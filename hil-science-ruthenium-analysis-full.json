[{"problem": "\nYou are given a directed graph represented as an adjacency matrix, where each element represents the weight of the edge between two nodes. Your task is to find the minimum number of edges that need to be removed from the graph to ensure that the resulting graph is acyclic and has the maximum possible number of edges. Additionally, you must return the resulting acyclic graph with the maximum number of edges.\n\nThe input to your function is a 2D array of real numbers, where each element represents the weight of the edge between two nodes. The function should return two values:\n1. The minimum number of edges that need to be removed to eliminate all cycles of any length, while ensuring that the resulting graph is acyclic and has the maximum possible number of edges.\n2. The resulting acyclic graph with the maximum number of edges, represented as a 2D array of real numbers.\n\nExample:\n- Input: graph = [[0,1.5,1.2],[1.5,0,1.0],[1.2,1.0,0]]\n- Output: (1, [[0,1.5,0],[1.5,0,1.0],[0,1.0,0]])\n- Explanation: The graph contains a cycle of length 3, so we need to remove at least one edge to eliminate it. Removing the edge between nodes 0 and 2 is sufficient, and the resulting graph is acyclic and has the maximum possible number of edges.\n\nThe function should be able to handle large graphs (up to 10,000 nodes) and efficiently find the minimum number of edges to remove and the resulting optimized acyclic graph. Additionally, the function should be able to handle graphs with real-valued edge weights between -100 and 100.\n", "startingSolution": "def minimum_edges_to_remove(graph):\r\n    n = len(graph)\r\n    \r\n    # Step 1: Detect all cycles using Floyd-Warshall algorithm\r\n    cycle_nodes = set()\r\n    dist = [[float('inf')] * n for _ in range(n)]\r\n    next_node = [[-1] * n for _ in range(n)]\r\n    \r\n    for i in range(n):\r\n        dist[i][i] = 0\r\n        for j in range(n):\r\n            if graph[i][j] != 0:\r\n                dist[i][j] = graph[i][j]\r\n                next_node[i][j] = j\r\n    \r\n    for k in range(n):\r\n        for i in range(n):\r\n            for j in range(n):\r\n                if dist[i][k] < float('inf') and dist[k][j] < float('inf') and dist[i][j] > dist[i][k] + dist[k][j]:\r\n                    dist[i][j] = dist[i][k] + dist[k][j]\r\n                    next_node[i][j] = next_node[i][k]\r\n                    if i == j and dist[i][i] < 0:  # Negative cycle detected\r\n                        cycle_nodes.add(i)\r\n    \r\n    if not cycle_nodes:\r\n        # No cycles detected, return original graph\r\n        return 0, graph\r\n    \r\n    # Step 2: Dynamic Programming to find the maximum number of edges to keep\r\n    dp = [[float('inf')] * (n + 1) for _ in range(n + 1)]\r\n    path = [[None] * (n + 1) for _ in range(n + 1)]\r\n    \r\n    dp[0][0] = 0\r\n    \r\n    for i in range(1, n + 1):\r\n        for j in range(n + 1):\r\n            dp[i][j] = dp[i - 1][j]  # Don't include node i\r\n            \r\n            # Include node i and calculate dp[i][j]\r\n            if j > 0:\r\n                for u in range(n):\r\n                    if dp[i - 1][j - 1] + dist[u][i - 1] < dp[i][j]:\r\n                        dp[i][j] = dp[i - 1][j - 1] + dist[u][i - 1]\r\n                        path[i][j] = u\r\n    \r\n    # Find the maximum number of edges we can keep\r\n    max_edges = 0\r\n    min_edges_to_remove = float('inf')\r\n    for j in range(n + 1):\r\n        if dp[n][j] < float('inf') and j > max_edges:\r\n            max_edges = j\r\n            min_edges_to_remove = dp[n][j]\r\n    \r\n    # Step 3: Reconstruct the resulting graph with max_edges\r\n    acyclic_graph = [[0] * n for _ in range(n)]\r\n    remaining_edges = max_edges\r\n    \r\n    for i in range(n, 0, -1):\r\n        if path[i][remaining_edges] is not None:\r\n            u = path[i][remaining_edges]\r\n            acyclic_graph[u][i - 1] = graph[u][i - 1]\r\n            remaining_edges -= 1\r\n    \r\n    return min_edges_to_remove, acyclic_graph\r\n\r\n# Example usage:\r\ngraph = [\r\n    [0, 1.5, 1.2],\r\n    [1.5, 0, 1.0],\r\n    [1.2, 1.0, 0]\r\n]\r\nmin_edges_removed, acyclic_graph = minimum_edges_to_remove(graph)\r\nprint(f\"Minimum edges to remove: {min_edges_removed}\")\r\nprint(\"Acyclic graph with maximum edges:\")\r\nfor row in acyclic_graph:\r\n    print(row)\r\n", "unitTests": [{"graph": "graph = [         [0, 1.5, 1.2],         [1.5, 0, 1.0],         [1.2, 1.0, 0]     ]", "expectedOutput": "1"}, {"expectedOutput": "0", "graph": "graph = [         [0, 2.5, 1.2],         [1.5, 0, 3.0],         [1.2, 2.0, 0]     ]"}, {"expectedOutput": "3", "graph": "graph = [         [0, 1.5, 1.2, 0, 0],         [1.5, 0, 1.0, 0, 0],         [1.2, 1.0, 0, 0, 0],         [0, 0, 0, 0, 2.0],         [0, 0, 0, 3.0, 0]     ]"}], "solution": "\nimport unittest\n\ndef minimum_edges_to_remove(graph):\n    n = len(graph)\n    \n    # Step 1: Detect all cycles using Floyd-Warshall algorithm\n    cycle_nodes = set()\n    dist = [[float('inf')] * n for _ in range(n)]\n    next_node = [[-1] * n for _ in range(n)]\n    \n    for i in range(n):\n        dist[i][i] = 0\n        for j in range(n):\n            if graph[i][j] != 0:\n                dist[i][j] = graph[i][j]\n                next_node[i][j] = j\n    \n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if dist[i][k] < float('inf') and dist[k][j] < float('inf') and dist[i][j] > dist[i][k] + dist[k][j]:\n                    dist[i][j] = dist[i][k] + dist[k][j]\n                    next_node[i][j] = next_node[i][k]\n                    if i == j and dist[i][i] < 0:  # Negative cycle detected\n                        cycle_nodes.add(i)\n    \n    if not cycle_nodes:\n        # No cycles detected, return original graph\n        return 0, graph\n    \n    # Step 2: Dynamic Programming to find the maximum number of edges to keep\n    dp = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    path = [[None] * (n + 1) for _ in range(n + 1)]\n    \n    dp[0][0] = 0\n    \n    for i in range(1, n + 1):\n        for j in range(n + 1):\n            dp[i][j] = dp[i - 1][j]  # Don't include node i\n            \n            # Include node i and calculate dp[i][j]\n            if j > 0:\n                for u in range(n):\n                    if dp[i - 1][j - 1] + dist[u][i - 1] < dp[i][j]:\n                        dp[i][j] = dp[i - 1][j - 1] + dist[u][i - 1]\n                        path[i][j] = u\n    \n    # Find the maximum number of edges we can keep\n    max_edges = 0\n    min_edges_to_remove = float('inf')\n    for j in range(n + 1):\n        if dp[n][j] < float('inf') and j > max_edges:\n            max_edges = j\n            min_edges_to_remove = dp[n][j]\n    \n    # Step 3: Reconstruct the resulting graph with max_edges\n    acyclic_graph = [[0] * n for _ in range(n)]\n    remaining_edges = max_edges\n    \n    for i in range(n, 0, -1):\n        if path[i][remaining_edges] is not None:\n            u = path[i][remaining_edges]\n            acyclic_graph[u][i - 1] = graph[u][i - 1]\n            remaining_edges -= 1\n    \n    return min_edges_to_remove, acyclic_graph\n\n# Example usage:\ngraph = [\n    [0, 1.5, 1.2],\n    [1.5, 0, 1.0],\n    [1.2, 1.0, 0]\n]\nmin_edges_removed, acyclic_graph = minimum_edges_to_remove(graph)\nprint(f\"Minimum edges to remove: {min_edges_removed}\")\nprint(\"Acyclic graph with maximum edges:\")\nfor row in acyclic_graph:\n    print(row)\n\n# Unit tests\nclass TestMinimumEdgesToRemove(unittest.TestCase):\n    def test_no_cycles(self):\n        graph = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\n        min_edges_removed, acyclic_graph = minimum_edges_to_remove(graph)\n        self.assertEqual(min_edges_removed, 0)\n        self.assertEqual(acyclic_graph, graph)\n\n    def test_single_cycle(self):\n        graph = [[0, 1.5, 1.2], [1.5, 0, 1.0], [1.2, 1.0, 0]]\n        min_edges_removed, acyclic_graph = minimum_edges_to_remove(graph)\n        self.assertEqual(min_edges_removed, 1)\n        self.assertEqual(acyclic_graph, [[0, 1.5, 0], [1.5, 0, 1.0], [0, 1.0, 0]])\n\n    def test_multiple_cycles(self):\n        graph = [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]]\n        min_edges_removed, acyclic_graph = minimum_edges_to_remove(graph)\n        self.assertEqual(min_edges_removed, 2)\n        self.assertEqual(acyclic_graph, [[0, 1, 0, 0], [1, 0, 0, 1], [0, 0, 0, 1], [0, 1, 1, 0]])\n\nif __name__ == '__main__':\n    unittest.main()\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-0", "worker": "725396297197498f"}, {"problem": "\nYou are given a 2D array grid of size m x n, where each cell represents a building. The value of each cell is the height of the building at that location. You are also given a non-negative integer maxHeight and a non-negative integer k.\n\nYour task is to find the maximum number of buildings that can be demolished while ensuring that the height of the remaining buildings does not exceed maxHeight, and the sum of the heights of the demolished buildings is at least k.\n\nThe rules for demolishing buildings are as follows:\n- You can demolish any number of buildings, as long as the height of the remaining buildings does not exceed maxHeight.\n- You can only demolish one building at a time, and you must demolish the building completely (you cannot partially demolish a building).\n- The demolition of a building does not affect the height of any other buildings.\n- The sum of the heights of the demolished buildings must be at least k.\n\nReturn the maximum number of buildings that can be demolished while satisfying the above conditions.\n\nExample:\n- grid = [[5,3,4,4,4,3],[3,2,4,3,3,3],[3,5,6,3,3,3]]\n- maxHeight = 4\n- k = 12\n- Output: 3\n  Explanation: We can demolish the buildings at (0,1), (0,2), and (1,0) to satisfy the condition that the height of the remaining buildings does not exceed 4 and the sum of the heights of the demolished buildings is at least 12.\n\nNote:\n- 1 <= m, n <= 50\n- 0 <= grid[i][j] <= 50\n- 0 <= maxHeight <= 50\n- 0 <= k <= 1000\n", "startingSolution": "def maxDemolishedBuildings(grid, maxHeight, k):\r\n    m = len(grid)\r\n    n = len(grid[0])\r\n    \r\n    # List to store the heights of buildings greater than maxHeight\r\n    candidates = []\r\n    \r\n    # Collect all heights greater than maxHeight\r\n    for i in range(m):\r\n        for j in range(n):\r\n            if grid[i][j] > maxHeight:\r\n                candidates.append(grid[i][j])\r\n    \r\n    # Sort the list in descending order\r\n    candidates.sort(reverse=True)\r\n    \r\n    demolished_count = 0\r\n    height_sum = 0\r\n    \r\n    # Demolish buildings until the sum of heights is at least k\r\n    for height in candidates:\r\n        if height_sum >= k:\r\n            break\r\n        height_sum += height\r\n        demolished_count += 1\r\n    \r\n    # Check if we reached the required sum of heights\r\n    if height_sum >= k:\r\n        return demolished_count\r\n    else:\r\n        return 0\r\n\r\n# Example usage\r\ngrid = [\r\n    [5, 3, 4, 4, 4, 3],\r\n    [3, 2, 4, 3, 3, 3],\r\n    [3, 5, 6, 3, 3, 3]\r\n]\r\nmaxHeight = 4\r\nk = 12\r\n\r\nprint(maxDemolishedBuildings(grid, maxHeight, k))  # Output: 3\r\n", "unitTests": [{"grid": "grid = [         [5, 3, 4, 4, 4, 3],         [3, 2, 4, 3, 3, 3],         [3, 5, 6, 3, 3, 3]     ]", "maxHeight": "4", "k": "12", "expectedOutput": "3"}, {"expectedOutput": "0", "grid": "grid = [         [2, 3, 1],         [3, 2, 3],         [1, 2, 2]     ]", "maxHeight": "3", "k": "5"}, {"expectedOutput": "2", "grid": "grid = [         [10, 15, 20],         [5, 25, 30],         [35, 40, 45]     ]", "maxHeight": "4", "k": "60"}], "solution": "\ndef maxDemolishedBuildings(grid, maxHeight, k):\n    m = len(grid)\n    n = len(grid[0])\n    \n    # List to store the heights of buildings greater than maxHeight\n    candidates = []\n    \n    # Collect all heights greater than maxHeight\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] > maxHeight:\n                candidates.append(grid[i][j])\n    \n    # Sort the list in descending order\n    candidates.sort(reverse=True)\n    \n    demolished_count = 0\n    height_sum = 0\n    \n    # Demolish buildings until the sum of heights is at least k\n    for height in candidates:\n        if height_sum >= k:\n            break\n        height_sum += height\n        demolished_count += 1\n    \n    # Check if we reached the required sum of heights\n    if height_sum >= k:\n        return demolished_count\n    else:\n        return 0\n\n# Supplemental code for verifying the solution\ndef test_maxDemolishedBuildings():\n    # Test case 1\n    grid = [\n        [5, 3, 4, 4, 4, 3],\n        [3, 2, 4, 3, 3, 3],\n        [3, 5, 6, 3, 3, 3]\n    ]\n    maxHeight = 4\n    k = 12\n    assert maxDemolishedBuildings(grid, maxHeight, k) == 3\n\n    # Test case 2\n    grid = [\n        [4, 4, 5, 6],\n        [2, 2, 2, 3],\n        [3, 1, 2, 4],\n        [2, 4, 5, 3],\n        [3, 1, 2, 4]\n    ]\n    maxHeight = 4\n    k = 5\n    assert maxDemolishedBuildings(grid, maxHeight, k) == 0\n\n    # Test case 3\n    grid = [\n        [5, 4, 4, 4, 4, 3, 3],\n        [3, 3, 3, 3, 3, 3, 3],\n        [3, 5, 6, 7, 3, 3, 3]\n    ]\n    maxHeight = 4\n    k = 10\n    assert maxDemolishedBuildings(grid, maxHeight, k) == 2\n\n    print(\"All test cases passed!\")\n\ntest_maxDemolishedBuildings()\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-1", "worker": "725396297197498f"}, {"problem": "You are given a string `s` and a set of strings `words`. Your task is to implement a function that finds the lexicographically smallest sequence of contiguous, non-overlapping substrings of `s` that can be formed by concatenating zero or more unique strings from `words`, such that the resulting concatenation is equal to `s`. Additionally, the function must return the minimum total length of the substrings in the sequence, the minimum number of substrings in the sequence, the minimum number of unique words from the `words` set used to form the target string `s`, the minimum number of unique characters in the substrings, and the maximum number of consecutive substrings in the sequence.\n\nThe function must also satisfy the following additional requirements:\n\n1. The function must handle cases where the words in the `words` set are not necessarily unique, but the function must use each word in the `words` set at most once to form the target string `s`.\n2. The function must return the lexicographically smallest sequence of contiguous, non-overlapping substrings required to form `s` using the words in `words`, the minimum total length of the substrings in the sequence, the minimum number of substrings in the sequence, the minimum number of unique words used, the minimum number of unique characters in the substrings, and the maximum number of consecutive substrings in the sequence. If it is impossible to form `s` using the given `words`, the function should return an empty list, -1, -1, -1, -1, and -1.\n3. The time complexity of the function must be at most O(n * m * log(m)), where n is the length of the string `s` and m is the number of words in the `words` set.\n4. The words in the `words` set can be of varying lengths, and the function must be able to handle this case.\n\nThe function should take the following input:\n- A string `s` representing the target string.\n- A set of strings `words` representing the available words that can be used to form the target string.\n\nThe function should return the lexicographically smallest sequence of contiguous, non-overlapping substrings of `s` that can be formed by concatenating zero or more unique strings from `words`, such that the resulting concatenation is equal to `s`. The function should also return the minimum total length of the substrings in the sequence, the minimum number of substrings in the sequence, the minimum number of unique words from the `words` set used to form the target string `s`, the minimum number of unique characters in the substrings, and the maximum number of consecutive substrings in the sequence. If it is impossible to form `s` using the given `words`, the function should return an empty list, -1, -1, -1, -1, and -1.\n\nExample:\n```\ns = \"leetcode\"\nwords = [\"leet\", \"code\", \"leet\", \"code\"]\nOutput: [\"leet\", \"code\"], 8, 2, 2, 8, 2\nExplanation:\nThe target string \"leetcode\" can be formed by concatenating the contiguous, non-overlapping substrings \"leet\" and \"code\", which is the lexicographically smallest sequence of substrings. The minimum total length of the substrings is 8, the minimum number of substrings is 2, the minimum number of unique words used is 2, the minimum number of unique characters in the substrings is 8, and the maximum number of consecutive substrings is 2.\n\ns = \"applepenapple\"\nwords = [\"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\"]\nOutput: [\"apple\", \"pen\", \"apple\"], 13, 3, 2, 6, 3\nExplanation:\nThe target string \"applepenapple\" can be formed by concatenating the contiguous, non-overlapping substrings \"apple\", \"pen\", and \"apple\", which is the lexicographically smallest sequence of substrings. The minimum total length of the substrings is 13, the minimum number of substrings is 3, the minimum number of unique words used is 2, the minimum number of unique characters in the substrings is 6, and the maximum number of consecutive substrings is 3.\n\ns = \"catsandog\"\nwords = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\nOutput: [], -1, -1, -1, -1, -1\nExplanation:\nIt is impossible to form the target string \"catsandog\" using the given words.", "startingSolution": "def find_min_unique_substring_sequence(s: str, words: list[str]) -> tuple[list[str], int, int, int, int, int]:\r\n    \"\"\"\r\n    Given a string `s` and a set of strings `words`, find the lexicographically smallest sequence of contiguous, non-overlapping substrings of `s` that can be formed by concatenating zero or more unique strings from `words`, such that the resulting concatenation is equal to `s`. Additionally, return the minimum total length of the substrings in the sequence, the minimum number of substrings in the sequence, the minimum number of unique words from the `words` set used to form the target string `s`, the minimum number of unique characters in the substrings, and the maximum number of consecutive substrings in the sequence.\r\n\r\n    The function must handle cases where the words in the `words` set are not necessarily unique, but the function must use each word in the `words` set at most once to form the target string `s`.\r\n\r\n    Args:\r\n        s (str): The target string.\r\n        words (list[str]): The available words that can be used to form the target string.\r\n\r\n    Returns:\r\n        Tuple[List[str], int, int, int, int, int]: The lexicographically smallest sequence of contiguous, non-overlapping substrings of `s` that can be formed by concatenating zero or more unique strings from `words`, the minimum total length of the substrings in the sequence, the minimum number of substrings in the sequence, the minimum number of unique words from the `words` set used to form the target string `s`, the minimum number of unique characters in the substrings, and the maximum number of consecutive substrings in the sequence. If it is impossible to form `s` using the given `words`, the function should return an empty list, -1, -1, -1, -1, and -1.\r\n    \"\"\"\r\n    pass", "unitTests": [{"": "s=\"applepenapple\", words=[\"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\", \"apple\"]", "expectedOutput": "([\"applepen\", \"apple\"], 13, 2, 2, 5, 3))"}, {"expectedOutput": "([], -1, -1, -1, -1, -1))", "": "s=\"catsandog\", words=[\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]"}, {"expectedOutput": "([\"leet\", \"code\"], 8, 2, 2, 6, 2))", "": "s=\"leetcode\", words=[\"leet\", \"code\", \"leet\", \"code\"]"}, {"expectedOutput": "([\"leet\", \"code\", \"andcodeforces\", \"leet\", \"code\"], 29, 5, 3, 11, 7)", "": "s=\"leetcodeandcodeforcesleetcode\", words=[ \"leet\", \"code\", \"leet\", \"code\", \"and\", \"codeforces\", \"andcodeforces\", \"code\", \"forces\", \"test\" ]"}], "solution": "from __future__ import annotations\r\n\r\nfrom dataclasses import dataclass\r\n\r\n\r\n@dataclass\r\nclass TrieTreeNode:\r\n    child_node: dict[str, TrieTreeNode]\r\n    words: dict[str, int]\r\n\r\n\r\ndef _add_to_trie_tree(root: TrieTreeNode, word: str, idx: int):\r\n    if word[idx] not in root.child_node:\r\n        root.child_node[word[idx]] = TrieTreeNode({}, {})\r\n\r\n    if idx + 1 == len(word):\r\n        if word not in root.words:\r\n            root.words[word] = 0\r\n\r\n        root.words[word] += 1\r\n\r\n        return\r\n\r\n    _add_to_trie_tree(root.child_node[word[idx]], word, idx + 1)\r\n\r\n\r\ndef _get_candidates_from_trie_tree(root: TrieTreeNode, s: str, substr: str,\r\n                                   idx: int, used: dict[str, int],\r\n                                   result: list[str]):\r\n    if idx == len(s):\r\n        return\r\n\r\n    if s[idx] in root.child_node:\r\n        word = substr + s[idx]\r\n\r\n        if word in root.words and (word not in used\r\n                                   or root.words[word] > used[word]):\r\n            result.append(word)\r\n\r\n        _get_candidates_from_trie_tree(root.child_node[s[idx]], s, word,\r\n                                       idx + 1, used, result)\r\n\r\n\r\ndef _lexicographically_smallest_sequence(trie_tree: TrieTreeNode,\r\n                                         s: str) -> list[str]:\r\n    n = len(s)\r\n    dp: list[str] = [\"\"] * (n + 1)\r\n    prev = [-1] * (n + 1)\r\n    used_words: list[dict[str, int]] = [{}] * (n + 1)\r\n\r\n    for i in range(n):\r\n        if i == 0 or len(used_words[i]) > 0:\r\n            candidates: list[str] = []\r\n            _get_candidates_from_trie_tree(trie_tree, s, \"\", i, used_words[i],\r\n                                           candidates)\r\n            for word in candidates:\r\n                next = i + len(word)\r\n\r\n                if dp[next] == \"\" or word < dp[next]:\r\n                    dp[next] = word\r\n                    prev[next] = i\r\n                    used_words[next] = dict(used_words[i])\r\n\r\n                    if word in used_words[i]:\r\n                        used_words[next][word] += 1\r\n                    else:\r\n                        used_words[next][word] = 1\r\n\r\n    result = []\r\n    idx = n\r\n\r\n    while idx > 0:\r\n        prev_idx = prev[idx]\r\n        result.append(dp[idx])\r\n        idx = prev_idx\r\n\r\n    result.reverse()\r\n\r\n    return result\r\n\r\n\r\ndef _get_maximum_minimum_number_of_consecutive_substrings(\r\n        trie_tree: TrieTreeNode, s: str) -> tuple[int, int]:\r\n    n = len(s)\r\n    dp_min = [10**18] * (n + 1)\r\n    dp_min[0] = 0\r\n    dp_max = [-1] * (n + 1)\r\n    dp_max[0] = 0\r\n    used_words_min: list[dict[str, int]] = [{}] * (n + 1)\r\n    used_words_max: list[dict[str, int]] = [{}] * (n + 1)\r\n\r\n    for i in range(n):\r\n        if i == 0 or len(used_words_min[i]) > 0:\r\n            candidates: list[str] = []\r\n            _get_candidates_from_trie_tree(trie_tree, s, \"\", i,\r\n                                           used_words_min[i], candidates)\r\n            for word in candidates:\r\n                new_len = dp_min[i] + 1\r\n                next = i + len(word)\r\n\r\n                if new_len < dp_min[next]:\r\n                    dp_min[next] = new_len\r\n                    used_words_min[next] = dict(used_words_min[i])\r\n\r\n                    if word not in used_words_min[next]:\r\n                        used_words_min[next][word] = 1\r\n                    else:\r\n                        used_words_min[next][word] += 1\r\n\r\n        if i == 0 or len(used_words_max[i]) > 0:\r\n            candidates = []\r\n            _get_candidates_from_trie_tree(trie_tree, s, \"\", i,\r\n                                           used_words_max[i], candidates)\r\n            for word in candidates:\r\n                new_len = dp_max[i] + 1\r\n                next = i + len(word)\r\n\r\n                if new_len > dp_max[next]:\r\n                    dp_max[next] = new_len\r\n                    used_words_max[next] = dict(used_words_max[i])\r\n\r\n                    if word not in used_words_max[next]:\r\n                        used_words_max[next][word] = 1\r\n                    else:\r\n                        used_words_max[next][word] += 1\r\n\r\n    return (dp_max[n], dp_min[n])\r\n\r\n\r\ndef _minimum_number_of_unique_words_used(trie_tree: TrieTreeNode, s: str):\r\n    n = len(s)\r\n    dp = [10**18] * (n + 1)\r\n    dp[0] = 0\r\n    used_words: list[dict[str, int]] = [{}] * (n + 1)\r\n\r\n    for i in range(n):\r\n        if i == 0 or len(used_words[i]) > 0:\r\n            candidates: list[str] = []\r\n            _get_candidates_from_trie_tree(trie_tree, s, \"\", i, used_words[i],\r\n                                           candidates)\r\n            for word in candidates:\r\n                new_len = dp[i] + 0 if word in used_words[i] else 1\r\n                next = i + len(word)\r\n\r\n                if new_len < dp[next]:\r\n                    dp[next] = new_len\r\n                    used_words[next] = dict(used_words[i])\r\n\r\n                    if word not in used_words[next]:\r\n                        used_words[next][word] = 1\r\n                    else:\r\n                        used_words[next][word] += 1\r\n\r\n    return len(used_words[n])\r\n\r\n\r\ndef find_min_unique_substring_sequence(\r\n        s: str, words: list[str]) -> tuple[list[str], int, int, int, int, int]:\r\n    \"\"\"\r\n    Given a string `s` and a set of strings `words`, find the lexicographically smallest sequence of contiguous, non-overlapping substrings of `s` that can be formed by concatenating zero or more unique strings from `words`, such that the resulting concatenation is equal to `s`. Additionally, return the minimum total length of the substrings in the sequence, the minimum number of substrings in the sequence, the minimum number of unique words from the `words` set used to form the target string `s`, the minimum number of unique characters in the substrings, and the maximum number of consecutive substrings in the sequence.\r\n\r\n    The function must handle cases where the words in the `words` set are not necessarily unique, but the function must use each word in the `words` set at most once to form the target string `s`.\r\n\r\n    Args:\r\n        s (str): The target string.\r\n        words (list[str]): The available words that can be used to form the target string.\r\n\r\n    Returns:\r\n        Tuple[List[str], int, int, int, int, int]: The lexicographically smallest sequence of contiguous, non-overlapping substrings of `s` that can be formed by concatenating zero or more unique strings from `words`, the minimum total length of the substrings in the sequence, the minimum number of substrings in the sequence, the minimum number of unique words from the `words` set used to form the target string `s`, the minimum number of unique characters in the substrings, and the maximum number of consecutive substrings in the sequence. If it is impossible to form `s` using the given `words`, the function should return an empty list, -1, -1, -1, -1, and -1.\r\n    \"\"\"\r\n    words_trie_tree = TrieTreeNode({}, {})\r\n\r\n    for word in words:\r\n        _add_to_trie_tree(words_trie_tree, word, 0)\r\n\r\n    maximum_number_of_consecutive_substrings, minimum_number_of_consecutive_substrings = _get_maximum_minimum_number_of_consecutive_substrings(\r\n        words_trie_tree, s)\r\n\r\n    if maximum_number_of_consecutive_substrings == -1 and len(s) > 0:\r\n        return ([], -1, -1, -1, -1, -1)\r\n\r\n    minimum_number_of_unique_characters = len(set(s))\r\n    minimum_total_length_of_the_substrings = len(s)\r\n    minimum_number_of_unique_words_used = _minimum_number_of_unique_words_used(\r\n        words_trie_tree, s)\r\n    lexicographically_smallest_sequence = _lexicographically_smallest_sequence(\r\n        words_trie_tree, s)\r\n\r\n    return (lexicographically_smallest_sequence,\r\n            minimum_total_length_of_the_substrings,\r\n            minimum_number_of_consecutive_substrings,\r\n            minimum_number_of_unique_words_used,\r\n            minimum_number_of_unique_characters,\r\n            maximum_number_of_consecutive_substrings)\r\n", "meetsStartingSolutionFormatCriteria": true, "meetsFinalSolutionFormatCriteria": true, "meetsCorrectnessCriteria": true, "meetsDifficultyCriteria": false, "id": "example-2", "worker": "94607a49db8dc666"}, {"problem": "\\nYou are given a 2D grid of size m x n, where each cell represents a building. Each building is either a residential building or a commercial building, represented by the values 0 and 1, respectively.\\n\\nYour task is to design a transportation system that connects all the commercial buildings, while minimizing the total distance traveled by the transportation vehicles. The transportation vehicles can only move horizontally or vertically between adjacent cells.\\n\\nThe input to your function is a 2D array grid, where grid[i][j] is 0 if the building at row i and column j is a residential building, and 1 if it is a commercial building.\\n\\nYour function should return the minimum total distance that the transportation vehicles need to travel to connect all the commercial buildings.\\n\\nExample:\\n- grid = [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]\\n- Output: 10\\n- Explanation: The minimum total distance that the transportation vehicles need to travel is 10, as shown in the image below.\\n\\n[Image showing the grid with the optimal transportation routes connecting the commercial buildings]\\", "startingSolution": "\ndef connect_commercial_buildings(grid):\n    \"\"\"\n    Connects all the commercial buildings in the given 2D grid while minimizing the total distance traveled.\n    Time Constraint: The transportation vehicles need to connect all commercial buildings within a certain time limit.\n    1. Weight: Each road between commercial buildings has a maximum weight capacity.\n    2. Priority: Some commercial buildings have higher priority and must be connected first.\n    3. Initial Road Costs: Some roads already exist with given costs, and these costs should be minimized.\n    4. Weather: when forecast is bad and wind blow from North the road can build only in horisontal direction and probability of bad weather is 50%.\n\n    Args:\n        grid (List[List[int]]): A 2D grid of size m x n, where each cell represents a building (0 for residential, 1 for commercial).\n\n    Returns:\n        int: The minimum total distance that the transportation vehicles need to travel to connect all the commercial buildings.\n    \"\"\"\n   ", "unitTests": [{"grid": "[     [0, 1, 0, 0],     [1, 0, 1, 0],     [0, 1, 0, 1],     [0, 0, 1, 0] ]", "expectedOutput": "10"}, {"expectedOutput": "0", "grid": "[[]]"}, {"expectedOutput": "0", "grid": "[[0, 0, 0], [0, 0, 0], [0, 0, 0]]"}, {"expectedOutput": "8", "grid": "[[1,1,1],[1,1,1],[1,1,1]]"}], "solution": "\nfrom typing import List\nfrom collections import defaultdict\nimport heapq\n\ndef connect_commercial_buildings(grid: List[List[int]]) -> int:\n    \"\"\"\n    Connects all the commercial buildings in the given 2D grid while minimizing the total distance traveled.\n    Time Constraint: The transportation vehicles need to connect all commercial buildings within a certain time limit.\n    1. Weight: Each road between commercial buildings has a maximum weight capacity.\n    2. Priority: Some commercial buildings have higher priority and must be connected first.\n    3. Initial Road Costs: Some roads already exist with given costs, and these costs should be minimized.\n    4. Weather: when forecast is bad and wind blow from North the road can build only in horisontal direction and probability of bad weather is 50%.\n\n    Args:\n        grid (List[List[int]]): A 2D grid of size m x n, where each cell represents a building (0 for residential, 1 for commercial).\n\n    Returns:\n        int: The minimum total distance that the transportation vehicles need to travel to connect all the commercial buildings.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    commercial_buildings = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    if len(commercial_buildings) <= 1:\n        return 0\n\n    # Initialize the graph\n    graph = defaultdict(list)\n    for i in range(len(commercial_buildings)):\n        for j in range(i + 1, len(commercial_buildings)):\n            x1, y1 = commercial_buildings[i]\n            x2, y2 = commercial_buildings[i]\n            distance = abs(x1 - x2) + abs(y1 - y2)\n            graph[(x1, y1)].append((distance, (x2, y2)))\n            graph[(x2, y2)].append((distance, (x1, y1)))\n\n    # Prim's algorithm\n    start = commercial_buildings[0]\n    pq = [(0, start)]\n    visited = set()\n    total_distance = 0\n\n    while pq:\n        dist, node = heapq.heappop(pq)\n        if node not in visited:\n            visited.add(node)\n            total_distance += dist\n            for neighbor_dist, neighbor in graph[node]:\n                heapq.heappush(pq, (neighbor_dist, neighbor))\n\n    return total_distance\n\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-3", "worker": "057f47b83434cfb3"}, {"problem": "You are given a 2D grid of size  m * n, where each cell represents a building. The value of each cell is the height of the building at that location. The grid size can be as large as 500 * 500, and building heights can be large, with values up to 10^6 . There can be multiple buildings of the same height in the grid.\n\nYour task is to find the maximum number of buildings that can be seen from a single vantage point. The vantage point can be placed anywhere on the grid, including the edges and corners, and it has a 360-degree view. A building is considered visible from the vantage point if there is no other building taller than it in the line of sight between the vantage point and the building.\n\nThe function should take the grid as input and return the maximum number of buildings that can be seen from a single vantage point.\n\nExample:\n\n- grid = [[3, 7, 8, 6, 5, 5],\n         [2, 3, 3, 2, 3, 4],\n         [2, 2, 2, 2, 3, 3],\n         [10, 10, 10, 10, 10, 10],\n         [10, 1, 1, 1, 1, 10],\n         [10, 10, 10, 10, 10, 10]]\n- Output: 11\n- Explanation: The vantage point can be placed at (4, 1) to see 11 buildings: (4, 0), (3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (4, 5), (5, 1), (5, 2), and (5, 3).", "startingSolution": "\ndef max_visible_buildings(grid):\n\"\"\"\n    Given a 2D grid of building heights, find the maximum number of buildings\n    that can be seen from a single vantage point with a 360-degree view.\n\n    Args:\n    grid (List[List[int]]): A 2D array of integers representing the heights of the buildings.\n\n    Returns:\n    int: The maximum number of buildings that can be seen from a single vantage point.\n\n    Example:\n    grid = [\n        [3, 7, 8, 6, 5, 5],\n        [2, 3, 3, 2, 3, 4],\n        [2, 2, 2, 2, 3, 3],\n        [10, 10, 10, 10, 10, 10],\n        [10, 1, 1, 1, 1, 10],\n        [10, 10, 10, 10, 10, 10]\n    ]\n    Output: 11\n    Explanation: The vantage point can be placed at (4, 1) to see 11 buildings: (4, 0), (3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (4, 5), (5, 1), (5, 2), and (5, 3).\n\n    Constraints:\n    - The grid size can be as large as 500 x 500.\n    - Building heights can be large, with values up to 10^6.\n    - There can be multiple buildings of the same height in the grid.\n    - The vantage point can be placed at any cell in the grid, including the edges and corners.\n    \"\"\"\n    pass\n", "unitTests": [{"grid": "grid1 = [         [3, 7, 8, 6, 5, 5],         [2, 3, 3, 2, 3, 4],         [2, 2, 2, 2, 3, 3],         [10, 10, 10, 10, 10, 10],         [10, 1, 1, 1, 1, 10],         [10, 10, 10, 10, 10, 10],     ]", "expectedOutput": "11"}, {"expectedOutput": "8", "grid": "grid2 = [         [5, 1, 4, 2, 8, 5, 6, 7],         [6, 1, 3, 1, 9, 8, 2, 3],         [2, 7, 6, 1, 1, 1, 4, 9],         [1, 1, 1, 1, 1, 2, 3, 2],         [9, 9, 8, 7, 6, 5, 4, 3],     ]"}, {"expectedOutput": "13", "grid": "grid3 = [         [10, 10, 10, 10, 10, 10, 10],         [10, 1, 1, 1, 1, 1, 10],         [10, 1, 9, 9, 9, 1, 10],         [10, 1, 1, 1, 1, 1, 10],         [10, 10, 10, 10, 10, 10, 10],     ]"}], "solution": "\ndef max_visible_buildings(grid):\n    \"\"\"\n    Given a 2D grid of building heights, find the maximum number of buildings\n    that can be seen from a single vantage point with a 360-degree view.\n\n    Args:\n    grid (List[List[int]]): A 2D array of integers representing the heights of the buildings.\n\n    Returns:\n    int: The maximum number of buildings that can be seen from a single vantage point.\n\n    Example:\n    grid = [\n        [3, 7, 8, 6, 5, 5],\n        [2, 3, 3, 2, 3, 4],\n        [2, 2, 2, 2, 3, 3],\n        [10, 10, 10, 10, 10, 10],\n        [10, 1, 1, 1, 1, 10],\n        [10, 10, 10, 10, 10, 10]\n    ]\n    Output: 11\n    Explanation: The vantage point can be placed at (4, 1) to see 11 buildings: (4, 0), (3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (4, 5), (5, 1), (5, 2), and (5, 3).\n\n    Constraints:\n    - The grid size can be as large as 500 x 500.\n    - Building heights can be large, with values up to 10^6.\n    - There can be multiple buildings of the same height in the grid.\n    - The vantage point can be placed at any cell in the grid, including the edges and corners.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    max_visible = 0\n\n    for i in range(m):\n        for j in range(n):\n            visible = 0\n            max_height = -1\n\n            for x in range(m):\n                for y in range(n):\n                    if (x, y) != (i, j) and (abs(x - i) + abs(y - j)) <= max(m, n):\n                        if grid[x][y] <= grid[i][j]:\n                            visible += 1\n                        elif grid[x][y] > max_height:\n                            max_height = grid[x][y]\n\n            max_visible = max(max_visible, visible)\n\n    return max_visible\n", "meetsStartingSolutionFormatCriteria": true, "meetsFinalSolutionFormatCriteria": true, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": true, "id": "example-4", "worker": "0a5cceb1127927f6"}, {"problem": "You are given a 2D grid of size \\( m \\times n \\), where each cell represents a point on a Cartesian plane. The grid is divided into regions of arbitrary shapes, where each region is defined by a set of points with the same color.\n\nYour task is to implement a function that, given the grid and a set of queries, determines the minimum distance between any two points in the same region for each query.\n\nThe function takes the following input:\n- A 2D array `grid`, where `grid[i][j]` represents the color of the cell at row `i` and column `j`. The colors are represented as integers. The grid can be large, with \\( 1 \\leq m, n \\leq 200 \\) and up to 1000 different color values.\n- A 2D array `queries`, where `queries[k] = [r1, c1, r2, c2]` represents a query to find the minimum distance between any two points in the same region within the rectangular area defined by the top-left corner `(r1, c1)` and the bottom-right corner `(r2, c2)`. The number of queries can be up to 100.\n\nThe function should return a 1D array, where the kth element represents the minimum distance between any two points in the same region for the kth query. If no such pair of points exists within the specified region for a particular query, return -1 for that query.\n\nThe minimum distance between two points `(x1, y1)` and `(x2, y2)` is defined as \\( \\sqrt{(x1 - x2)^2 + (y1 - y2)^2} \\).\n\nNote that the grid may contain regions of arbitrary size and shape, including non-contiguous areas, and the queries may overlap with multiple regions.", "startingSolution": "\ndef min_region_distance(grid, queries):\n    \"\"\"\n    Given a 2D grid of colors and a set of queries, determine the minimum distance between any two points in the same region for each query.\n\n    Args:\n        grid (List[List[int]]): A 2D array of integers representing the colors of the cells in the grid.\n        queries (List[List[int]]): A 2D array of integers, where each inner list represents a query with the format [r1, c1, r2, c2], where (r1, c1) is the top-left corner and (r2, c2) is the bottom-right corner of the rectangular region to search.\n\n    Returns:\n        List[float]: A 1D array of floats, where the kth element represents the minimum distance between any two points in the same region for the kth query. If no such pair of points exists within the specified region for a particular query, the function should return -1 for that query.\n    \"\"\"\n    pass\n", "unitTests": [{"expectedOutput": "[1.0, 1.0, 1.414]", "grid": "grid1 = [[1, 1, 2], [3, 1, 2], [3, 3, 2]]", "queries": "queries1 = [[0, 0, 1, 1], [0, 2, 2, 2], [1, 0, 2, 1],]"}, {"expectedOutput": "[1.0, 1.0, -1]", "grid": "grid2 = [[4, 4, 4, 5], [4, 5, 5, 5], [6, 6, 5, 5]]", "queries": "queries2 = [[0, 0, 1, 1], [0, 2, 2, 3], [2, 0, 2, 1],]"}, {"expectedOutput": "[1.0, 1.0, 1.0]", "grid": "grid3 = [[7, 8, 8, 9], [7, 8, 9, 9], [7, 8, 8, 9]]", "queries": "queries3 = [[0, 0, 2, 0], [0, 1, 2, 2], [0, 3, 2, 3],]"}], "solution": "\nimport math\nfrom typing import List\n\ndef min_region_distance(grid: List[List[int]], queries: List[List[int]]) -> List[float]:\n    \"\"\"\n    Given a 2D grid of colors and a set of queries, determine the minimum distance between any two points in the same region for each query.\n\n    Args:\n        grid (List[List[int]]): A 2D array of integers representing the colors of the cells in the grid.\n        queries (List[List[int]]): A 2D array of integers, where each inner list represents a query with the format [r1, c1, r2, c2], where (r1, c1) is the top-left corner and (r2, c2) is the bottom-right corner of the rectangular region to search.\n\n    Returns:\n        List[float]: A 1D array of floats, where the kth element represents the minimum distance between any two points in the same region for the kth query. If no such pair of points exists within the specified region for a particular query, the function should return -1 for that query.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    parent = {(i, j): (i, j) for i in range(m) for j in range(n)}\n    rank = {(i, j): 0 for i in range(m) for j in range(n)}\n\n    def find(x, y):\n        if parent[(x, y)] != (x, y):\n            parent[(x, y)] = find(*parent[(x, y)])\n        return parent[(x, y)]\n\n    def union(x1, y1, x2, y2):\n        px1, py1 = find(x1, y1)\n        px2, py2 = find(x2, y2)\n        if px1 == px2 and py1 == py2:\n            return\n        if rank[(px1, py1)] < rank[(px2, py2)]:\n            parent[(px1, py1)] = (px2, py2)\n        elif rank[(px1, py1)] > rank[(px2, py2)]:\n            parent[(px2, py2)] = (px1, py1)\n        else:\n            parent[(px2, py2)] = (px1, py1)\n            rank[(px1, py1)] += 1\n\n    for i in range(m):\n        for j in range(n):\n            if i > 0 and grid[i][j] == grid[i-1][j]:\n                union(i, j, i-1, j)\n            if j > 0 and grid[i][j] == grid[i][j-1]:\n                union(i, j, i, j-1)\n\n    def min_distance(r1, c1, r2, c2):\n        min_dist = float('inf')\n        for i in range(r1, r2+1):\n            for j in range(c1, c2+1):\n                for k in range(r1, r2+1):\n                    for l in range(c1, c2+1):\n                        if find(i, j) == find(k, l):\n                            min_dist = min(min_dist, math.sqrt((i-k)**2 + (j-l)**2))\n        return min_dist if min_dist != float('inf') else -1\n\n    return [min_distance(*query) for query in queries]\n", "meetsStartingSolutionFormatCriteria": true, "meetsFinalSolutionFormatCriteria": true, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-5", "worker": "0a5cceb1127927f6"}, {"problem": "Given a directed graph G = (V, E), where V is the set of vertices and E is the set of directed edges, and each edge (u, v) ∈ E has an associated weight w(u, v), your task is to find the maximum number of non-overlapping paths in the graph that satisfy the following conditions:\n\n1. Each path must start at a designated source vertex s and end at a designated target vertex t.\n2. The paths must be both vertex-disjoint and edge-disjoint, meaning that no two paths can share a common vertex (except for the source and target vertices) or a common edge.\n3. Each path must have a length (number of edges) of at least k, where k is a positive integer provided as input.\n4. The lengths of the paths must be in non-decreasing order, meaning that the length of each path must be greater than or equal to the length of the previous path.\n5. The starting vertices of the paths must be in non-decreasing order, meaning that the starting vertex of each path must be greater than or equal to the starting vertex of the previous path.\n6. The total number of paths returned must not exceed a given limit, L, where L is a positive integer provided as input.\n7. The paths must form a simplicial complex-like structure, where each path intersects with at least one other path at a specific vertex, and the set of vertices visited by the paths must form a simplicial complex in the graph.\n8. The total distance between the vertices in all the paths combined, where the distance between two vertices is defined as the sum of the weights of the edges in the shortest path between them, must not exceed a given limit, D, where D is a positive integer provided as input.\n9. The paths must be sorted in non-decreasing order by the maximum weight of the edges they traverse.\n\nThe function should take the following input:\n- V: the set of vertices in the graph\n- E: the set of directed edges in the graph, where each edge is represented as a tuple (u, v) indicating a directed edge from vertex u to vertex v, and each edge has an associated weight w(u, v)\n- s: the source vertex\n- t: the target vertex\n- k: a positive integer representing the minimum length requirement for each path\n- L: a positive integer representing the maximum number of paths that the function can return\n- D: a positive integer representing the maximum total distance between the vertices in all the paths combined\n\nThe function should return a list representing the maximum number of edge-disjoint paths from the source s to the target t, where each path has a length of at least k, the lengths of the paths are in non-decreasing order, the starting vertices of the paths are in non-decreasing order, the paths form a simplicial complex-like structure, the total distance between the vertices in all the paths combined does not exceed D, and the paths are sorted in non-decreasing order by the maximum weight of the edges they traverse, subject to the constraint that the total number of paths returned must not exceed L.\n\nExample:\n- Input: V = {1, 2, 3, 4, 5, 6}, E = {(1, 2, 2), (2, 3, 3), (3, 4, 4), (4, 5, 5), (5, 6, 6), (1, 6, 1)}, s = 1, t = 6, k = 2, L = 3, D = 20\n- Output: [[1, 6]]\n- Explanation: The maximum number of edge-disjoint paths from 1 to 6, where each path has a length of at least 2, the lengths are in non-decreasing order, the starting vertices are in non-decreasing order, the paths form a simplicial complex-like structure, the total distance between the vertices in all the paths combined does not exceed 20, the paths are sorted in non-decreasing order by the maximum weight of the edges they traverse, and the total number of paths does not exceed 3, is 1. One possible configuration is:\n  - Path 1: 1 -> 6", "startingSolution": "def count_disjoint_paths(V: set[int], E: set[tuple[int, int, int]], s: int, t: int, k: int, L: int, D: int) -> list[list[int]]:\r\n    \"\"\"\r\n    Given a directed graph G = (V, E), where V is the set of vertices and E is the set of directed edges, and each edge (u, v) ∈ E has an associated weight w(u, v), your task is to find the maximum number of non-overlapping paths in the graph that satisfy the following conditions:\r\n\r\n    1. Each path must start at a designated source vertex s and end at a designated target vertex t.\r\n    2. The paths must be both vertex-disjoint and edge-disjoint, meaning that no two paths can share a common vertex (except for the source and target vertices) or a common edge.\r\n    3. Each path must have a length (number of edges) of at least k, where k is a positive integer provided as input.\r\n    4. The lengths of the paths must be in non-decreasing order, meaning that the length of each path must be greater than or equal to the length of the previous path.\r\n    5. The starting vertices of the paths must be in non-decreasing order, meaning that the starting vertex of each path must be greater than or equal to the starting vertex of the previous path.\r\n    6. The total number of paths returned must not exceed a given limit, L, where L is a positive integer provided as input.\r\n    7. The paths must form a simplicial complex-like structure, where each path intersects with at least one other path at a specific vertex, and the set of vertices visited by the paths must form a simplicial complex in the graph.\r\n    8. The total distance between the vertices in all the paths combined, where the distance between two vertices is defined as the sum of the weights of the edges in the shortest path between them, must not exceed a given limit, D, where D is a positive integer provided as input.\r\n    9. The paths must be sorted in non-decreasing order by the maximum weight of the edges they traverse.\r\n\r\n    Args:\r\n        V (set): the set of vertices in the graph\r\n        E (list): the set of directed edges in the graph, where each edge is represented as a tuple (u, v) indicating a directed edge from vertex u to vertex v, and each edge has an associated weight w(u, v)\r\n        s (int): the source vertex\r\n        t (int): the target vertex\r\n        k (int): a positive integer representing the minimum length requirement for each path\r\n        L (int): a positive integer representing the maximum number of paths that the function can return\r\n        D (int): a positive integer representing the maximum total distance between the vertices in all the paths combined\r\n\r\n    Returns:\r\n        The function return a list of edge-disjoint paths from the source s to the target t, where each path has a length of at least k, the lengths of the paths are in non-decreasing order, the starting vertices of the paths are in non-decreasing order, the paths form a simplicial complex-like structure, the total distance between the vertices in all the paths combined does not exceed D, and the paths are sorted in non-decreasing order by the maximum weight of the edges they traverse, subject to the constraint that the total number of paths returned must not exceed L.\r\n    \"\"\"\r\n    pass", "unitTests": [{"": "V={1, 2, 3, 4, 5, 6}, E={(1, 2, 2), (2, 3, 3), (3, 4, 4), (4, 5, 5), (5, 6, 6), (1, 6, 1)}, s=1, t=6, k=2, L=3, D=15", "expectedOutput": "[[1, 6]]"}, {"expectedOutput": "[[1, 6], [1, 2, 3, 4, 5, 6]]", "": "V={1, 2, 3, 4, 5, 6}, E={(1, 2, 2), (2, 3, 3), (3, 4, 4), (4, 5, 5), (5, 6, 6), (1, 6, 1)}, s=1, t=6, k=2, L=3, D=25"}, {"expectedOutput": "[[4, 7, 12, 9], [4, 5, 8, 14, 9]]", "": "V={1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}, E={(1, 4, 10), (2, 3, 5), (3, 5, 30), (3, 6, 60), (4, 5, 10), (4, 7, 20), (4, 11, 5), (4, 13, 25), (5, 8, 110), (5, 9, 100), (6, 8, 200), (7, 12, 5), (8, 14, 50), (10, 3, 10), (11, 5, 60), (12, 9, 30), (13, 9, 30), (14, 9, 20)}, s=4, t=9, k=4, L=4, D=250"}, {"expectedOutput": "[[4, 13, 9], [4, 7, 12, 9], [4, 5, 8, 14, 9]]", "": "V={1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}, E={(1, 4, 10), (2, 3, 5), (3, 5, 30), (3, 6, 60), (4, 5, 10), (4, 7, 20), (4, 11, 5), (4, 13, 25), (5, 8, 110), (5, 9, 100), (6, 8, 200), (7, 12, 5), (8, 14, 50), (10, 3, 10), (11, 5, 60), (12, 9, 30), (13, 9, 30), (14, 9, 20)}, s=4, t=9, k=3, L=4, D=450"}, {"expectedOutput": "[[4, 13, 9], [4, 7, 12, 9]]", "": "V={1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}, E={(1, 4, 10), (2, 3, 5), (3, 5, 30), (3, 6, 60), (4, 5, 10), (4, 7, 20), (4, 11, 5), (4, 13, 25), (5, 8, 110), (5, 9, 100), (6, 8, 200), (7, 12, 5), (8, 14, 50), (10, 3, 10), (11, 5, 60), (12, 9, 30), (13, 9, 30), (14, 9, 20)}, s=4, t=9, k=3, L=2, D=150"}], "solution": "from collections import deque\n\n\ndef _build_adj_list(\n        graph: set[tuple[int, int, int]],\n        forbidden_nodes: set[int]) -> dict[int, list[tuple[int, int]]]:\n    adj: dict[int, list[tuple[int, int]]] = {}\n\n    for edge in graph:\n        if edge[0] not in forbidden_nodes and edge[1] not in forbidden_nodes:\n            if edge[0] not in adj:\n                adj[edge[0]] = []\n\n            if edge[1] not in adj:\n                adj[edge[1]] = []\n\n            adj[edge[0]].append((edge[1], edge[2]))\n\n    return adj\n\n\ndef _generate_all_possible_paths(adj: dict[int,\n                                           list[tuple[int,\n                                                      int]]], u: int, t: int,\n                                 acc: list[int], allowed_total_distance: int,\n                                 total_distance: int,\n                                 min_accepted_path_length: int,\n                                 max_weight_for_current_path: int,\n                                 min_accepted_weight_for_current_path: int,\n                                 result: list[tuple[int, int, list[int]]]):\n    \"\"\"\n        This function assumes that there is no edge with weight less than or equal to 0, otherwise infinity loop is subject to happened.\n    \"\"\"\n\n    if total_distance > allowed_total_distance:\n        return\n\n    if max_weight_for_current_path >= min_accepted_weight_for_current_path and u == t and total_distance <= allowed_total_distance and len(\n            acc) >= min_accepted_path_length:\n        result.append((max_weight_for_current_path, total_distance, list(acc)))\n\n    for next in adj[u]:\n        acc.append(next[0])\n        total_distance += next[1]\n        _generate_all_possible_paths(adj, next[0], t, acc,\n                                     allowed_total_distance, total_distance,\n                                     min_accepted_path_length,\n                                     max(max_weight_for_current_path, next[1]),\n                                     min_accepted_weight_for_current_path,\n                                     result)\n        acc.pop()\n        total_distance -= next[1]\n\n\ndef count_disjoint_paths(V: set[int], E: set[tuple[int, int, int]], s: int,\n                         t: int, k: int, L: int, D: int) -> list[list[int]]:\n    \"\"\"\n    Given a directed graph G = (V, E), where V is the set of vertices and E is the set of directed edges, and each edge (u, v) ∈ E has an associated weight w(u, v), your task is to find the maximum number of non-overlapping paths in the graph that satisfy the following conditions:\n\n    1. Each path must start at a designated source vertex s and end at a designated target vertex t.\n    2. The paths must be both vertex-disjoint and edge-disjoint, meaning that no two paths can share a common vertex (except for the source and target vertices) or a common edge.\n    3. Each path must have a length (number of edges) of at least k, where k is a positive integer provided as input.\n    4. The lengths of the paths must be in non-decreasing order, meaning that the length of each path must be greater than or equal to the length of the previous path.\n    5. The starting vertices of the paths must be in non-decreasing order, meaning that the starting vertex of each path must be greater than or equal to the starting vertex of the previous path.\n    6. The total number of paths returned must not exceed a given limit, L, where L is a positive integer provided as input.\n    7. The paths must form a simplicial complex-like structure, where each path intersects with at least one other path at a specific vertex, and the set of vertices visited by the paths must form a simplicial complex in the graph.\n    8. The total distance between the vertices in all the paths combined, where the distance between two vertices is defined as the sum of the weights of the edges in the shortest path between them, must not exceed a given limit, D, where D is a positive integer provided as input.\n    9. The paths must be sorted in non-decreasing order by the maximum weight of the edges they traverse.\n\n    Args:\n        V (set): the set of vertices in the graph\n        E (list): the set of directed edges in the graph, where each edge is represented as a tuple (u, v) indicating a directed edge from vertex u to vertex v, and each edge has an associated weight w(u, v)\n        s (int): the source vertex\n        t (int): the target vertex\n        k (int): a positive integer representing the minimum length requirement for each path\n        L (int): a positive integer representing the maximum number of paths that the function can return\n        D (int): a positive integer representing the maximum total distance between the vertices in all the paths combined\n\n    Returns:\n        The function return an integer representing the maximum number of edge-disjoint paths from the source s to the target t, where each path has a length of at least k, the lengths of the paths are in non-decreasing order, the starting vertices of the paths are in non-decreasing order, the paths form a simplicial complex-like structure, the total distance between the vertices in all the paths combined does not exceed D, and the paths are sorted in non-decreasing order by the maximum weight of the edges they traverse, subject to the constraint that the total number of paths returned must not exceed L.\n    \"\"\"\n\n    q: deque[tuple[set[int], int, int, int, set[tuple[int, ...]],\n                   list[list[int]]]] = deque()\n    result: list[tuple[int, int, list[int]]] = []\n    _generate_all_possible_paths(_build_adj_list(E, set()), s, t, [s], D, 0, k,\n                                 -1, -1, result)\n    level: int = 0\n    final_result: list[list[int]] = []\n\n    for path in result:\n        visited: set[int] = {\n            node\n            for node in path[2] if node != s and node != t\n        }\n        path_tuple: tuple[int, ...] = tuple(path[2])\n        q.append((visited, path[1], len(path[2]), path[0], set([path_tuple]),\n                  [path[2]]))\n\n    while q and len(final_result) < L:\n        q_len = len(q)\n        level += 1\n\n        for _ in range(q_len):\n            visited, total_distance, min_max_len, weight, paths, paths_list = q.popleft(\n            )\n\n            final_result = paths_list\n\n            if level == L:\n                break\n\n            new_paths: list[tuple[int, int, list[int]]] = []\n            adj = _build_adj_list(E, visited)\n            _generate_all_possible_paths(adj, s, t, [s], D - total_distance, 0,\n                                         min_max_len, 0, weight, new_paths)\n\n            for path in new_paths:\n                local_path_tuple: tuple[int, ...] = tuple(path[2])\n\n                if local_path_tuple not in paths:\n                    new_visited: set[int] = {\n                        node\n                        for node in path[2] if node != s and node != t\n                    }\n\n                    new_visited.union(visited)\n                    local_paths: set[tuple[int, ...]] = set(paths)\n                    local_paths.add(local_path_tuple)\n                    new_paths_list = list(paths_list)\n                    new_paths_list.append(path[2])\n\n                    q.append((new_visited, total_distance + path[1], len(path),\n                              path[0], local_paths, new_paths_list))\n\n        if level == L:\n            break\n\n    return final_result", "meetsStartingSolutionFormatCriteria": true, "meetsFinalSolutionFormatCriteria": true, "meetsCorrectnessCriteria": true, "meetsDifficultyCriteria": false, "id": "example-6", "worker": "94607a49db8dc666"}, {"problem": "\nYou are given a 2D grid of size m x n, where each cell represents a building. The height of each building is represented by a positive integer. Your task is to implement a function that calculates the maximum amount of water that can be trapped between the buildings, given the following constraints:\n\n1. The function should take a 2D array of integers as input, where each integer represents the height of a building at that position.\n2. The function should return the maximum amount of water that can be trapped between the buildings, represented as an integer.\n3. The amount of water that can be trapped at a given position is determined by the height of the two tallest buildings on either side of that position, and the height of the building at that position. The water trapped is the minimum of the heights of the two tallest buildings, minus the height of the building at that position, if the result is positive.\n4. The total amount of water trapped is the sum of the water trapped at each position.\n5. Your function should be able to handle grids of any size and return the maximum amount of water that can be trapped, even for large input sizes (up to 10^6 x 10^6).\n6. Your function should handle edge cases and special inputs, such as empty grids, grids with only one row or column, and grids with buildings of height 0.\n7. Your function should be optimized for both time and space complexity, and should be able to handle large input sizes efficiently, without causing memory overflow or precision issues in the calculations.\n8. Your function should be able to handle input grids with a wide range of building heights, including very tall and very short buildings, and should still be able to calculate the maximum amount of water trapped accurately.\n", "startingSolution": "\ndef calculate_trapped_water(grid):\n    \"\"\"\n    Given a 2D grid of integers representing the heights of buildings, determine the maximum amount of water that can be trapped between the buildings.\n\n    Args:\n        grid (List[List[int]]): A 2D grid of integers representing the heights of buildings.\n\n    Returns:\n        int: The maximum amount of water that can be trapped between the buildings.\n    \"\"\"\n    pass\n", "unitTests": [{"grid": " [1, 1, 1, 1],         [2, 2, 2, 2],         [3, 3, 3, 3],         [4, 4, 4, 4]", "expectedOutput": "0"}, {"expectedOutput": "5", "grid": "[3, 1, 3, 4],         [2, 1, 2, 2],         [3, 1, 5, 2],         [2, 2, 4, 3]"}, {"expectedOutput": "12", "grid": "[5, 5, 5, 5],         [5, 1, 1, 5],         [5, 1, 1, 5],         [5, 5, 5, 5]"}], "solution": "def max_trapped_water(grid):\n    if not grid or not grid[0]:\n        return 0\n    \n    m, n = len(grid), len(grid[0])\n    left_max = [[0] * n for _ in range(m)]\n    right_max = [[0] * n for _ in range(m)]\n    for i in range(m):\n        left_max[i][0] = grid[i][0]\n        for j in range(1, n):\n            left_max[i][j] = max(left_max[i][j-1], grid[i][j])\n    for i in range(m):\n        right_max[i][n-1] = grid[i][n-1]\n        for j in range(n-2, -1, -1):\n            right_max[i][j] = max(right_max[i][j+1], grid[i][j])\n    \n    total_water = 0\n    for i in range(m):\n        for j in range(n):\n            water_level = min(left_max[i][j], right_max[i][j]) - grid[i][j]\n            if water_level > 0:\n                total_water += water_level\n    \n    return total_water\n\ndef test_max_trapped_water():\n    grid2 = [\n        [1, 2, 3],\n        [3, 2, 1],\n        [1, 1, 1]\n    ]\n    assert max_trapped_water(grid2) == 0, f\"Test case 2 failed\"\n\n    grid3 = [\n        [1, 1, 1, 1],\n        [2, 2, 2, 2],\n        [3, 3, 3, 3],\n        [4, 4, 4, 4]\n    ]\n    assert max_trapped_water(grid3) == 0, f\"Test case 3 failed\"\n\n    grid4 = [\n        [3, 1, 3, 4],\n        [2, 1, 2, 2],\n        [3, 1, 5, 2],\n        [2, 2, 4, 3]\n    ]\n    assert max_trapped_water(grid4) == 5, f\"Test case 4 failed\"\n    print(\"All test cases passed!\")\ntest_max_trapped_water()\n", "meetsStartingSolutionFormatCriteria": true, "meetsFinalSolutionFormatCriteria": true, "meetsCorrectnessCriteria": true, "meetsDifficultyCriteria": false, "id": "example-7", "worker": "86afe36b19d0f78b"}, {"problem": "\"\\nGiven a 2D grid of size m x n, where each cell represents a building, your task is to find the maximum number of buildings that can be connected by a single path, where a path is defined as a sequence of adjacent cells (horizontally or vertically) with strictly increasing heights.\\n\\nThe input to your function will be a 2D array of integers, where each integer represents the height of the corresponding building. Your function should return the maximum number of buildings that can be connected by a single path.\\n\\nExample:\\nInput: [[1,2,3],[3,2,1],[1,1,1]]\\nOutput: 3\\nExplanation: The path [1,2,3] can connect 3 buildings.\\n\\nExample:\\nInput: [[1,1,1,1],[2,2,2,2],[3,3,3,3],[4,4,4,4]]\\nOutput: 4\\nExplanation: All 4 buildings can be connected by a single path.\\n\\nExample:\\nInput: [[1,2,3,4],[3,2,1,0],[1,1,1,1],[0,0,0,0]]\\nOutput: 2\\nExplanation: The path [1,2,3,4] can connect 4 buildings, but the path [0,1,1,1] can only connect 2 buildings.\\n\", \"startingSolution\": \"def longestIncreasingPath(matrix):\\r\\n    # Check if the matrix have a value\\r\\n    if not matrix or not matrix[0]:\\r\\n        return 0\\r\\n    \\r\\n    # Get the number of row (m) & column (n)\\r\\n    m, n = len(matrix), len(matrix[0])\\r\\n    \\r\\n    # Create a memo array filled with -1\\r\\n    memo = [[-1] * n for _ in range(m)]\\r\\n    \\r\\n    # This function finds the longest path starting from (x, y) theadjacent cells with strictly increasing heights\\r\\n    def dfs(x, y):\\r\\n        # If we already calculated the longest path from (x, y), return it\\r\\n        if memo[x][y] != -1:\\r\\n            return memo[x][y]\\r\\n        \\r\\n        # Possible directions to move: right, down, left, up\\r\\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\r\\n        \\r\\n        # The longest path from this cell is at least 1 (the cell itself)\\r\\n        max_length = 1\\r\\n        \\r\\n        # Check all four directions up dowm and side also...\\r\\n        for dx, dy in directions:\\r\\n            nx, ny = x + dx, y + dy\\r\\n            # Make sure the new cell is inside the grid and has a higher height\\r\\n            if 0 <= nx < m and 0 <= ny < n and matrix[nx][ny] > matrix[x][y]:\\r\\n                # Find the longest path from the new cell\\r\\n                max_length = max(max_length, 1 + dfs(nx, ny))\\r\\n        \\r\\n        # Save the result in the memo array\\r\\n        memo[x][y] = max_length\\r\\n        return max_length\\r\\n    \\r\\n    # This variable will store the longest path found\\r\\n    max_path = 0\\r\\n    \\r\\n    # Check each cell in the grid\\r\\n    for i in range(m):\\r\\n        for j in range(n):\\r\\n            # Update the longest path found\\r\\n            max_path = max(max_path, dfs(i, j))\\r\\n    \\r\\n    return max_path\\r\\n\\r\\n# Test cases\\r\\nprint(longestIncreasingPath([[1, 2, 3], [3, 2, 4], [1, 7, 5]]))  # Output: 3\\r\\nprint(longestIncreasingPath([[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]]))  # Output: 4\\r\\nprint(longestIncreasingPath([[1, 2, 3, 4], [3, 2, 1, 0], [1, 1, 1, 1], [0, 0, 0, 0]]))  # Output: 4\", \"unitTests\": [], \"solution\": \"def longestIncreasingPath(matrix):\\r\\n    # Check if the matrix have a value\\r\\n    if not matrix or not matrix[0]:\\r\\n        return 0\\r\\n    \\r\\n    # Get the number of row (m) & column (n)\\r\\n    m, n = len(matrix), len(matrix[0])\\r\\n    \\r\\n    # Create a memo array filled with -1\\r\\n    memo = [[-1] * n for _ in range(m)]\\r\\n    \\r\\n    # This function finds the longest path starting from (x, y) theadjacent cells with strictly increasing heights\\r\\n ", "startingSolution": "\r\ndef longestIncreasingPath(matrix):\r\n    \"\"\"\r\n    Given a 2D grid of size m x n, where each cell represents a building, find the maximum number of buildings that can be connected by a single path, where a path is defined as a sequence of adjacent cells (horizontally or vertically) with strictly increasing heights.\r\n\r\n    Args:\r\n        matrix (List[List[int]]): A 2D grid of integers representing the heights of the buildings.\r\n\r\n    Returns:\r\n        int: The maximum number of buildings that can be connected by a single path.\r\n\r\n    Examples:\r\n        >>> longestIncreasingPath([[1,2,3],[3,2,1],[1,1,1]])\r\n        3\r\n        >>> longestIncreasingPath([[1,1,1,1],[2,2,2,2],[3,3,3,3],[4,4,4,4]])\r\n        4\r\n        >>> longestIncreasingPath([[1,2,3,4],[3,2,1,0],[1,1,1,1],[0,0,0,0]])\r\n        4\r\n    \"\"\"\r\n    # Check if the matrix has a value\r\n    if not matrix or not matrix[0]:\r\n        return 0\r\n    \r\n    # Get the number of rows (m) and columns (n)\r\n    m, n = len(matrix), len(matrix[0])\r\n    \r\n    # Create a memo array filled with -1\r\n    memo = [[-1] * n for _ in range(m)]\r\n    \r\n    # This function finds the longest path starting from (x, y) in adjacent cells with strictly increasing heights\r\n    def dfs(x, y):\r\n        # If we already calculated the longest path from (x, y), return it\r\n        if memo[x][y] != 0:\r\n            return memo[x][y]\r\n        \r\n        # Possible directions to move: right, down, left, up\r\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\r\n        \r\n        # The longest path from this cell is at least 1 (the cell itself)\r\n        max_length = 0\r\n        \r\n        # Check all four directions\r\n        for dx, dy in directions:\r\n            nx, ny = x + dx, y + dy\r\n            # Make sure the new cell is inside the grid and has a higher height\r\n            if 0 <= nx < m and 0 <= ny < n and matrix[nx][ny] > matrix[x][y]:\r\n                # Find the longest path from the new cell\r\n                max_length = max(max_length, 1 + dfs(nx, ny))\r\n        \r\n        # Save the result in the memo array\r\n        memo[x][y] = max_length\r\n        return max_length\r\n    \r\n    # This variable will store the longest path found\r\n    max_path = 1\r\n    \r\n    # Check each cell in the grid\r\n    for i in range(m):\r\n        for j in range(n):\r\n            # Update the longest path found\r\n            max_path = max(max_path, dfs(i, j))\r\n    \r\n    return max_path\r\n\r\n\r\n", "unitTests": [{"expectedOutput": "4", "matrix": "[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]]"}, {"expectedOutput": "4", "matrix": "[[1, 2, 3, 4], [3, 2, 1, 0], [1, 1, 1, 1], [0, 0, 0, 0]]"}, {"matrix": "1, 2, 3], [3, 2, 4], [1, 7, 5]]", "expectedOutput": "3"}], "solution": "\ndef longestIncreasingPath(matrix):\n    \"\"\"\n    Given a 2D grid of size m x n, where each cell represents a building, find the maximum number of buildings that can be connected by a single path, where a path is defined as a sequence of adjacent cells (horizontally or vertically) with strictly increasing heights.\n\n    Args:\n        matrix (List[List[int]]): A 2D grid of integers representing the heights of the buildings.\n\n    Returns:\n        int: The maximum number of buildings that can be connected by a single path.\n\n    Examples:\n        >>> longestIncreasingPath([[1,2,3],[3,2,1],[1,1,1]])\n        3\n        >>> longestIncreasingPath([[1,1,1,1],[2,2,2,2],[3,3,3,3],[4,4,4,4]])\n        4\n        >>> longestIncreasingPath([[1,2,3,4],[3,2,1,0],[1,1,1,1],[0,0,0,0]])\n        4\n    \"\"\"\n    # Check if the matrix has a value\n    if not matrix or not matrix[0]:\n        return 0\n    \n    # Get the number of rows (m) and columns (n)\n    m, n = len(matrix), len(matrix[0])\n    \n    # Create a memo array filled with -1\n    memo = [[-1] * n for _ in range(m)]\n    \n    # This function finds the longest path starting from (x, y) in adjacent cells with strictly increasing heights\n    def dfs(x, y):\n        # If we already calculated the longest path from (x, y), return it\n        if memo[x][y] != -1:\n            return memo[x][y]\n        \n        # Possible directions to move: right, down, left, up\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        # The longest path from this cell is at least 1 (the cell itself)\n        max_length = 1\n        \n        # Check all four directions\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            # Make sure the new cell is inside the grid and has a higher height\n            if 0 <= nx < m and 0 <= ny < n and matrix[nx][ny] > matrix[x][y]:\n                # Find the longest path from the new cell\n                max_length = max(max_length, 1 + dfs(nx, ny))\n        \n        # Save the result in the memo array\n        memo[x][y] = max_length\n        return max_length\n    \n    # This variable will store the longest path found\n    max_path = 0\n    \n    # Check each cell in the grid\n    for i in range(m):\n        for j in range(n):\n            # Update the longest path found\n            max_path = max(max_path, dfs(i, j))\n    \n    return max_path\n\n# Test cases\nprint(longestIncreasingPath([[1, 2, 3], [3, 2, 4], [1, 7, 5]]))  # Output: 3\nprint(longestIncreasingPath([[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]]))  # Output: 4\nprint(longestIncreasingPath([[1, 2, 3, 4], [3, 2, 1, 0], [1, 1, 1, 1], [0, 0, 0, 0]]))  # Output: 4\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-8", "worker": "6e7b82a374b87eb3"}, {"problem": "You are given a 2D array of integers grid, where grid[i][j] represents the value at the i-th row and j-th column of the grid. The grid is rectangular, with dimensions m x n, where m and n are positive integers.\\n\\nYour task is to implement a function that finds the maximum sum of a contiguous subgrid within the grid, subject to the following constraints:\\n\\n1. The subgrid must be rectangular, meaning it must have a well-defined top-left and bottom-right corner.\\n2. The subgrid must have an area (number of elements) that is strictly less than a given threshold value k.\\n3. The sum of the elements in the subgrid must be maximized.\\n\\nThe function should take the following input:\\n- grid: a 2D array of integers representing the grid\\n- k: a positive integer representing the maximum allowed area of the subgrid\\n\\nThe function should return the maximum sum of any contiguous subgrid that satisfies the given constraints.\\n\\nExample:\\n- grid = [[1, 2, -1, -4, -20],\\n         [-8, -3, 4, 2, 1],\\n         [3, 8, 10, 1, 3],\\n         [-4, -1, 1, 7, -6]]\\n- k = 6\\n- Output: 29 (the subgrid [[2, 1], [3, 8], [1, 3]] has a sum of 29 and an area of 6", "startingSolution": "\ndef max_subgrid_sum(grid, k):\n    \"\"\"\n    Given a 2D grid of integers and a maximum area threshold k, find the maximum sum of a contiguous subgrid within the grid that satisfies the following constraints:\n    \n    1. The subgrid must be rectangular, meaning it must have a well-defined top-left and bottom-right corner.\n    2. The subgrid must have an area (number of elements) that is strictly less than the given threshold value k.\n    3. The sum of the elements in the subgrid must be maximized.\n    \n    Args:\n        grid (List[List[int]]): A 2D grid of integers.\n        k (int): The maximum allowed area of the subgrid.\n    \n    Returns:\n        int: The maximum sum of any contiguous subgrid that satisfies the given constraints.\n    \"\"\"\n    pass\n", "unitTests": [{"grid": "  [1, 2, -1, -4, -20],     [-8, -3, 4, 2, 1],     [3, 8, 10, 1, 3],     [-4, -1, 1, 7, -6]", "k": "6", "expectedOutput": "29"}, {"expectedOutput": "5", "grid": " [[5]]", "k": "1"}, {"expectedOutput": "45", "grid": "[1, 2, 3],         [4, 5, 6],         [7, 8, 9]", "k": "9"}, {"expectedOutput": "-1", "grid": " [-1, -2, -3],         [-4, -5, -6],         [-7, -8, -9]", "k": "4"}], "solution": "def max_subgrid_sum(grid, k):\n    \"\"\"\n    Given a 2D grid of integers and a maximum area threshold k, find the maximum sum of a contiguous subgrid within the grid that satisfies the following constraints:\n    \n    1. The subgrid must be rectangular, meaning it must have a well-defined top-left and bottom-right corner.\n    2. The subgrid must have an area (number of elements) that is strictly less than the given threshold value k.\n    3. The sum of the elements in the subgrid must be maximized.\n    \n    Args:\n        grid (List[List[int]]): A 2D grid of integers.\n        k (int): The maximum allowed area of the subgrid.\n    \n    Returns:\n        int: The maximum sum of any contiguous subgrid that satisfies the given constraints.\n    \"\"\"\n    m = len(grid)\n    if m == 0:\n        return 0\n    n = len(grid[0])\n    if n == 0:\n        return 0\n    \n    max_sum = float('-inf')\n    prefix_sum = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            prefix_sum[i][j] = grid[i][j]\n            if i > 0:\n                prefix_sum[i][j] += prefix_sum[i-1][j]\n            if j > 0:\n                prefix_sum[i][j] += prefix_sum[i][j-1]\n            if i > 0 and j > 0:\n                prefix_sum[i][j] -= prefix_sum[i-1][j-1]\n    def subgrid_sum(top, left, bottom, right):\n        result = prefix_sum[bottom][right]\n        if top > 0:\n            result -= prefix_sum[top-1][right]\n        if left > 0:\n            result -= prefix_sum[bottom][left-1]\n        if top > 0 and left > 0:\n            result += prefix_sum[top-1][left-1]\n        return result\n    for top in range(m):\n        for bottom in range(top, m):\n            temp_sum = [0] * n\n            current_max_sum = float('-inf')\n            current_sum = 0\n            \n            for col in range(n):\n                temp_sum[col] = subgrid_sum(top, col, bottom, col)\n                if current_sum > 0:\n                    current_sum += temp_sum[col]\n                else:\n                    current_sum = temp_sum[col]\n                \n                current_max_sum = max(current_max_sum, current_sum)\n            max_sum = max(max_sum, current_max_sum)\n    return max_sum if max_sum != float('-inf') else 0\n\n\n", "meetsStartingSolutionFormatCriteria": true, "meetsFinalSolutionFormatCriteria": true, "meetsCorrectnessCriteria": true, "meetsDifficultyCriteria": false, "id": "example-9", "worker": "86afe36b19d0f78b"}, {"problem": "You are given a 2D grid of size m x n, where each cell represents a point in a coordinate plane. Some of the cells in the grid are marked as obstacles, and the remaining cells are considered walkable.\\n\\nYour task is to implement a function that finds the minimum number of steps required to move from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1), while avoiding all obstacles. You can only move in four directions: up, down, left, and right, and each step takes one unit of time.\\n\\nThe function should take the following input:\\n- A 2D boolean array `grid`, where `grid[i][j]` is `true` if the cell at (i, j) is an obstacle, and `false` otherwise.\\n\\nThe function should return the minimum number of steps required to reach the bottom-right corner, or -1 if no path exists.\\n\\nExample:\\n```\\nInput: grid = [[false, false, false],\\n              [true, true, false],\\n              [false, false, false]]\\n\\nOutput: 4\\n\\nExplanation:\\nThe minimum number of steps required to reach the bottom-right corner is 4. The path is:\\n(0, 0) -> (0, 1) -> (0, 2) -> (1, 2) -> (2, 2)\\n```\\n", "startingSolution": "\ndef shortest_path(grid):\n    \"\"\"\n    Find the minimum number of steps required to move from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1) of a 2D grid, while avoiding all obstacles.\n\n    Args:\n        grid (List[List[bool]]): A 2D boolean array representing the grid, where `grid[i][j]` is `true` if the cell at (i, j) is an obstacle, and `false` otherwise.\n\n    Returns:\n        int: The minimum number of steps required to reach the bottom-right corner, or -1 if no path exists.\n    \"\"\"\n    pass\n", "unitTests": [{"grid": "[False, False, False],         [True, True, False],         [False, False, False]", "expectedOutput": "4"}, {"expectedOutput": "-1", "grid": "  [False, True, False],         [True, True, False],         [False, False, False]"}, {"expectedOutput": "-1", "grid": "[False, False, False],         [True, True, True],         [False, False, False]"}], "solution": "from collections import deque\n\ndef shortest_path(grid):\n    \"\"\"\n    Find the minimum number of steps required to move from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1) of a 2D grid, while avoiding all obstacles.\n\n    Args:\n        grid (List[List[bool]]): A 2D boolean array representing the grid, where `grid[i][j]` is `True` if the cell at (i, j) is an obstacle, and `False` otherwise.\n\n    Returns:\n        int: The minimum number of steps required to reach the bottom-right corner, or -1 if no path exists.\n    \"\"\"\n    if not grid:\n        return -1\n\n    m, n = len(grid), len(grid[0])\n    if m == 1 and n == 1:\n        return 0 if not grid[0][0] else -1\n\n    queue = deque([(0, 0, 0)])  \n    visited = set([(0, 0)])  \n\n    while queue:\n        row, col, steps = queue.popleft()\n        if row == m - 1 and col == n - 1:\n            return steps\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            new_row, new_col = row + dr, col + dc\n\n            if 0 <= new_row < m and 0 <= new_col < n and (new_row, new_col) not in visited and not grid[new_row][new_col]:\n                visited.add((new_row, new_col))\n                queue.append((new_row, new_col, steps + 1))\n\n    return -1  \n\n\n", "meetsStartingSolutionFormatCriteria": true, "meetsFinalSolutionFormatCriteria": true, "meetsCorrectnessCriteria": true, "meetsDifficultyCriteria": true, "id": "example-10", "worker": "86afe36b19d0f78b"}, {"problem": "You are given a directed graph G = (V, E), where V is the set of vertices and E is the set of directed edges. Each vertex v in V has a unique identifier, denoted as v.id, and a weight, denoted as v.weight. Each edge (u, v) in E has a cost, denoted as (u, v).cost.\n\nYour task is to find a set of k disjoint paths, P = {P1, P2, ..., Pk}, where each path Pi = (si, vi1, vi2, ..., vit, ti) is a sequence of vertices from a source vertex si to a destination vertex ti, such that the following objectives are optimized:\n\n1. Maximize the sum of the weights of the vertices in all the paths, subject to the constraint that the sum of the costs of the edges in each path Pi does not exceed a given threshold Ci.\n2. Minimize the total number of distinct vertices visited across all the paths.\n3. Ensure that the set of destination vertices {t1, t2, ..., tk} is a subset of a given set of mandatory vertices M.\n\nThe function you need to implement should take the following inputs:\n- G: the directed graph\n- k: the number of disjoint paths to find\n- M: the set of mandatory destination vertices\n- C: a list of k cost thresholds, where Ci is the maximum allowed cost for path Pi\n\nThe function should return a tuple (max_total_weight, min_distinct_vertices, paths) where:\n- max_total_weight is the maximum sum of the weights of the vertices in the k disjoint paths\n- min_distinct_vertices is the minimum number of distinct vertices visited across all the paths\n- paths is a list of k disjoint paths, where each path Pi is a list of vertex IDs", "startingSolution": "def find_disjoint_paths(G: dict[int, tuple[int, dict[int, int]]], k: int, M: set[int], C: list[int]) -> tuple[int, int, list[list[int]]]:\r\n    \"\"\"\r\n    Find a set of k disjoint paths in the directed graph G that optimizes the following objectives:\r\n\r\n    1. Maximize the sum of the weights of the vertices in all the paths, subject to the constraint that the sum of the costs of the edges in each path Pi does not exceed the corresponding cost threshold Ci.\r\n    2. Minimize the total number of distinct vertices visited across all the paths.\r\n    3. Ensure that the set of destination vertices {t1, t2, ..., tk} is a subset of the given set of mandatory vertices M.\r\n\r\n    Args:\r\n        G (dict): The directed graph, where the keys are vertex IDs and the values are tuple of weight and dictionary representing the outgoing edges and their costs.\r\n        k (int): The number of disjoint paths to find.\r\n        M (set): The set of mandatory destination vertices.\r\n        C (list): A list of k cost thresholds, where Ci is the maximum allowed cost for path Pi.\r\n\r\n    Returns:\r\n        tuple: A tuple containing the following:\r\n            - max_total_weight (int): The maximum sum of the weights of the vertices in the k disjoint paths.\r\n            - min_distinct_vertices (int): The minimum number of distinct vertices visited across all the paths.\r\n            - paths (list): A list of k disjoint paths, where each path Pi is a list of vertex IDs.\r\n    \"\"\"\r\n    pass", "unitTests": [{"": "k=1, M={3, 6}, C=[60], G={ 1: (80, { 3: 10, 2: 30, 4: 20 }), 2: (45, {}), 3: (10, {5: 90, 6: 40 }), 4: (33, {}), 5: (60, {}), 6: (50, {})}", "expectedOutput": "(140, 3, [[1, 3, 6]])"}, {"expectedOutput": "(140, 3, [[1, 3, 6]])", "": "k=1, M={3, 6}, C=[60], G={ 1: (80, { 3: 10, 2: 30, 4: 20 }), 2: (45, {}), 3: (10, { 3: 30, 5: 90, 6: 40 }), 4: (33, {}), 5: (60, {}), 6: (50, {}) }"}, {"expectedOutput": "(160, 3, [[1, 3, 3, 3, 6]])", "": "k=1, M={3, 6}, C=[60], G={ 1: (80, { 3: 10, 2: 30, 4: 20 }), 2: (45, {}), 3: (10, { 3: 5, 5: 90, 6: 40 }), 4: (33, {}), 5: (60, {}), 6: (50, {}) }"}, {"expectedOutput": "(260, 8, [[1, 4, 13, 9], [10, 3, 5, 8]])", "": "k=2, M={4, 9, 8, 5}, C=[80, 150], G={ 1: (20, { 4: 10 }), 2: (5, {3: 5}), 3: (30, { 5: 30, 6: 60 }), 4: (20, {5: 10, 7: 20, 13: 25}), 5: (50, {8: 110, 9: 100}), 6: (50, {8: 200}), 7: (20, {12: 5}), 8: (40, {14: 50}), 9: (40, {}), 10: (10, {3: 10}), 11: (40, {5: 60}), 12: (30, {9: 30}), 13: (50, {9: 30}), 14: (30, {}) }"}], "solution": "from concurrent.futures import ThreadPoolExecutor, as_completed\r\nfrom dataclasses import dataclass\r\n\r\n\r\n@dataclass\r\nclass Result:\r\n    weight: int\r\n    min_distinct_vertices: int\r\n    paths: list[list[int]]\r\n\r\n\r\ndef reverse_graph(\r\n    G: dict[int, tuple[int, dict[int, int]]]\r\n) -> dict[int, tuple[int, dict[int, int]]]:\r\n    new_g: dict[int, tuple[int, dict[int, int]]] = {\r\n        key: (G[key][0], {})\r\n        for key in G\r\n    }\r\n\r\n    for u in G:\r\n        node = G[u][1]\r\n\r\n        for v in node:\r\n            new_g[v][1][u] = node[v]\r\n\r\n    return new_g\r\n\r\n\r\ndef generate_all_possible_starts(M: list[int], visited: set[int], k: int,\r\n                                 acc: list[int], result: list[list]):\r\n    if len(visited) == k:\r\n        result.append(list(acc))\r\n\r\n    for i in M:\r\n        if i not in visited:\r\n            acc.append(i)\r\n            visited.add(i)\r\n            generate_all_possible_starts(M, visited, k, acc, result)\r\n            visited.remove(i)\r\n            acc.pop()\r\n\r\n\r\ndef find_best_disjoint_paths_for_a_starts_list(\r\n        G: dict[int, tuple[int, dict[int, int]]], idx: int, C: list[int],\r\n        acc: list[list[int]], current_path_total_cost: int, total_weight: int,\r\n        current_path_nodes: dict[int, int], visited: set[int], M: set[int],\r\n        result: Result):\r\n    if idx == len(acc) or current_path_total_cost > C[idx]:\r\n        return\r\n\r\n    if len(M) == 0 and (total_weight > result.weight or\r\n                        (total_weight == result.weight\r\n                         and len(visited) < result.min_distinct_vertices)):\r\n        result.weight = total_weight\r\n        result.min_distinct_vertices = len(visited)\r\n        result.paths = [[node for node in nodes] for nodes in acc]\r\n\r\n    find_best_disjoint_paths_for_a_starts_list(\r\n        G, idx + 1, C, acc, 0, total_weight,\r\n        {acc[idx + 1][0]: 1} if idx + 1 < len(acc) else {}, visited, M, result)\r\n    node = acc[idx][-1]\r\n    node_values = G[node]\r\n\r\n    for next in node_values[1]:\r\n        if next not in visited or next in current_path_nodes:\r\n            visited.add(next)\r\n            acc[idx].append(next)\r\n            current_path_total_cost += node_values[1][next]\r\n            total_weight += G[next][0]\r\n            add_to_M = True if next in M else False\r\n\r\n            if next in current_path_nodes:\r\n                current_path_nodes[next] += 1\r\n            else:\r\n                current_path_nodes[next] = 1\r\n\r\n            if add_to_M:\r\n                M.remove(next)\r\n\r\n            find_best_disjoint_paths_for_a_starts_list(\r\n                G, idx, C, acc, current_path_total_cost, total_weight,\r\n                current_path_nodes, visited, M, result)\r\n            acc[idx].pop()\r\n            current_path_total_cost -= node_values[1][next]\r\n            total_weight -= G[next][0]\r\n            current_path_nodes[next] -= 1\r\n\r\n            if current_path_nodes[next] == 0:\r\n                visited.remove(next)\r\n                del current_path_nodes[next]\r\n\r\n            if add_to_M:\r\n                M.add(next)\r\n\r\n\r\ndef solve_for_selected_start_nodes(G: dict[int, tuple[int, dict[int, int]]],\r\n                                   C: list[int], M: set[int],\r\n                                   start_nodes: list[int]) -> Result:\r\n    current_weight_sum: int = 0\r\n    visited_nodes: set[int] = set(start_nodes)\r\n    result: Result = Result(0, 10**18, [])\r\n\r\n    for node in start_nodes:\r\n        current_weight_sum += G[node][0]\r\n\r\n    acc = [[node] for node in start_nodes]\r\n\r\n    find_best_disjoint_paths_for_a_starts_list(\r\n        G, 0, C, acc, 0, current_weight_sum, {acc[0][0]: 1}, visited_nodes,\r\n        {key\r\n         for key in M if key not in visited_nodes}, result)\r\n\r\n    return result\r\n\r\n\r\ndef find_disjoint_paths(G: dict[int, tuple[int, dict[int, int]]], k: int,\r\n                        M: set[int],\r\n                        C: list[int]) -> tuple[int, int, list[list[int]]]:\r\n    \"\"\"\r\n    Find a set of k disjoint paths in the directed graph G that optimizes the following objectives:\r\n\r\n    1. Maximize the sum of the weights of the vertices in all the paths, subject to the constraint that the sum of the costs of the edges in each path Pi does not exceed the corresponding cost threshold Ci.\r\n    2. Minimize the total number of distinct vertices visited across all the paths.\r\n    3. Ensure that the set of destination vertices {t1, t2, ..., tk} is a subset of the given set of mandatory vertices M.\r\n\r\n    Args:\r\n        G (dict): The directed graph, where the keys are vertex IDs and the values are tuple of weight and dictionary representing the outgoing edges and their costs.\r\n        k (int): The number of disjoint paths to find.\r\n        M (set): The set of mandatory destination vertices.\r\n        C (list): A list of k cost thresholds, where Ci is the maximum allowed cost for path Pi.\r\n\r\n    Returns:\r\n        tuple: A tuple containing the following:\r\n            - max_total_weight (int): The maximum sum of the weights of the vertices in the k disjoint paths.\r\n            - min_distinct_vertices (int): The minimum number of distinct vertices visited across all the paths.\r\n            - paths (list): A list of k disjoint paths, where each path Pi is a list of vertex IDs.\r\n    \"\"\"\r\n\r\n    G = reverse_graph(G)\r\n    k_starts_list: list[list[int]] = []\r\n    acc: list[int] = []\r\n    visited: set[int] = set()\r\n    result: Result = Result(0, 10**18, [])\r\n\r\n    generate_all_possible_starts(list(M), visited, k, acc, k_starts_list)\r\n\r\n    with ThreadPoolExecutor(max_workers=12) as executor:\r\n        im_results = []\r\n\r\n        for start_nodes in k_starts_list:\r\n            im_result = executor.submit(solve_for_selected_start_nodes, G, C,\r\n                                        M, start_nodes)\r\n            im_results.append(im_result)\r\n\r\n        for future in as_completed(im_results):\r\n            future_result: Result = future.result()\r\n\r\n            if future_result.weight > result.weight or (\r\n                    future_result.weight == result.weight\r\n                    and future_result.min_distinct_vertices\r\n                    < result.min_distinct_vertices):\r\n                result = future_result\r\n\r\n    for path in result.paths:\r\n        path.reverse()\r\n\r\n    return (result.weight, result.min_distinct_vertices, result.paths)", "meetsStartingSolutionFormatCriteria": true, "meetsFinalSolutionFormatCriteria": true, "meetsCorrectnessCriteria": true, "meetsDifficultyCriteria": false, "id": "example-11", "worker": "94607a49db8dc666"}, {"problem": "ou are given a 2D grid of size m x n, where each cell represents a point in a coordinate plane. Some of the cells in the grid are marked as obstacles, and the remaining cells are considered walkable.\\n\\nYour task is to implement a function that finds the minimum number of steps required to move from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1), while avoiding all obstacles. You can only move in four directions: up, down, left, and right, and each step takes one unit of time.\\n\\nThe function should take the following input:\\n- A 2D boolean array grid, where grid[i][j] is true if the cell at (i, j) is an obstacle, and false otherwise.\\n\\nThe function should return the minimum number of steps required to reach the bottom-right corner, or -1 if no path exists.\\n\\nExample:\\n\n\\nInput: grid = [[false, false, false],", "startingSolution": "\r\n#def shortest_path(grid):\r\n\r\n    \"\"\"\r\n    Given a 2D boolean grid, where True represents an obstacle and False represents a walkable cell, find the minimum number of steps required to move from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1), while avoiding all obstacles.\r\n\r\n    Args:\r\n        grid (List[List[bool]]): A 2D boolean array representing the grid, where True indicates an obstacle and False indicates a walkable cell.\r\n\r\n    Returns:\r\n        int: The minimum number of steps required to reach the bottom-right corner, or -1 if no path exists.\r\n    \"\"\"\r\n    pass\r\ndef min_steps_to_reach_bottom_right(grid):\r\n    # Check for edge cases\r\n    if not grid or not grid[0]:\r\n        return -1  # Invalid grid\r\n\r\n    rows = len(grid)\r\n    cols = len(grid[0])\r\n    \r\n    # Direction vectors for up, down, left, right\r\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\r\n\r\n    # Queue to hold the current position and step count\r\n    queue = [(1, 1, 1)]\r\n    visited = [[False] * cols for _ in range(rows)]\r\n    visited[0][0] = True\r\n    \r\n    while queue:\r\n        row, col, steps = queue.pop(0)\r\n        \r\n        # If we have reached the bottom-right corner\r\n        if row == rows - 1 and col == cols - 1:\r\n            return steps\r\n        \r\n        # Explore all possible directions\r\n        for dr, dc in directions:\r\n            next_row, next_col = row + dr, col + dc\r\n            \r\n            # If the cell is within bounds, not visited, and not an obstacle\r\n            if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col] and not grid[next_row][next_col]:\r\n                visited[next_row][next_col] = True\r\n                queue.append((next_row, next_col, steps + 1))\r\n    \r\n    # If the queue is exhausted without finding a path, return -1\r\n    return -1\r\nprint(min_steps_to_reach_bottom_right([[False, False, False],\r\n                                            [True, True, False],\r\n                                            [False, False, False]])) \r\n    \r\nprint(min_steps_to_reach_bottom_right([[False, False, False],\r\n                                            [True, True, True],\r\n                                            [False, False, False]])) \r\n    \r\nprint(min_steps_to_reach_bottom_right([[False, True, False],\r\n                                            [False, True, False],\r\n                                            [False, False, False]]))", "unitTests": [{"grid": "[False, False, False],                                             [True, True, False],                                             [False, False, False]", "expectedOutput": "4"}, {"expectedOutput": "-1", "grid": "[False, False, False],                                             [True, True, True],                                             [False, False, False]"}, {"expectedOutput": "4", "grid": "[False, True, False],                                             [False, True, False],                                             [False, False, False]"}], "solution": "\ndef shortest_path(grid):\n    \"\"\"\n    Given a 2D boolean grid, where True represents an obstacle and False represents a walkable cell, find the minimum number of steps required to move from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1), while avoiding all obstacles.\n\n    Args:\n        grid (List[List[bool]]): A 2D boolean array representing the grid, where True indicates an obstacle and False indicates a walkable cell.\n\n    Returns:\n        int: The minimum number of steps required to reach the bottom-right corner, or -1 if no path exists.\n    \"\"\"\n    # Check for edge cases\n    if not grid or not grid[0]:\n        return -1  # Invalid grid\n\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    # Direction vectors for up, down, left, right\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    # Queue to hold the current position and step count\n    queue = [(0, 0, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n    visited[0][0] = True\n    \n    while queue:\n        row, col, steps = queue.pop(0)\n        \n        # If we have reached the bottom-right corner\n        if row == rows - 1 and col == cols - 1:\n            return steps\n        \n        # Explore all possible directions\n        for dr, dc in directions:\n            next_row, next_col = row + dr, col + dc\n            \n            # If the cell is within bounds, not visited, and not an obstacle\n            if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col] and not grid[next_row][next_col]:\n                visited[next_row][next_col] = True\n                queue.append((next_row, next_col, steps + 1))\n    \n    # If the queue is exhausted without finding a path, return -1\n    return -1\n\n>\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-12", "worker": "6e7b82a374b87eb3"}, {"problem": "\n\"Given a 2D grid of size m x n, where each cell represents a building, your task is to find the maximum number of non-overlapping rectangular areas that can be constructed within the grid, such that each area satisfies the following conditions:\n\n1. The area must be a rectangle, with its sides parallel to the grid axes.\n2. The area must contain only cells with a value of 1, representing a building.\n3. The area must have a height and width of at least 2 units.\n4. The area must not overlap with any other area.\n\nThe input to your function will be a 2D array grid, where grid[i][j] is 1 if there is a building at that cell, and 0 otherwise.\n\nYour function should return the maximum number of non-overlapping rectangular areas that can be constructed within the grid, given the constraints above.\n\nExample:\nInput: grid = [[1,1,1,1],[1,1,1,1],[1,1,1,1]]\nOutput: 2\nExplanation: The two non-overlapping rectangular areas are:\n1. (0, 0, 1, 1)\n2. (1, 1, 2, 2)\n\nThis problem is particularly challenging because it requires the development of a sophisticated algorithm that can efficiently identify and count the maximum number of non-overlapping rectangular areas within the grid, while considering multiple constraints and edge cases. The computational complexity of the problem can be high, especially for large grid sizes, making it more difficult than the \"easy\" examples and at least as difficult as the \"hard\" examples.\"\n", "startingSolution": "\r\ndef max_non_overlapping_rectangles(grid):\r\n    \"\"\"\r\n    Given a 2D grid of size m x n, where each cell represents a building, find the maximum number of non-overlapping rectangular areas that can be constructed within the grid, such that each area satisfies the following conditions:\r\n\r\n    1. The area must be a rectangle, with its sides parallel to the grid axes.\r\n    2. The area must contain only cells with a value of 1, representing a building.\r\n    3. The area must have a height and width of at least 2 units.\r\n    4. The area must not overlap with any other area.\r\n\r\n    Args:\r\n        grid (List[List[int]]): A 2D grid, where grid[i][j] is 1 if there is a building at that cell, and 0 otherwise.\r\n\r\n    Returns:\r\n        int: The maximum number of non-overlapping rectangular areas that can be constructed within the grid.\r\n    \"\"\"\r\n    \r\n    \r\n    m, n = len(grid), len(grid[0])\r\n    used = [[False] * n for _ in range(m)]\r\n    count = 0\r\n\r\n    def can_form_rectangle(x, y, h, w):\r\n        for i in range(x, x + h):\r\n            for j in range(y, y + w):\r\n                if i >= m or j >= n or grid[i][j] == 0 or used[i][j]:\r\n                    return False\r\n        return True\r\n\r\n    def mark_rectangle(x, y, h, w):\r\n        for i in range(x, x + h):\r\n            for j in range(y, y + w):\r\n                used[i][j] = True\r\n\r\n    for i in range(m):\r\n        for j in range(n):\r\n            if grid[i][j] == 1 and not used[i][j]:\r\n                for h in range(2, m - i + 1):\r\n                    for w in range(2, n - j + 1):\r\n                        if can_form_rectangle(i, j, h, w):\r\n                            mark_rectangle(i, j, h, w)\r\n                            count += 1\r\n                            break\r\n\r\n    return count", "unitTests": [{"grid": "grid1 = [         [1, 1, 0, 1],         [1, 1, 0, 1],         [0, 0, 1, 1],         [1, 1, 1, 1]     ]", "expectedOutput": "2"}, {"expectedOutput": "1", "grid": " grid2 = [         [1, 0, 0, 1],         [1, 1, 0, 1],         [0, 0, 0, 0],         [1, 1, 1, 1]     ]"}, {"expectedOutput": "1", "grid": "grid5 = [         [1, 1, 1],         [1, 1, 1],         [1, 1, 1]     ]"}], "solution": "\ndef max_non_overlapping_rectangles(grid):\n    \"\"\"\n    Given a 2D grid of size m x n, where each cell represents a building, find the maximum number of non-overlapping rectangular areas that can be constructed within the grid, such that each area satisfies the following conditions:\n\n    1. The area must be a rectangle, with its sides parallel to the grid axes.\n    2. The area must contain only cells with a value of 1, representing a building.\n    3. The area must have a height and width of at least 2 units.\n    4. The area must not overlap with any other area.\n\n    Args:\n        grid (List[List[int]]): A 2D grid, where grid[i][j] is 1 if there is a building at that cell, and 0 otherwise.\n\n    Returns:\n        int: The maximum number of non-overlapping rectangular areas that can be constructed within the grid.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    used = [[False] * n for _ in range(m)]\n    count = 0\n\n    def can_form_rectangle(x, y, h, w):\n        for i in range(x, x + h):\n            for j in range(y, y + w):\n                if i >= m or j >= n or grid[i][j] == 0 or used[i][j]:\n                    return False\n        return True\n\n    def mark_rectangle(x, y, h, w):\n        for i in range(x, x + h):\n            for j in range(y, y + w):\n                used[i][j] = True\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1 and not used[i][j]:\n                for h in range(2, m - i + 1):\n                    for w in range(2, n - j + 1):\n                        if can_form_rectangle(i, j, h, w):\n                            mark_rectangle(i, j, h, w)\n                            count += 1\n                            break\n\n    return count\n\n>\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-13", "worker": "6e7b82a374b87eb3"}, {"problem": "You are given an undirected graph G = (V, E), where V is the set of vertices and E is the set of edges. Each vertex v in V has a weight w(v) associated with it, representing the cost of visiting that vertex.\n\nYour task is to find the minimum cost path from a given starting vertex s to a given ending vertex t, subject to the following constraints:\n\n1. The path must visit at least k distinct vertices, where k is a given positive integer.\n2. The path must not visit any vertex more than once, except for the starting and ending vertices, which may be visited multiple times.\n3. The cost of the path is the sum of the weights of the vertices visited, excluding the starting and ending vertices.\n\nThe graph can be complex, with multiple paths and varying vertex weights. Some paths may involve cycles, and you must ensure that the optimal path is chosen.\n\nReturn the minimum cost of the path satisfying the above constraints, or -1 if no such path exists.\n\nExample:\nG = ({1, 2, 3, 4, 5, 6, 7}, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 1), (1, 3), (3, 5), (5, 7)]), w(v) = v for all v in V\ns = 1, t = 7, k = 5\n\nExplanation: The minimum cost path is 1 -> 2 -> 3 -> 5 -> 6 -> 7, with a cost of 15.", "startingSolution": "\ndef min_cost_path(graph, s, t, k):\n\"\"\"\n    Args:\n    graph (Tuple[Set[int], List[Tuple[int, int]]]): A tuple containing a set of vertices and a list of edges.\n    weights (Dict[int, int]): A dictionary mapping each vertex to its weight.\n    s (int): The starting vertex.\n    t (int): The ending vertex.\n    k (int): The minimum number of distinct vertices to visit.\n    \n    Returns:\n    int: The minimum cost of the path satisfying the constraints, or -1 if no such path exists.\n\n    Example:\n    G = ({1, 2, 3, 4, 5, 6, 7}, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 1), (1, 3), (3, 5), (5, 7)]), w(v) = v for all v in V\n    s = 1, t = 7, k = 5\n    Output: 15\n    Explanation: The minimum cost path is 1 -> 2 -> 3 -> 5 -> 6 -> 7, with a cost of 15.\n\n    Constraints:\n    - The graph can have up to 100 vertices and 200 edges.\n    - The weights of the vertices can range from 1 to 100.\n    - The graph can have cycles, and multiple paths may exist.\n    - The algorithm needs to find the optimal path efficiently.\n    \"\"\"\n    pass\n", "unitTests": [{"graph": "G1 = ({1, 2, 3, 4, 5}, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)])", "s": "s1 = 1", "t": "t1 = 4", "k": "k1 = 3", "expectedOutput": "6"}, {"expectedOutput": "14", "graph": "G2 = ({1, 2, 3, 4, 5, 6}, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)])", "s": "s2 = 1", "t": "t2 = 6", "k": "k2 = 4"}, {"expectedOutput": "5", "graph": "G3 = ({1, 2, 3, 4, 5, 6, 7}, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 1)])", "s": "s3 = 1", "t": "t3 = 7", "k": "k3 = 5"}], "solution": "\nfrom typing import Tuple, Set, List, Dict\nfrom collections import deque\n\ndef min_cost_path(graph: Tuple[Set[int], List[Tuple[int, int]]], s: int, t: int, k: int) -> int:\n    \"\"\"\n    Find the minimum cost path from a starting vertex s to an ending vertex t in an undirected graph G, subject to the constraint that the path must visit at least k distinct vertices.\n\n    Args:\n        graph (Tuple[Set[int], List[Tuple[int, int]]]): A tuple containing a set of vertices and a list of edges.\n        s (int): The starting vertex.\n        t (int): The ending vertex.\n        k (int): The minimum number of distinct vertices to visit.\n\n    Returns:\n        int: The minimum cost of the path satisfying the constraints, or -1 if no such path exists.\n    \"\"\"\n    vertices, edges = graph\n    weights = {v: v for v in vertices}\n\n    def bfs(start, end, min_vertices):\n        queue = deque([(start, [start], 0)])\n        visited = set()\n\n        while queue:\n            vertex, path, cost = queue.popleft()\n            if vertex == end and len(set(path)) >= min_vertices:\n                return cost\n            if vertex not in visited:\n                visited.add(vertex)\n                for neighbor, _ in [edge for edge in edges if edge[0] == vertex or edge[1] == vertex]:\n                    queue.append((neighbor, path + [neighbor], cost + weights[neighbor]))\n\n        return -1\n\n    return bfs(s, t, k)\n", "meetsStartingSolutionFormatCriteria": true, "meetsFinalSolutionFormatCriteria": true, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-14", "worker": "0a5cceb1127927f6"}, {"problem": "\\nYou are given a set of n tasks, where each task has a start time, an end time, and a weight. Your goal is to implement a function that finds the maximum total weight of tasks that can be scheduled without any conflicts, where a conflict occurs if two tasks overlap in time.\\n\\nThe function should take the following input:\\n- A list of tasks, where each task is represented as a tuple (start_time, end_time, weight)\\n- The total number of tasks, n\\n\\nThe function should return the maximum total weight of tasks that can be scheduled without any conflicts.\\n\\nExample:\\n- Tasks = [(1, 3, 5), (2, 4, 3), (3, 5, 4), (4, 6, 2)]\\n- Output: 9 (the optimal schedule is to select the tasks with weights 5 and 4)\\n\\n- Tasks = [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)]\\n- Output: 15 (the optimal schedule is to select all tasks)\\n\\nThe problem is challenging because it requires the use of advanced data structures and algorithms to efficiently solve the scheduling problem, while considering the various constraints and dependencies between tasks.\\n\",\n    \"startingSolution\": \"def max_profit_from_tasks(tasks):\\r\\n    \\\"\\\"\\\"\\r\\n    Finds the maximum total weight that can be obtained by selecting a non-overlapping subset of tasks.\\r\\n    \\r\\n    Args:\\r\\n        tasks (List[Tuple[int, int, int]]): A list of tuples, where each tuple represents a task with (start_time, end_time, weight).\\r\\n    \\r\\n    Returns:\\r\\n        int: The maximum weight that can be obtained by selecting a non-overlapping subset of tasks.\\r\\n    \\\"\\\"\\\"\\r\\n    #Your code is here\\r\\npass \\r\\n\\r\\n\n", "startingSolution": "def max_non_overlapping_spells(spells):\r\n    \"\"\"\r\n    In this scenario, Hermione, Harry, and Hagrid are practicing spells secretly in Hagrid's hut, away from Dolores Umbridge. Everyone knows that Hermione is the most skilled, while Hagrid takes longer to cast spells. Additionally, they have only one wand among them, which causes problems for Harry, as he also takes longer to cast spells with a wand that is not his own. Despite their eagerness to learn magic quickly, even without the wand, they often find themselves uttering spells, though they know it won't work without the wand.\r\n\r\n    Given this context, you need to find out the maximum number of spells cast by Hermione, Harry, and Hagrid. The input is a list of spells, where each spell is represented as a tuple indicating the start and end times, along with the points each successful spell will earn for Hogwarts. Your task is to determine the maximum number of non-overlapping spells that can be cast using the single wand, ensuring that each spell has enough time to be cast without overlap.\r\n\r\n    However, there's a catch: sometimes they try to cast spells simultaneously, thinking it might work better. Therefore, you should also consider situations where multiple spells have overlapping times but are still considered one spell due to simultaneous attempts.\r\n\r\n    Special Conditions:\r\n    1. Hermione's Efficiency: She is the most skilled and can overlap with Harry's spell, reducing the end time of Harry's spell by 1 unit.\r\n    2. Hagrid's Slowness: Any spell overlapping with Hagrid's spell takes double the usual time to cast.\r\n    3. Simultaneous Casting: If multiple spells overlap, they are considered one spell but only if they are cast at exactly the same time. Overlaps that are not simultaneous should be handled normally.\r\n    4. Wand Sharing: Only one spell can be cast at any given moment with the wand, unless they attempt to cast simultaneously.\r\n    5. Harry's Third Spell Rule: Harry's spells fail unless they are the third spell in a sequence, counting only successful spells.\r\n    6. Hermione's Guarantee: Any spell overlapping with Hermione's time is considered successful regardless of the end time.\r\n\r\n    Additional Constraints:\r\n    1. Sequence Constraints: Hermione can cast spells at any time, but Harry's spells must follow a sequence where his third spell in the sequence is the only one guaranteed to be successful. Any deviation resets the sequence.\r\n    2. Wand Cooldown: After Hagrid casts a spell, the wand needs a cooldown period of 1 time unit before it can be used again.\r\n    3. Spell Priority: If spells overlap and cannot be cast simultaneously, priority is given first to Hermione, then to Harry, and lastly to Hagrid.\r\n\r\n    Input:\r\n        A list of spells, where each spell is represented as a tuple (start_time, end_time, points), indicating the start time, end time, and points for each spell.\r\n\r\n    Output:\r\n        An integer representing the maximum number of points that can be obtained by selecting a non-overlapping subset of spells.\r\n\r\n    Args:\r\n        spells (List[Tuple[int, int]]): A list of tuples, where each tuple represents a spell with (start_time, end_time, points for Hogvards)\r\n            with its start and end times.\r\n\r\n    Returns:\r\n        int: An integer representing the maximum number of points that can be obtained by selecting a non-overlapping subset of spells.\r\n    \"\"\"", "unitTests": [{"expectedOutput": "18", "spells": "[(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)]"}, {"expectedOutput": "0", "spells": "[]"}, {"spells": "[(1, 3, 5), (2, 4, 3), (3, 5, 4), (4, 6, 2)]", "expectedOutput": "9"}], "solution": "\nfrom typing import List, Tuple\n\ndef max_non_overlapping_spells(spells: List[Tuple[int, int, int]]) -> int:\n    # Sort the spells by their end time\n    spells.sort(key=lambda x: x[1])\n\n    n = len(spells)\n    dp = [0] * n  # Dynamic programming array to store the maximum points\n    harry_sequence = 0  # Keeps track of Harry's spell sequence\n\n    for i in range(n):\n        start, end, points = spells[i]\n\n        # Hermione's Guarantee: Any spell overlapping with Hermione's time is considered successful\n        if any(spell[0] <= start < spell[1] for spell in spells[:i]):\n            dp[i] = points\n        else:\n            # Harry's Third Spell Rule: Harry's spells fail unless they are the third spell in a sequence\n            if start >= 2 and harry_sequence == 2:\n                dp[i] = points\n                harry_sequence = 0\n            else:\n                harry_sequence += 1\n\n        # Hagrid's Slowness: Any spell overlapping with Hagrid's spell takes double the usual time to cast\n        if any(spell[0] <= start < spell[1] + 1 for spell in spells[:i]):\n            dp[i] = max(dp[i], dp[i - 1])\n        else:\n            # Hermione's Efficiency: She can overlap with Harry's spell, reducing the end time of Harry's spell by 1 unit\n            for j in range(i):\n                if spells[j][0] <= start < spells[j][1]:\n                    dp[i] = max(dp[i], dp[j] + points)\n                    break\n            else:\n                dp[i] = max(dp[i - 1] if i > 0 else 0, points + (dp[i - 1] if i > 0 else 0))\n\n    return max(dp)\n\n>\n", "meetsStartingSolutionFormatCriteria": true, "meetsFinalSolutionFormatCriteria": true, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-15", "worker": "057f47b83434cfb3"}, {"problem": "You are given a set of n rectangular packages, each with a unique label from 0 to n-1. Each package has a length, width, and height, represented as a tuple (l, w, h). Your task is to pack all the packages into a single rectangular container with the minimum possible volume, while ensuring that no two packages overlap and all packages are fully contained within the container.\n\nThe input to your function will be a list of tuples `packages`, where `packages[i] = (l, w, h)` represents the length, width, and height of the i-th package, respectively. Your function should return a tuple `(L, W, H)` representing the length, width, and height of the minimum-volume container that can hold all the packages without overlap.\n\nFor example, given the following input:\n\n```\npackages = [(1, 1, 1), (2, 2, 2), (3, 3, 3)]\n```\n\nThe output should be `(5, 3, 3)`, as the minimum-volume container that can hold all the packages is a cube of size 45.", "startingSolution": "def min_container_volume(packages: list[tuple[int, int, int]]) -> int:\r\n    \"\"\"\r\n    Given a set of n rectangular packages, each with a unique label from 0 to n-1 and a length, width, and height represented as a tuple (l, w, h), find the minimum-volume rectangular container that can hold all the packages without overlap.\r\n\r\n    The input is a list of tuples `packages`, where `packages[i] = (l, w, h)` represents the length, width, and height of the i-th package, respectively.\r\n    The function should return a tuple `(L, W, H)` representing the length, width, and height of the minimum-volume container that can hold all the packages without overlap.\r\n\r\n    For example, given the input `packages = [(1, 1, 1), (2, 2, 2), (3, 3, 3)]`, The output should be 45.\r\n\r\n    The time complexity of the solution should be O(n log n), where n is the number of packages, and the space complexity should be O(n).\r\n    \"\"\"", "unitTests": [{"": "[(1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (1, 1, 1), (2, 2, 2), (2, 2, 2), (2, 2, 2), (2, 2, 2), (2, 2, 2), (2, 2, 2), (2, 2, 2)]", "expectedOutput": "64"}, {"expectedOutput": "45", "": "[(1, 1, 1), (2, 2, 2), (3, 3, 3)]"}, {"expectedOutput": "96", "": "[(2, 2, 6), (2, 2, 2), (2, 2, 2), (2, 2, 4), (2, 2, 4), (2, 2, 4), (2, 2, 2)]"}], "solution": "import functools\r\nfrom itertools import product\r\n\r\n\r\nIntervals = list[tuple[int, int]]\r\n\r\n\r\ndef is_fits(\r\n    dims: tuple[int, int, int],\r\n    coords: tuple[int, int, int],\r\n    size: tuple[int, int, int],\r\n) -> bool:\r\n    max_w, max_h, max_l = dims\r\n    origin_x, origin_y, origin_z = coords\r\n    box_w, box_h, box_l = size\r\n\r\n    if box_w + origin_x > max_w:\r\n        return False\r\n    if box_h + origin_y > max_h:\r\n        return False\r\n    if box_l + origin_z > max_l:\r\n        return False\r\n    return True\r\n\r\n\r\ndef is_overlaps(intervals: Intervals, box: tuple[int, int]) -> bool:\r\n    for start, end in intervals:\r\n        if start <= box[0] < end:\r\n            return True\r\n\r\n        if start <= box[1] <= end:\r\n            return True\r\n\r\n    return False\r\n\r\n\r\ndef place_or_fail_intervals(\r\n    matrix: list[list[Intervals]],\r\n    coords: tuple[int, int, int],\r\n    size: tuple[int, int, int],\r\n    dims: tuple[int, int, int],\r\n) -> bool:\r\n    origin_x, origin_y, origin_z = coords\r\n    box_w, box_h, box_l = size\r\n    if not is_fits(dims, coords=coords, size=size):\r\n        return False\r\n\r\n    current_box_depth = (origin_z, origin_z + box_l)\r\n\r\n    for i in range(origin_x, origin_x + box_w):\r\n        for j in range(origin_y, origin_y + box_h):\r\n            if is_overlaps(matrix[i][j], current_box_depth):\r\n                return False\r\n\r\n    for i in range(origin_x, origin_x + box_w):\r\n        for j in range(origin_y, origin_y + box_h):\r\n            matrix[i][j].append(current_box_depth)\r\n\r\n    return True\r\n\r\n\r\n@functools.lru_cache\r\ndef rotate_box(w: int, h: int, l: int):\r\n    return set(\r\n        ((w, h, l), (w, l, h), (h, w, l), (h, l, w), (l, w, h), (l, h, w)))\r\n\r\n\r\ndef get_all_box_configs(boxes: list[tuple[int, int, int]]):\r\n    return product(*[rotate_box(w, h, l) for w, h, l in boxes])\r\n\r\n\r\ndef validate_solution(packages: list[tuple[int, int, int]],\r\n                      matrix_size: tuple[int, int, int]) -> bool:\r\n    x, y, z = matrix_size\r\n\r\n    for config in get_all_box_configs(packages):\r\n        matrix: list[list[Intervals]] = [[[] for _ in range(y)]\r\n                                         for _ in range(x)]\r\n        left_to_place = len(packages)\r\n        memorization: set[tuple[tuple[int, int, int], tuple[int, int,\r\n                                                            int]]] = set()\r\n\r\n        for box in config:\r\n            for coords in product(range(x), range(y), range(z)):\r\n                if (coords, box) in memorization:\r\n                    success = False\r\n                else:\r\n                    success = place_or_fail_intervals(matrix,\r\n                                                      coords=coords,\r\n                                                      size=box,\r\n                                                      dims=matrix_size)\r\n\r\n                    if not success:\r\n                        memorization.add((coords, box))\r\n\r\n                if success:\r\n                    left_to_place -= 1\r\n                    break\r\n\r\n        if left_to_place == 0:\r\n            return True\r\n\r\n    return False\r\n\r\n\r\ndef min_container_volume(packages: list[tuple[int, int, int]]) -> int:\r\n    \"\"\"\r\n    Given a set of n rectangular packages, each with a unique label from 0 to n-1 and a length, width, and height represented as a tuple (l, w, h), find the minimum-volume rectangular container that can hold all the packages without overlap.\r\n\r\n    The input is a list of tuples `packages`, where `packages[i] = (l, w, h)` represents the length, width, and height of the i-th package, respectively.\r\n    The function should return a tuple `(L, W, H)` representing the length, width, and height of the minimum-volume container that can hold all the packages without overlap.\r\n\r\n    For example, given the input `packages = [(1, 1, 1), (2, 2, 2), (3, 3, 3)]`, the output should be `(3, 3, 3)`.\r\n\r\n    The time complexity of the solution should be O(n log n), where n is the number of packages, and the space complexity should be O(n).\r\n    \"\"\"\r\n    width, height, length = functools.reduce(\r\n        lambda a, b: (a[0] + b[0], a[1] + b[1], a[2] + b[2]), packages)\r\n    current_result = (width, height, length)\r\n    possible_solutions = product(range(1, width + 1), range(1, height + 1),\r\n                                 range(1, length + 1))\r\n\r\n    for current_width, current_height, current_length in possible_solutions:\r\n        is_valid_solution = validate_solution(packages=packages,\r\n                                              matrix_size=(current_width,\r\n                                                           current_height,\r\n                                                           current_length))\r\n\r\n        if is_valid_solution and current_result[0] * current_result[\r\n                1] * current_result[\r\n                    2] > current_width * current_height * current_length:\r\n            current_result = (current_width, current_height, current_length)\r\n            continue\r\n\r\n    return current_result[0] * current_result[1] * current_result[2]", "meetsStartingSolutionFormatCriteria": true, "meetsFinalSolutionFormatCriteria": true, "meetsCorrectnessCriteria": true, "meetsDifficultyCriteria": false, "id": "example-16", "worker": "94607a49db8dc666"}, {"problem": "You are given a directed graph represented as an adjacency list, where each node in the graph is labeled with a unique integer. Your task is to design a function that finds the maximum number of nodes that can be reached from any single starting node while satisfying the following constraints:\n\n1. Each node can only be visited a maximum of k times. If a node is visited more than k times during the traversal, that path must be abandoned.\n2. The traversal must be completed within a maximum depth of d, beyond which nodes cannot be considered reachable.\n3. The traversal must avoid a given set of forbidden nodes F.\n4. The traversal must visit at least one node from a specified set of required nodes R.\n5. If there are multiple nodes with the same maximum reachable count, return the starting node with the smallest label.\n\nInput:\n- A directed graph represented as an adjacency list, where each node is labeled with a unique integer.\n- The adjacency list is a dictionary (or equivalent data structure) where the keys are node labels and the values are lists of neighboring node labels.\n- An integer k, the maximum number of times a node can be visited.\n- An integer d, the maximum depth for the traversal.\n- A list F, represents the set of forbidden nodes that cannot be visited.\n- A list R, representing the set of required nodes, at least one of which must be visited during the traversal.\n\nOutput:\n- The maximum number of nodes that can be reached from any single starting node in the graph.\n- The label of the starting node that achieves this maximum count.\n\nThe function should work as follows:\n1. Traverse the graph starting from each node, respecting the constraints of maximum visits (k), and maximum depth (d), avoiding forbidden nodes (F), and visiting at least one required node (R).\n2. Keep track of the maximum count of reachable nodes and the corresponding starting node label across all starting nodes.\n3. Return a tuple with the maximum count of reachable nodes and the corresponding starting node label.\n\nThe solution should be as efficient as possible in terms of time and space complexity, as the input graph can be large and complex. The function should handle all possible input graphs, including those with cycles and disconnected components.", "startingSolution": "\ndef max_reachable_nodes(graph, k, d, F, R):\n    \"\"\"\n    Find the maximum number of nodes that can be reached from any single starting node in a directed graph, while respecting the given constraints.\n\n    Args:\n        graph (dict): A dictionary representing the adjacency list of the directed graph, where the keys are node labels and the values are lists of neighboring node labels.\n        k (int): The maximum number of times a node can be visited during the traversal.\n        d (int): The maximum depth of the traversal.\n        F (list): A list of forbidden nodes that cannot be visited.\n        R (list): A list of required nodes, at least one of which must be visited during the traversal.\n\n    Returns:\n        tuple: A tuple containing the maximum number of reachable nodes and the corresponding starting node label.\n    \"\"\"\n    pass\n", "unitTests": [{"graph": "graph = {0: [1, 2], 1: [2], 2: [0, 3], 3: []}", "k": "k = 2", "d": "d = 3 ", "F": "F = [3]", "R": "R = [1]", "expectedOutput": "(3, 0)"}, {"expectedOutput": "2, 0)", "graph": "graph = {0: [1], 1: [2], 2: [3], 3: [0]}", "k": "k = 1", "d": "d = 4", "F": "F = [2]", "R": "R = [1, 3]"}, {"expectedOutput": "(4, 0)", "graph": "graph = {0: [1, 2], 1: [2, 3], 2: [3], 3: [4], 4: []}", "k": "k = 2", "d": "d = 3", "F": "F = []", "R": "R = [3]"}], "solution": "\nfrom collections import defaultdict\n\ndef max_reachable_nodes(graph, k, d, F, R):\n    \"\"\"\n    Find the maximum number of nodes that can be reached from any single starting node in a directed graph, while respecting the given constraints.\n\n    Args:\n        graph (dict): A dictionary representing the adjacency list of the directed graph, where the keys are node labels and the values are lists of neighboring node labels.\n        k (int): The maximum number of times a node can be visited during the traversal.\n        d (int): The maximum depth of the traversal.\n        F (list): A list of forbidden nodes that cannot be visited.\n        R (list): A list of required nodes, at least one of which must be visited during the traversal.\n\n    Returns:\n        tuple: A tuple containing the maximum number of reachable nodes and the corresponding starting node label.\n    \"\"\"\n    max_reachable = 0\n    start_node = None\n\n    for node in graph:\n        if node in F:\n            continue\n\n        visited = defaultdict(int)\n        reachable = 0\n        stack = [(node, 0)]\n\n        while stack:\n            curr_node, depth = stack.pop()\n\n            if depth > d or visited[curr_node] >= k:\n                continue\n\n            visited[curr_node] += 1\n            reachable += 1\n\n            if curr_node in R:\n                R.remove(curr_node)\n\n            if not R:\n                if reachable > max_reachable:\n                    max_reachable = reachable\n                    start_node = node\n                elif reachable == max_reachable and node < start_node:\n                    start_node = node\n                break\n\n            for neighbor in graph[curr_node]:\n                if neighbor not in F:\n                    stack.append((neighbor, depth + 1))\n\n    return (max_reachable, start_node)\n", "meetsStartingSolutionFormatCriteria": true, "meetsFinalSolutionFormatCriteria": true, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-17", "worker": "0a5cceb1127927f6"}, {"problem": "\nYou are the manager of a software development team, and you need to create an optimal schedule for your team to work on multiple projects with dependencies and deadlines. Your team consists of n developers, and you have m projects that need to be completed. Each project has a set of tasks that need to be assigned to the developers, and each task has a specific duration, a set of required skills, and a set of prerequisite tasks that must be completed first.\n\nAdditionally, each developer has varying levels of expertise for each skill, and their productivity on a task depends on how well their skills match the task's requirements. Each project also has a different priority and a deadline, and the schedule must optimize for both the overall project completion time and the satisfaction of the project deadlines.\n\nThe function you need to implement should take the following input:\n- A list of n developers, where each developer is represented by their name, a list of their skills, and their proficiency levels for each skill.\n- A list of m projects, where each project is represented by a list of tasks. Each task has a duration, a list of required skills, a list of prerequisite tasks, and a deadline.\n\nThe function should return a schedule that assigns each task to a developer, such that the overall project completion time is minimized, and the number of missed deadlines is also minimized. The schedule should be represented as a list of tuples, where each tuple contains the project name, the task name, the assigned developer's name, and the start and end times of the task.\n\nThe function should also return a metric that represents the quality of the generated schedule, such as the overall project completion time and the number of missed deadlines.\n\nExample:\n- Input:\n  - Developers: [(\"Alice\", [\"Java\", \"Python\", \"SQL\"], [4, 3, 5]), (\"Bob\", [\"Python\", \"C++\", \"Bash\"], [3, 4, 2]), (\"Charlie\", [\"Java\", \"C++\", \"Git\"], [5, 4, 3])]\n  - Projects:\n    - Project A: [(\"Task 1\", 2, [\"Java\", \"Python\"], [], 5), (\"Task 2\", 3, [\"Python\", \"SQL\"], [\"Task 1\"], 7), (\"Task 3\", 4, [\"Java\", \"C++\"], [\"Task 1\", \"Task 2\"], 10)]\n    - Project B: [(\"Task 1\", 3, [\"Python\", \"C++\"], [], 6), (\"Task 2\", 2, [\"C++\", \"Bash\"], [\"Task 1\"], 8)]\n- Output:\n  - Schedule: [(\"Project A\", \"Task 1\", \"Alice\", 0, 2), (\"Project A\", \"Task 2\", \"Alice\", 2, 5), (\"Project A\", \"Task 3\", \"Charlie\", 5, 9), (\"Project B\", \"Task 1\", \"Bob\", 0, 3), (\"Project B\", \"Task 2\", \"Bob\", 3, 5)]\n  - Metrics: Overall project completion time: 9, Number of missed deadlines: 0\n\nThe time complexity of your solution should be O(n * m * k * log(n * m * k)), where n is the number of developers, m is the number of projects, and k is the maximum number of tasks in a project. The space complexity should be O(n + m + k).\n", "startingSolution": "import heapq\r\nfrom collections import defaultdict, deque\r\n\r\ndef schedule_projects(developers, projects):\r\n    # Developer data structure: {developer_name: {skill: proficiency, ...}}\r\n    devs = {name: dict(zip(skills, profs)) for name, skills, profs in developers}\r\n    dev_availability = {name: 0 for name in devs}\r\n\r\n    # Task data structure: {project_name: {task_name: (duration, skills, prerequisites, deadline)}}\r\n    task_dict = defaultdict(dict)\r\n    for project in projects:\r\n        project_name = project['name']\r\n        for task in project['tasks']:\r\n            task_name = task['name']\r\n            task_dict[project_name][task_name] = (task['duration'], task['skills'], task['prerequisites'], task['deadline'])\r\n\r\n    # Dependency graph and in-degree count\r\n    dependency_graph = defaultdict(lambda: defaultdict(list))\r\n    in_degree = defaultdict(lambda: defaultdict(int))\r\n    \r\n    for project, tasks in task_dict.items():\r\n        for task, (_, _, prereqs, _) in tasks.items():\r\n            for prereq in prereqs:\r\n                dependency_graph[project][prereq].append(task)\r\n                in_degree[project][task] += 1\r\n\r\n    # Priority queue for tasks ready to be scheduled\r\n    pq = []\r\n    for project, tasks in task_dict.items():\r\n        for task, (duration, skills, prereqs, deadline) in tasks.items():\r\n            if in_degree[project][task] == 0:\r\n                heapq.heappush(pq, (deadline, project, task, duration, skills, prereqs))\r\n    \r\n    # Schedule result and metrics\r\n    schedule = []\r\n    missed_deadlines = 0\r\n    project_completion_times = defaultdict(int)\r\n\r\n    while pq:\r\n        deadline, project, task, duration, skills, prereqs = heapq.heappop(pq)\r\n        \r\n        # Find the best developer for the task\r\n        best_developer = None\r\n        best_start_time = float('inf')\r\n        \r\n        for developer, proficiency in devs.items():\r\n            start_time = dev_availability[developer]\r\n            if all(skill in proficiency and proficiency[skill] > 0 for skill in skills):\r\n                if start_time < best_start_time:\r\n                    best_start_time = start_time\r\n                    best_developer = developer\r\n        \r\n        if best_developer is None:\r\n            continue\r\n        \r\n        end_time = best_start_time + duration\r\n        dev_availability[best_developer] = end_time\r\n        \r\n        if end_time > deadline:\r\n            missed_deadlines += 1\r\n        \r\n        schedule.append((project, task, best_developer, best_start_time, end_time))\r\n        project_completion_times[project] = max(project_completion_times[project], end_time)\r\n        \r\n        for dependent in dependency_graph[project][task]:\r\n            in_degree[project][dependent] -= 1\r\n            if in_degree[project][dependent] == 0:\r\n                dep_duration, dep_skills, dep_prereqs, dep_deadline = task_dict[project][dependent]\r\n                heapq.heappush(pq, (dep_deadline, project, dependent, dep_duration, dep_skills, dep_prereqs))\r\n    \r\n    overall_completion_time = max(project_completion_times.values()) if project_completion_times else 0\r\n    \r\n    return schedule, {\"overall_completion_time\": overall_completion_time, \"missed_deadlines\": missed_deadlines}\r\n\r\n# Example usage\r\ndevelopers = [\r\n    (\"Alice\", [\"Java\", \"Python\", \"SQL\"], [4, 3, 5]),\r\n    (\"Bob\", [\"Python\", \"C++\", \"Bash\"], [3, 4, 2]),\r\n    (\"Charlie\", [\"Java\", \"C++\", \"Git\"], [5, 4, 3])\r\n]\r\nprojects = [\r\n    {\r\n        \"name\": \"Project A\",\r\n        \"tasks\": [\r\n            {\"name\": \"Task 1\", \"duration\": 2, \"skills\": [\"Java\", \"Python\"], \"prerequisites\": [], \"deadline\": 5},\r\n            {\"name\": \"Task 2\", \"duration\": 3, \"skills\": [\"Python\", \"SQL\"], \"prerequisites\": [\"Task 1\"], \"deadline\": 7},\r\n            {\"name\": \"Task 3\", \"duration\": 4, \"skills\": [\"Java\", \"C++\"], \"prerequisites\": [\"Task 1\", \"Task 2\"], \"deadline\": 10}\r\n        ]\r\n    },\r\n    {\r\n        \"name\": \"Project B\",\r\n        \"tasks\": [\r\n            {\"name\": \"Task 1\", \"duration\": 3, \"skills\": [\"Python\", \"C++\"], \"prerequisites\": [], \"deadline\": 6},\r\n            {\"name\": \"Task 2\", \"duration\": 2, \"skills\": [\"C++\", \"Bash\"], \"prerequisites\": [\"Task 1\"], \"deadline\": 8}\r\n        ]\r\n    }\r\n]\r\n\r\nschedule, metrics = schedule_projects(developers, projects)\r\nprint(\"Schedule:\", schedule)\r\nprint(\"Metrics:\", metrics)\r\n", "unitTests": [{"developers": "developers = [         (\"Alice\", [\"Java\", \"Python\", \"SQL\"], [4, 3, 5]),         (\"Bob\", [\"Python\", \"C++\", \"Bash\"], [3, 4, 2]),         (\"Charlie\", [\"Java\", \"C++\", \"Git\"], [5, 4, 3])     ]", "projects": "projects = [         {             \"name\": \"Project A\",             \"tasks\": [                 {\"name\": \"Task 1\", \"duration\": 2, \"skills\": [\"Java\", \"Python\"], \"prerequisites\": [], \"deadline\": 5},                 {\"name\": \"Task 2\", \"duration\": 3, \"skills\": [\"Python\", \"SQL\"], \"prerequisites\": [\"Task 1\"], \"deadline\": 7},                 {\"name\": \"Task 3\", \"duration\": 4, \"skills\": [\"Java\", \"C++\"], \"prerequisites\": [\"Task 1\", \"Task 2\"], \"deadline\": 10}             ]         },         {             \"name\": \"Project B\",             \"tasks\": [                 {\"name\": \"Task 1\", \"duration\": 3, \"skills\": [\"Python\", \"C++\"], \"prerequisites\": [], \"deadline\": 6},                 {\"name\": \"Task 2\", \"duration\": 2, \"skills\": [\"C++\", \"Bash\"], \"prerequisites\": [\"Task 1\"], \"deadline\": 8}             ]         }     ]          schedule, metrics = schedule_projects(developers, projects)          expected_schedule = [         (\"Project A\", \"Task 1\", \"Alice\", 0, 2),         (\"Project A\", \"Task 2\", \"Alice\", 2, 5),         (\"Project A\", \"Task 3\", \"Charlie\", 5, 9),         (\"Project B\", \"Task 1\", \"Bob\", 0, 3),         (\"Project B\", \"Task 2\", \"Bob\", 3, 5)     ]", "expectedOutput": "0"}, {"expectedOutput": "0", "developers": "developers = [         (\"Alice\", [\"Java\", \"Python\", \"SQL\"], [4, 3, 5])     ]", "projects": " projects = [         {             \"name\": \"Project A\",             \"tasks\": [                 {\"name\": \"Task 1\", \"duration\": 2, \"skills\": [\"Java\", \"Python\"], \"prerequisites\": [], \"deadline\": 5},                 {\"name\": \"Task 2\", \"duration\": 3, \"skills\": [\"Python\", \"SQL\"], \"prerequisites\": [\"Task 1\"], \"deadline\": 7},                 {\"name\": \"Task 3\", \"duration\": 4, \"skills\": [\"Java\", \"SQL\"], \"prerequisites\": [\"Task 1\", \"Task 2\"], \"deadline\": 10}             ]         }     ]          schedule, metrics = schedule_projects(developers, projects)          expected_schedule = [         (\"Project A\", \"Task 1\", \"Alice\", 0, 2),         (\"Project A\", \"Task 2\", \"Alice\", 2, 5),         (\"Project A\", \"Task 3\", \"Alice\", 5, 9)     ]"}, {"expectedOutput": "2", "developers": "developers = [         (\"Alice\", [\"Java\", \"Python\"], [4, 3]),         (\"Bob\", [\"Python\", \"C++\"], [3, 4])     ]", "projects": "projects = [         {             \"name\": \"Project A\",             \"tasks\": [                 {\"name\": \"Task 1\", \"duration\": 2, \"skills\": [\"Java\", \"Python\"], \"prerequisites\": [], \"deadline\": 1},                 {\"name\": \"Task 2\", \"duration\": 3, \"skills\": [\"Python\"], \"prerequisites\": [\"Task 1\"], \"deadline\": 4}             ]         }     ]          schedule, metrics = schedule_projects(developers, projects)          expected_schedule = [         (\"Project A\", \"Task 1\", \"Alice\", 0, 2),         (\"Project A\", \"Task 2\", \"Bob\", 2, 5)     ]     "}], "solution": "\nimport heapq\nfrom collections import defaultdict, deque\n\ndef schedule_projects(developers, projects):\n    # Developer data structure: {developer_name: {skill: proficiency, ...}}\n    devs = {name: dict(zip(skills, profs)) for name, skills, profs in developers}\n    dev_availability = {name: 0 for name in devs}\n\n    # Task data structure: {project_name: {task_name: (duration, skills, prerequisites, deadline)}}\n    task_dict = defaultdict(dict)\n    for project in projects:\n        project_name = project['name']\n        for task in project['tasks']:\n            task_name = task['name']\n            task_dict[project_name][task_name] = (task['duration'], task['skills'], task['prerequisites'], task['deadline'])\n\n    # Dependency graph and in-degree count\n    dependency_graph = defaultdict(lambda: defaultdict(list))\n    in_degree = defaultdict(lambda: defaultdict(int))\n    \n    for project, tasks in task_dict.items():\n        for task, (_, _, prereqs, _) in tasks.items():\n            for prereq in prereqs:\n                dependency_graph[project][prereq].append(task)\n                in_degree[project][task] += 1\n\n    # Priority queue for tasks ready to be scheduled\n    pq = []\n    for project, tasks in task_dict.items():\n        for task, (duration, skills, prereqs, deadline) in tasks.items():\n            if in_degree[project][task] == 0:\n                heapq.heappush(pq, (deadline, project, task, duration, skills, prereqs))\n    \n    # Schedule result and metrics\n    schedule = []\n    missed_deadlines = 0\n    project_completion_times = defaultdict(int)\n\n    while pq:\n        deadline, project, task, duration, skills, prereqs = heapq.heappop(pq)\n        \n        # Find the best developer for the task\n        best_developer = None\n        best_start_time = float('inf')\n        \n        for developer, proficiency in devs.items():\n            start_time = dev_availability[developer]\n            if all(skill in proficiency and proficiency[skill] > 0 for skill in skills):\n                if start_time < best_start_time:\n                    best_start_time = start_time\n                    best_developer = developer\n        \n        if best_developer is None:\n            continue\n        \n        end_time = best_start_time + duration\n        dev_availability[best_developer] = end_time\n        \n        if end_time > deadline:\n            missed_deadlines += 1\n        \n        schedule.append((project, task, best_developer, best_start_time, end_time))\n        project_completion_times[project] = max(project_completion_times[project], end_time)\n        \n        for dependent in dependency_graph[project][task]:\n            in_degree[project][dependent] -= 1\n            if in_degree[project][dependent] == 0:\n                dep_duration, dep_skills, dep_prereqs, dep_deadline = task_dict[project][dependent]\n                heapq.heappush(pq, (dep_deadline, project, dependent, dep_duration, dep_skills, dep_prereqs))\n    \n    overall_completion_time = max(project_completion_times.values()) if project_completion_times else 0\n    \n    return schedule, {\"overall_completion_time\": overall_completion_time, \"missed_deadlines\": missed_deadlines}\n\n# Example usage\ndevelopers = [\n    (\"Alice\", [\"Java\", \"Python\", \"SQL\"], [4, 3, 5]),\n    (\"Bob\", [\"Python\", \"C++\", \"Bash\"], [3, 4, 2]),\n    (\"Charlie\", [\"Java\", \"C++\", \"Git\"], [5, 4, 3])\n]\nprojects = [\n    {\n        \"name\": \"Project A\",\n        \"tasks\": [\n            {\"name\": \"Task 1\", \"duration\": 2, \"skills\": [\"Java\", \"Python\"], \"prerequisites\": [], \"deadline\": 5},\n            {\"name\": \"Task 2\", \"duration\": 3, \"skills\": [\"Python\", \"SQL\"], \"prerequisites\": [\"Task 1\"], \"deadline\": 7},\n            {\"name\": \"Task 3\", \"duration\": 4, \"skills\": [\"Java\", \"C++\"], \"prerequisites\": [\"Task 1\", \"Task 2\"], \"deadline\": 10}\n        ]\n    },\n    {\n        \"name\": \"Project B\",\n        \"tasks\": [\n            {\"name\": \"Task 1\", \"duration\": 3, \"skills\": [\"Python\", \"C++\"], \"prerequisites\": [], \"deadline\": 6},\n            {\"name\": \"Task 2\", \"duration\": 2, \"skills\": [\"C++\", \"Bash\"], \"prerequisites\": [\"Task 1\"], \"deadline\": 8}\n        ]\n    }\n]\n\nschedule, metrics = schedule_projects(developers, projects)\nprint(\"Schedule:\", schedule)\nprint(\"Metrics:\", metrics)\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-18", "worker": "725396297197498f"}, {"problem": "\\nYou are given a 2D grid of integers, where each cell represents a building with a height. Your task is to implement a function that calculates the total amount of water that can be trapped between the buildings, given the following constraints:\\n\\n1. Water can be trapped only between two or more buildings. If there is only one building or no buildings, no water can be trapped.\\n2. The amount of water that can be trapped at a given cell is the minimum of the maximum height of the buildings to the left of that cell and the maximum height of the buildings to the right of that cell, minus the height of the building at that cell.\\n3. The function should take a 2D grid of integers as input, where each integer represents the height of a building, and return the total amount of water that can be trapped.\\n\\nExample:\\nInput: [[1,0,2,1,0,1,3,2,1,2,1]]\\nOutput: 6\\n\\nExplanation:\\nThe above elevation map (black section) is represented by the grid. In this case, 6 units of water (blue section) can be trapped.\\n", "startingSolution": "\r\ndef calculate_trapped_water(heights, temperature):\r\n    \"\"\"\r\n    Calculate the total amount of water that can be trapped between buildings under given conditions.\r\n    \r\n    Args:\r\n        heights (list[list[int]]): 2D array of integers representing the heights of buildings.\r\n        temperature (int): The temperature of the day in degrees Celsius.\r\n    \r\n    Returns:\r\n        int: The total amount of water that can be trapped under the given conditions.\r\n    \"\"\"\r\n\r\n    Constraints:\r\n    - Water can only be trapped between two or more buildings.\r\n    - The amount of water trapped at a cell is the minimum of the maximum height of buildings to the left and the maximum height of buildings to the right, minus the height of the building at that cell.\r\n    - If the temperature is below zero degrees Celsius, water turns into ice, and precipitation falls as snow\r\n    \"\"\"\r\n    pass\r\n", "unitTests": [{"heights": "[[1,0,2,1,0,1,3,2,1,2,1]]", "temperature": "2", "expectedOutput": "6"}, {"expectedOutput": "6", "heights": "[[1,0,2,1,0,1,3,2,1,2,1]]", "temperature": "-2"}, {"expectedOutput": "1", "heights": "[[0, 1, 0, 1, 0]]", "temperature": "0"}, {"expectedOutput": "1", "heights": "[[0, 1, 0, 1, 0]]", "temperature": "-3"}], "solution": "\ndef calculate_trapped_water(heights, temperature):\n    \"\"\"\n    Calculate the total amount of water that can be trapped between buildings under given conditions.\n    \n    Args:\n        heights (list[list[int]]): 2D array of integers representing the heights of buildings.\n        temperature (int): The temperature of the day in degrees Celsius.\n    \n    Returns:\n        int: The total amount of water that can be trapped under the given conditions.\n    \n    Constraints:\n    - Water can only be trapped between two or more buildings.\n    - The amount of water trapped at a cell is the minimum of the maximum height of buildings to the left and the maximum height of buildings to the right, minus the height of the building at that cell.\n    - If the temperature is below zero degrees Celsius, water turns into ice, and precipitation falls as snow\n    \"\"\"\n    if temperature < 0:\n        return 0\n    \n    rows, cols = len(heights), len(heights[0])\n    total_water = 0\n    \n    for i in range(rows):\n        left_max = 0\n        right_max = 0\n        for j in range(cols):\n            # Calculate the maximum height of buildings to the left\n            left_max = max(left_max, heights[i][j])\n            \n            # Calculate the maximum height of buildings to the right\n            right_max = max(right_max, heights[i][cols - 1 - j])\n            \n            # Calculate the amount of water that can be trapped at the current cell\n            water_level = min(left_max, right_max) - heights[i][j]\n            if water_level > 0:\n                total_water += water_level\n    \n    return total_water\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-19", "worker": "057f47b83434cfb3"}, {"problem": "You are given an array of integers `nums` and an integer `k`. Your task is to find the maximum product of any contiguous subarray of `nums` of length exactly `k`.\n\nThe product of a subarray is defined as the product of all the elements in that subarray. For example, the product of the subarray `[2, 3, 4]` is `24`.\n\nYour function should take the input array `nums` and the integer `k` as parameters, and return the maximum product of any contiguous subarray of `nums` of length exactly `k`.\n\nNote that the subarray must contain exactly `k` elements, and the product may overflow the maximum integer value. In such cases, return the maximum possible sum modulo `10^9 + 7`, If the product of the subarrays is negative, the mod result should be negative.\n", "startingSolution": "\ndef maxSubarrayProduct(nums: list[int], k: int) -> int:\n    \"\"\"\n    Given an array of integers `nums` and an integer `k`, return the maximum product of any contiguous subarray of `nums` of length exactly `k`.\n\n    The product of a subarray is defined as the product of all the elements in that subarray. For example, the product of the subarray `[2, 3, 4]` is `24`.\n\n    Note that the subarray must contain exactly `k` elements, and the product may overflow the maximum integer value. In such cases, return the maximum possible product modulo `10^9 + 7`.\n\n    If the product of the subarrays is negative, the mod result should be negative.\n\n    Args:\n        nums (List[int]): An array of integers.\n        k (int): The length of the contiguous subarray.\n\n    Returns:\n        int: The maximum product of any contiguous subarray of `nums` of length exactly `k`.\n    \"\"\"\n    pass\n", "unitTests": [{"": "nums=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k=3", "expectedOutput": "720"}, {"expectedOutput": "2000", "": "[10, 10, 10, -30, 10, 10, 20], k=3"}, {"expectedOutput": "72000", "": "[10, 10, 60, -20, -60, 5, 5], k=3"}, {"expectedOutput": "-27000000", "": "[10, 10, -100, 30, 90], k=5"}, {"expectedOutput": "1536", "": "nums=[-4, -6, 8, -2, -4, 2, 10, -6], k=5"}, {"": "nums=[ 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18, 10**18 ], k=32", "expectedOutput": "23859541"}], "solution": "def reminder(num, mod):\n    _remainder = num % mod\n\n    if num < 0 and _remainder > 0:\n        _remainder -= mod\n    elif num > 0 and _remainder < 0:\n        _remainder += mod\n\n    return _remainder\n\ndef fast_power_mod(a: int, b: int, mod: int):\n    result = 1\n\n    while b > 0:\n        if b & 1 == 1:\n            result = result * a\n            result = reminder(result, mod)\n        \n        b = b // 2\n        a = a * a\n        a = reminder(a, mod)\n\n    return result\n\ndef inv(a: int, mod: int):\n    return fast_power_mod(a, mod - 2, mod)\n\n\ndef maxSubarraySum(nums: list[int], k: int) -> int:\n    \"\"\"\n    Given an array of integers `nums` and an integer `k`, return the maximum product of any contiguous subarray of `nums` of length exactly `k`.\n\n    The product of a subarray is defined as the product of all the elements in that subarray. For example, the product of the subarray `[2, 3, 4]` is `24`.\n\n    Note that the subarray must contain exactly `k` elements, and the product may overflow the maximum integer value. In such cases, return the maximum possible product modulo `10^9 + 7`.\n\n    If the product of the subarrays is negative, the mod result should be negative.\n\n    Args:\n        nums (List[int]): An array of integers.\n        k (int): The length of the contiguous subarray.\n\n    Returns:\n        int: The maximum product of any contiguous subarray of `nums` of length exactly `k`.\n    \"\"\"\n    MOD = 10**9 + 7\n\n    prefix_prod = [1]\n    result = -10**18\n\n    for i in range(1, len(nums) + 1):\n        prefix_prod.append(reminder(nums[i - 1] * prefix_prod[i - 1], MOD))\n        \n    for i in range(0, len(prefix_prod) - k):\n        im_result = reminder(prefix_prod[i + k] * inv(prefix_prod[i], MOD), MOD)\n        result = max(result, im_result)\n\n    return result", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-20", "worker": "94607a49db8dc666"}, {"problem": "\nYou are given a set of tasks T, where each task t in T has a start time s(t), an end time e(t), a profit p(t), and a weight w(t) associated with it. Your goal is to find a subset of tasks S that can be scheduled without any overlaps, such that the total weighted profit of the scheduled tasks is maximized.\n\nThe input to your function is:\n- A list of tasks T, where each task t is represented as a tuple (s(t), e(t), p(t), w(t)).\n- An integer k, representing the minimum number of tasks that must be scheduled.\n- An integer W, representing the maximum total weight of the scheduled tasks.\n\nYour function should return the maximum total weighted profit that can be achieved by scheduling a subset of tasks S, where the size of S is at least k, the total weight of S is at most W, and there are no overlaps between the scheduled tasks.\n\nExample:\n- T = [(1, 3, 5, 2), (2, 4, 3, 1), (3, 5, 4, 3), (4, 6, 2, 1), (6, 7, 4, 2)]\n- k = 4\n- W = 6\n\n- The maximum total weighted profit that can be achieved by scheduling a subset of tasks is 14, by scheduling the tasks (1, 3, 5, 2), (3, 5, 4, 3), and (6, 7, 4, 2).\n", "startingSolution": "from typing import List, Tuple\r\n\r\n\r\ndef max_profit_with_min_tasks(tasks: List[Tuple[int, int, int]], k: int) -> int:\r\n    \"\"\"\r\n    This function finds the maximum total profit achievable by scheduling a subset of tasks\r\n    with at least k tasks and no overlaps.\r\n\r\n    Args:\r\n        tasks: A list of tuples (start_time, end_time, profit) representing tasks.\r\n        k: An integer representing the minimum number of tasks to schedule.\r\n\r\n    Returns:\r\n        The maximum total profit achievable.\r\n    \"\"\"\r\n\r\n    sorted_tasks = sorted(tasks, key=lambda x: x[1])\r\n\r\n    max_profit = 0\r\n    scheduled_tasks = 0\r\n\r\n    for start, end, profit in sorted_tasks:\r\n        if scheduled_tasks >= k:\r\n            break\r\n\r\n        max_profit += profit\r\n        scheduled_tasks += 1\r\n\r\n    return max_profit", "unitTests": [{"": "[(1, 3, 5), (2, 4, 3), (3, 5, 4), (4, 6, 2), (6, 7, 4)], 3", "expectedOutput": "12"}, {"expectedOutput": "8", "": "[(1, 10, 2), (2, 6, 3), (3, 5, 5), (4, 7, 1)], 2"}, {"expectedOutput": "14", "": "[(1, 3, 5), (2, 4, 3), (3, 5, 4), (4, 6, 2), (6, 7, 4)], 4"}], "solution": "from typing import List, Tuple\r\n\r\n\r\ndef max_profit_with_min_tasks(tasks: List[Tuple[int, int, int]], k: int) -> int:\r\n    \"\"\"\r\n    This function finds the maximum total profit achievable by scheduling a subset of tasks\r\n    with at least k tasks and no overlaps.\r\n\r\n    Args:\r\n        tasks: A list of tuples (start_time, end_time, profit) representing tasks.\r\n        k: An integer representing the minimum number of tasks to schedule.\r\n\r\n    Returns:\r\n        The maximum total profit achievable.\r\n    \"\"\"\r\n\r\n    sorted_tasks = sorted(tasks, key=lambda x: x[1])\r\n\r\n    max_profit = 0\r\n    scheduled_tasks = 0\r\n\r\n    for start, end, profit in sorted_tasks:\r\n        if scheduled_tasks >= k:\r\n            break\r\n\r\n        max_profit += profit\r\n        scheduled_tasks += 1\r\n\r\n    return max_profit\r\n\r\n# Verify the solution\r\ndef test_max_profit_with_min_tasks():\r\n    assert max_profit_with_min_tasks([(1, 3, 5), (2, 4, 3), (3, 5, 4), (4, 6, 2), (6, 7, 4)], 3) == 12\r\n    assert max_profit_with_min_tasks([(1, 2, 3), (2, 3, 4), (3, 4, 5)], 2) == 8\r\n    assert max_profit_with_min_tasks([(1, 3, 5), (2, 4, 3), (3, 5, 4), (4, 6, 2), (6, 7, 4)], 4) == 14\r\n\r\ntest_max_profit_with_min_tasks()\r\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-21", "worker": "c2610e1792c5cf07"}, {"problem": "\nGiven an array of integers `nums` and an integer `k`, your task is to find the maximum possible product of any contiguous subarray of `nums` of length at most `k`.\n\nThe product of an empty subarray is considered to be 1.\n\nThe challenge is that the product of a subarray can become extremely large or extremely small, and you must handle both cases efficiently. Additionally, the subarray with the maximum product may not necessarily be the one with the largest individual elements.\n\nFurthermore, the problem is complicated by the fact that the product of a subarray can overflow the maximum integer value, and you must handle this scenario gracefully.\n\nYou must return the maximum possible product modulo 10^9 + 7.\n\nExample:\n- `maxSubarrayProduct([2, 3, -2, 4, -1, 5, -5, 2], 3) == 240` (the subarray [3, -2, 4] has the maximum product of 24)\n- `maxSubarrayProduct([-2, 0, -1, 0, -5, 1], 2) == 5` (the subarray [1] has the maximum product of 5)\n- `maxSubarrayProduct([1000000000, 1000000000, 1000000000], 2) == 1000000006` (the subarray [1000000000, 1000000000] has the maximum product of 1000000000000000000, which overflows the maximum integer value)\n", "startingSolution": "\ndef maxSubarrayProduct(nums, k):\n    \"\"\"\n    Given an array of integers `nums` and an integer `k`, your task is to find the maximum possible product of any contiguous subarray of `nums` of length at most `k`.\n\n    The product of an empty subarray is considered to be 1.\n\n    The challenge is that the product of a subarray can become extremely large or extremely small, and you must handle both cases efficiently. Additionally, the subarray with the maximum product may not necessarily be the one with the largest individual elements.\n\n    Furthermore, the problem is complicated by the fact that the product of a subarray can overflow the maximum integer value, and you must handle this scenario gracefully.\n\n    You must return the maximum possible product modulo 10^9 + 7.\n\n    Example:\n    - `maxSubarrayProduct([2, 3, -2, 4, -1, 5, -5, 2], 3) == 240` (the subarray [3, -2, 4] has the maximum product of 24)\n    - `maxSubarrayProduct([-2, 0, -1, 0, -5, 1], 2) == 5` (the subarray [1] has the maximum product of 5)\n    - `maxSubarrayProduct([1000000000, 1000000000, 1000000000], 2) == 1000000006` (the subarray [1000000000, 1000000000] has the maximum product of 1000000000000000000, which overflows the maximum integer value)\n    \"\"\"\n    pass\n", "unitTests": [{"nums": "[2345, 0, 34567, -345678]", "k": "3", "expectedOutput": "[2345, 0, 34567, -345678]"}, {"expectedOutput": "932313945", "nums": "[10098776543, 3209843216, 9876543211, 40999998776]", "k": "3"}, {"expectedOutput": "32", "nums": "[32, 0, -1]", "k": "2"}], "solution": "\ndef maxSubarrayProduct(nums, k):\n    \"\"\"\n    Given an array of integers `nums` and an integer `k`, your task is to find the maximum possible product of any contiguous subarray of `nums` of length at most `k`.\n\n    The product of an empty subarray is considered to be 1.\n\n    The challenge is that the product of a subarray can become extremely large or extremely small, and you must handle both cases efficiently. Additionally, the subarray with the maximum product may not necessarily be the one with the largest individual elements.\n\n    Furthermore, the problem is complicated by the fact that the product of a subarray can overflow the maximum integer value, and you must handle this scenario gracefully.\n\n    You must return the maximum possible product modulo 10^9 + 7.\n\n    Example:\n    - `maxSubarrayProduct([2, 3, -2, 4, -1, 5, -5, 2], 3) == 240` (the subarray [3, -2, 4] has the maximum product of 24)\n    - `maxSubarrayProduct([-2, 0, -1, 0, -5, 1], 2) == 5` (the subarray [1] has the maximum product of 5)\n    - `maxSubarrayProduct([1000000000, 1000000000, 1000000000], 2) == 1000000006` (the subarray [1000000000, 1000000000] has the maximum product of 1000000000000000000, which overflows the maximum integer value)\n    \"\"\"\n    MOD = 10**9 + 7\n    n = len(nums)\n    if n < k:\n        return 0\n\n    max_prod = 1\n    for i in range(k):\n        max_prod *= nums[i]\n    max_prod %= MOD\n\n    curr_prod = max_prod\n    for i in range(k, n):\n        curr_prod = (curr_prod // nums[i - k]) * nums[i]\n        curr_prod %= MOD\n        max_prod = max(max_prod, curr_prod)\n\n    return max_prod\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-22", "worker": "df0862d302f4b759"}, {"problem": "\nYou are given a set of n points in a 2D plane, where each point is represented by its (x, y) coordinates. Your task is to find the minimum number of straight line segments that can be used to connect all the points, such that each point is either an endpoint or an internal point of at least one segment.\n\nThe input to your function is a 2D list of integers, where each inner list represents the (x, y) coordinates of a point. The points may be collinear, and the input may contain duplicate points or an empty list.\n\nYour function should return an integer representing the minimum number of line segments required to connect all the points, while ensuring that each point is either an endpoint or an internal point of at least one segment. The segments must be straight lines, and the solution should handle all possible edge cases, such as when the input is empty or when all the points are collinear.\n\nFor example, if the input is:\n[[0, 0], [1, 1], [2, 0], [3, 1], [4, 0]]\nYour function should return 3, as the points can be connected using three line segments: (0, 0) to (1, 1), (1, 1) to (3, 1), and (2, 0) to (4, 0).\n\nHowever, if the input is:\n[[0, 0], [1, 1], [2, 0], [3, 1], [4, 0], [5, 1]]\nYour function should return 4, as the points can be connected using four line segments: (0, 0) to (1, 1), (1, 1) to (3, 1), (2, 0) to (4, 0), and (4, 0) to (5, 1).\n\nThe solution should be efficient and handle large inputs without exceeding time or memory constraints.\n", "startingSolution": "\ndef min_line_segments(points):\n    \"\"\"\n    Given a set of n points in a 2D plane, where each point is represented by its (x, y) coordinates, find the minimum number of straight line segments that can be used to connect all the points, such that each point is either an endpoint or an internal point of at least one segment.\n\n    Args:\n        points (List[List[int]]): A 2D list of integers, where each inner list represents the (x, y) coordinates of a point.\n\n    Returns:\n        int: The minimum number of line segments required to connect all the points.\n    \"\"\"\n    pass\n", "unitTests": [{"points": "[[0, 0], [1, 1], [2, 0], [3, 1], [4, 0]]", "expectedOutput": "3"}, {"expectedOutput": "4", "points": "[[0, 1], [1, 2], [2, 1], [1, 0]]"}, {"expectedOutput": "2", "points": "[[0, 0], [0, 1], [1, 0], [1, 1]]"}], "solution": "import math\n\ndef min_line_segments(points):\n    if not points or len(points) == 1:\n        return 0\n    n = len(points)\n    edges = []\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((distance(points[i], points[j]), i, j))\n    edges.sort()\n    parent = list(range(n))\n    rank = [0] * n\n\n    def find(v):\n        if parent[v] != v:\n            parent[v] = find(parent[v])\n        return parent[v]\n\n    def union(v1, v2):\n        root1 = find(v1)\n        root2 = find(v2)\n        if root1 != root2:\n            if rank[root1] > rank[root2]:\n                parent[root2] = root1\n            elif rank[root1] < rank[root2]:\n                parent[root1] = root2\n            else:\n                parent[root2] = root1\n                rank[root1] += 1\n    mst_edges_count = 0\n    for weight, u, v in edges:\n        if find(u) != find(v):\n            union(u, v)\n            mst_edges_count += 1\n            if mst_edges_count == n - 1: \n                break\n\n    return mst_edges_count\n\n\nif __name__ == \"__main__\":\n    ", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-23", "worker": "86afe36b19d0f78b"}, {"problem": "You are given an undirected graph G = (V, E), where V is the set of vertices and E is the set of edges. Each vertex v in V has a corresponding weight w(v) associated with it. Your task is to find the maximum weight of a Hamiltonian cycle in the graph, where a Hamiltonian cycle is a closed path that visits each vertex exactly once.\n\nThe input to your function will be:\n- An integer n, representing the number of vertices in the graph.\n- A 2D array edges, where edges[i] = [a, b] represents an undirected edge between vertices a and b.\n- An array weights, where weights[i] represents the weight of the vertex with index i.\n\nYour function should return the maximum weight of a Hamiltonian cycle in the graph. If no Hamiltonian cycle exists, return -1.\n\nExample:\n- Input: n = 4, edges = [[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]], weights = [1,2,3,4]\n- Output: 10\n- Explanation: The maximum weight Hamiltonian cycle is 0 -> 1 -> 2 -> 3 -> 0, with a total weight of 1 + 2 + 3 + 4 = 10.", "startingSolution": "from typing import List\r\n\r\n\r\ndef max_weight_hamiltonian_cycle(n: int, edges: List[List[int]], weights: List[int]) -> int:\r\n    \"\"\"\r\n    Find the maximum weight of a Hamiltonian cycle in an undirected graph.\r\n\r\n    Args:\r\n    - n: An integer representing the number of vertices in the graph.\r\n    - edges: A 2D array where edges[i] = [a, b] represents an undirected edge between vertices a and b.\r\n    - weights: An array where weights[i] represents the weight of the vertex with index i.\r\n\r\n    Returns:\r\n    - The maximum weight of a Hamiltonian cycle in the graph. If no Hamiltonian cycle exists, return -1.\r\n    \"\"\"\r\n    graph = [[0] * n for _ in range(n)]\r\n    for edge in edges:\r\n        u, v = edge\r\n        graph[u][v] = 1\r\n        graph[v][u] = 1\r\n\r\n    dp = [[-float('inf')] * n for _ in range(1 << n)]\r\n    dp[1][0] = 0\r\n\r\n    for mask in range(1, 1 << n):\r\n        for u in range(n):\r\n            if not (mask & (1 << u)):\r\n                continue\r\n            for v in range(n):\r\n                if (mask & (1 << v)) or graph[u][v] == 0:\r\n                    continue\r\n                new_mask = mask | (1 << v)\r\n                dp[new_mask][v] = max(\r\n                    dp[new_mask][v], dp[mask][u] + weights[v])\r\n\r\n    max_weight = 0\r\n    final_mask = (1 << n) - 1\r\n    for u in range(n):\r\n        if graph[u][0] == 1 and dp[final_mask][u] + weights[0] > max_weight:\r\n            max_weight = dp[final_mask][u] + weights[0]\r\n\r\n    return max_weight if max_weight > 0 else -1", "unitTests": [{"": "4, [[0, 1], [0, 2], [0, 3], [       1, 2], [1, 3], [2, 3]], [1, 2, 3, 4]", "expectedOutput": "10"}, {"expectedOutput": "6", "": "3, [[0, 1], [1, 2], [2, 0]], [1, 2, 3]"}, {"expectedOutput": "11", "": "2, [[0, 1]], [5, 6]"}], "solution": "\nfrom typing import List\n\ndef max_weight_hamiltonian_cycle(n: int, edges: List[List[int]], weights: List[int]) -> int:\n    \"\"\"\n    Find the maximum weight of a Hamiltonian cycle in an undirected graph.\n\n    Args:\n    - n: An integer representing the number of vertices in the graph.\n    - edges: A 2D array where edges[i] = [a, b] represents an undirected edge between vertices a and b.\n    - weights: An array where weights[i] represents the weight of the vertex with index i.\n\n    Returns:\n    - The maximum weight of a Hamiltonian cycle in the graph. If no Hamiltonian cycle exists, return -1.\n    \"\"\"\n    graph = [[0] * n for _ in range(n)]\n    for edge in edges:\n        u, v = edge\n        graph[u][v] = 1\n        graph[v][u] = 1\n\n    dp = [[-float('inf')] * n for _ in range(1 << n)]\n    dp[1][0] = 0\n\n    for mask in range(1, 1 << n):\n        for u in range(n):\n            if not (mask & (1 << u)):\n                continue\n            for v in range(n):\n                if (mask & (1 << v)) or graph[u][v] == 0:\n                    continue\n                new_mask = mask | (1 << v)\n                dp[new_mask][v] = max(\n                    dp[new_mask][v], dp[mask][u] + weights[v])\n\n    max_weight = 0\n    final_mask = (1 << n) - 1\n    for u in range(n):\n        if graph[u][0] == 1 and dp[final_mask][u] + weights[0] > max_weight:\n            max_weight = dp[final_mask][u] + weights[0]\n\n    return max_weight if max_weight > 0 else -1\n\n>\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-24", "worker": "c2610e1792c5cf07"}, {"problem": "\nYou are given a set of n tasks, where each task is represented by a tuple (start_time, end_time, profit, deadline, penalty). Your task is to find the maximum total profit that can be obtained by scheduling a subset of these tasks, subject to the following constraints:\n\n1. Each task can only be scheduled once, and it must be scheduled within its given start and end times.\n2. No two scheduled tasks can overlap in time, meaning that if task A is scheduled, then no other task B can be scheduled such that A's start or end time falls within B's start and end times.\n3. The total profit is the sum of the profits of all the scheduled tasks, minus the sum of the penalties of all the unscheduled tasks.\n4. Each scheduled task must be completed by its given deadline.\n5. The total number of tasks that can be scheduled must not exceed a given limit `k`.\n\nImplement a function that takes the set of tasks and the limit `k` as input, and returns the maximum total profit that can be obtained by scheduling a non-overlapping subset of the tasks while satisfying the deadline and task limit constraints.\n\nThe function should take the following input:\n- `tasks`: a list of tuples (start_time, end_time, profit, deadline, penalty) representing the tasks.\n- `k`: the maximum number of tasks that can be scheduled.\n\nThe function should return:\n- The maximum total profit that can be obtained by scheduling a non-overlapping subset of the tasks while satisfying the deadline and task limit constraints.\n", "startingSolution": "def max_profit(tasks, k):\r\n    # Sort tasks by deadline\r\n    tasks.sort(key=lambda x: x[3])\r\n    \r\n    # Initialize dp array\r\n    n = len(tasks)\r\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\r\n    \r\n    # Iterate over each task\r\n    for i in range(1, n + 1):\r\n        start_time, end_time, profit, deadline, penalty = tasks[i-1]\r\n        \r\n        # Calculate the penalty if we skip this task\r\n        skipped_penalty = dp[i-1][0] - penalty\r\n        \r\n        # Update dp table for each number of tasks scheduled j\r\n        for j in range(0, k + 1):\r\n            # Option 1: Do not schedule this task\r\n            dp[i][j] = max(dp[i][j], dp[i-1][j] - penalty)\r\n            \r\n            # Option 2: Schedule this task if feasible\r\n            if j > 0 and start_time >= dp[i-1][j-1]:\r\n                dp[i][j] = max(dp[i][j], dp[i-1][j-1] + profit)\r\n    \r\n    # Find the maximum profit from any number of scheduled tasks\r\n    max_profit = 0\r\n    for j in range(k + 1):\r\n        max_profit = max(max_profit, dp[n][j])\r\n    \r\n    return max_profit\r\n\r\n# Example usage:\r\ntasks = [\r\n    (1, 3, 40, 4, 10),\r\n    (2, 5, 20, 2, 5),\r\n    (3, 6, 25, 2, 8),\r\n    (5, 7, 10, 1, 2)\r\n]\r\nk = 2\r\n\r\nprint(max_profit(tasks, k))  # Output: 65\r\n", "unitTests": [{"tasks": "tasks = [         (1, 3, 40, 4, 10),  # (start_time, end_time, profit, deadline, penalty)         (2, 5, 20, 2, 5),         (3, 6, 25, 2, 8),         (5, 7, 10, 1, 2)     ]", "k": "3", "expectedOutput": "95"}, {"expectedOutput": "65", "tasks": "tasks = [         (1, 3, 40, 4, 10),         (2, 5, 20, 2, 5),         (3, 6, 25, 2, 8),         (5, 7, 10, 1, 2)     ]", "k": "2"}, {"expectedOutput": "95", "tasks": "tasks = [         (1, 3, 40, 4, 10),         (2, 5, 20, 2, 5),         (3, 6, 25, 2, 8),         (5, 7, 10, 5, 2)  # Deadline is 5, making it challenging to schedule alongside other tasks     ]     ", "k": "k = 3"}], "solution": "\ndef max_profit(tasks, k):\n    # Sort tasks by deadline\n    tasks.sort(key=lambda x: x[3])\n    \n    # Initialize dp array\n    n = len(tasks)\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    \n    # Iterate over each task\n    for i in range(1, n + 1):\n        start_time, end_time, profit, deadline, penalty = tasks[i-1]\n        \n        # Calculate the penalty if we skip this task\n        skipped_penalty = dp[i-1][0] - penalty\n        \n        # Update dp table for each number of tasks scheduled j\n        for j in range(0, k + 1):\n            # Option 1: Do not schedule this task\n            dp[i][j] = max(dp[i][j], dp[i-1][j] - penalty)\n            \n            # Option 2: Schedule this task if feasible\n            if j > 0 and start_time >= dp[i-1][j-1]:\n                dp[i][j] = max(dp[i][j], dp[i-1][j-1] + profit)\n    \n    # Find the maximum profit from any number of scheduled tasks\n    max_profit = 0\n    for j in range(k + 1):\n        max_profit = max(max_profit, dp[n][j])\n    \n    return max_profit\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-25", "worker": "725396297197498f"}, {"problem": "\"You are given a 2D grid of size m x n, where each cell represents a building. The height of each building is represented by a positive integer. Your task is to find the maximum number of buildings that can be seen from the sky, given that the sky is directly above the grid and the viewing angle is 90 degrees.The rules for determining which buildings can be seen are as follows:\\n- A building can be seen if there are no taller buildings between it and the sky.\\n- Buildings are considered to be in the same row or column if they share the same x or y coordinate, respectively.\\n- For each row and column, you must find the maximum number of visible buildings.The function should take the 2D grid of building heights as input and return the total number of visible buildings.", "startingSolution": "\r\ndef visible_buildings(grid, m, n):\r\n    \"\"\"\r\n    Given a 2D grid of building heights, find the maximum number of buildings that can be seen from the sky.\r\n\r\n    Args:\r\n        grid (List[List[int]]): A 2D grid of building heights.\r\n        m (int): The number of rows in the grid.\r\n        n (int): The number of columns in the grid.\r\n\r\n    Returns:\r\n        int: The total number of visible buildings.\r\n\r\n    \"\"\"\r\ndef count_visible_buildings(grid,m,n):\r\n    # Number of rows and columns\r\n    m = len(grid)\r\n    n = len(grid[0]) if m > 0 else 0\r\n\r\n    # Number of visible buildings\r\n    num_visible_buildings = 0\r\n\r\n    # Visibility row-wise\r\n    for row in grid:\r\n        max_height_count = 0\r\n        for height in row:\r\n            if height > max_height_count:\r\n                num_visible_buildings += 1\r\n                max_height_count = height\r\n\r\n    # Visibility column-wise\r\n    for col in range(n):\r\n        max_height_count = 1\r\n        for row in range(m):\r\n            if grid[row][col] > max_height_count:\r\n                num_visible_buildings += 1\r\n                max_height_count = grid[row][col]\r\n\r\n    return num_visible_buildings\r\n\r\n# Example usage:\r\n", "unitTests": [{"grid": "grid = [     [5, 3, 4, 4, 4, 3, 3],     [3, 2, 4, 3, 3, 2, 2],     [3, 5, 6, 3, 3, 5, 4] ]", "m": "7", "n": "3", "expectedOutput": "17"}, {"expectedOutput": "16", "grid": "grid = [          [3, 2, 4, 3, 3, 2, 2],     [3, 5, 6, 3, 3, 5, 4] ] ", "m": "7", "n": "2"}, {"expectedOutput": "10", "grid": "    [3, 5, 6]", "m": "2", "n": "3"}], "solution": "\ndef visible_buildings(grid, m, n):\n    \"\"\"\n    Given a 2D grid of building heights, find the maximum number of buildings that can be seen from the sky.\n\n    Args:\n        grid (List[List[int]]): A 2D grid of building heights.\n        m (int): The number of rows in the grid.\n        n (int): The number of columns in the grid.\n\n    Returns:\n        int: The total number of visible buildings.\n    \"\"\"\n    def count_visible_buildings(grid, m, n):\n        # Number of rows and columns\n        m = len(grid)\n        n = len(grid[0]) if m > 0 else 0\n\n        # Number of visible buildings\n        num_visible_buildings = 0\n\n        # Visibility row-wise\n        for row in grid:\n            max_height_count = 0\n            for height in row:\n                if height > max_height_count:\n                    num_visible_buildings += 1\n                    max_height_count = height\n\n        # Visibility column-wise\n        for col in range(n):\n            max_height_count = 0\n            for row in range(m):\n                if grid[row][col] > max_height_count:\n                    num_visible_buildings += 1\n                    max_height_count = grid[row][col]\n\n        return num_visible_buildings\n\n    return count_visible_buildings(grid, m, n)\n\n# Example usage:\ngrid1 = [[3, 0, 8, 4], [2, 4, 5, 7], [9, 2, 6, 3], [0, 3, 1, 0]]\nprint(visible_buildings(grid1, 4, 4))  # Output: 17\n\ngrid2 = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]\nprint(visible_buildings(grid2, 4, 4))  # Output: 16\n\ngrid3 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(visible_buildings(grid3, 3, 3))  # Output: 10\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-26", "worker": "6e7b82a374b87eb3"}, {"problem": "\nYou are given an undirected weighted graph represented as an adjacency list, where each node is associated with a list of its neighboring nodes and the corresponding edge weights. Your task is to find the minimum weight set of edges that need to be removed from the graph to ensure that the remaining graph has exactly k connected components, where k is a given integer. Additionally, each connected component in the final graph must have a diameter (the maximum distance between any two nodes in the component) of at most d, where d is another given integer.\n\nThe input to your function is:\n- An integer n representing the number of nodes in the graph\n- A list of n lists, where the i-th list contains tuples (j, w) representing the neighboring node j and the weight w of the edge between nodes i and j\n- An integer k representing the desired number of connected components in the final graph\n- An integer d representing the maximum diameter allowed for each connected component\n\nYour function should return:\n- A list of tuples, where each tuple (u, v) represents an edge that needs to be removed from the graph to ensure the final graph has exactly k connected components, each with a diameter of at most d\n- The total weight of the removed edges\n\nExample:\n- n = 10, graph = [[],[(1,1),(2,2)],[(0,2),(3,4)],[(2,4),(4,5),(6,7)],[(3,5),(5,6)],[(3,6),(4,6),(6,8)],[(3,7),(5,8),(7,8)],[(6,8),(8,9)],[(5,6),(6,7),(7,9)],[(7,9)]],\n  k = 3, d = 3\n  Output: [[(2,3),(5,6)], 11] (Remove the edges with weights 4 and 6 to create 3 connected components, each with a diameter of at most 3)\n\n- n = 20, graph = [[],[(2,3)],[(0,3),(3,2),(4,4)],[(0,2),(1,3),(4,5),(5,6)],[(2,4),(3,5),(6,7),(7,8)],[(3,6),(4,7),(8,9),(9,10)],[(3,7),(4,8),(5,9),(10,11)],[(4,8),(5,10),(6,11),(11,12)],[(4,9),(5,10),(6,11),(12,13)],[(5,10),(6,12),(7,13),(13,14)],[(5,11),(6,12),(7,13),(14,15)],[(6,12),(7,14),(8,15),(15,16)],[(7,13),(8,15),(9,16),(16,17)],[(8,14),(9,16),(10,17),(17,18)],[(9,15),(10,17),(11,18),(18,19)],[(10,16),(11,18),(12,19)],[],[],[],[]], \n  k = 5, d = 4\n  Output: [[(1,2),(4,5),(7,8),(10,11),(13,14)], 20] (Remove the edges with weights 3, 5, 7, 9, and 11 to create 5 connected components, each with a diameter of at most 4)\n", "startingSolution": "from collections import deque, defaultdict\r\n\r\ndef minimum_edges_to_remove(n, graph, k, d):\r\n    def calculate_diameter(start_node, n, graph):\r\n        \"\"\" Calculate the diameter of the connected component starting from start_node. \"\"\"\r\n        visited = [False] * n\r\n        max_distance = 0\r\n        \r\n        def bfs(node):\r\n            queue = deque([(node, 0)])\r\n            visited[node] = True\r\n            max_dist = 0\r\n            \r\n            while queue:\r\n                current, dist = queue.popleft()\r\n                for neighbor, weight in graph[current]:\r\n                    if not visited[neighbor]:\r\n                        visited[neighbor] = True\r\n                        queue.append((neighbor, dist + weight))\r\n                        max_dist = max(max_dist, dist + weight)\r\n            return max_dist\r\n        \r\n        max_distance = bfs(start_node)\r\n        return max_distance\r\n    \r\n    def is_valid_diameter(weight_threshold):\r\n        \"\"\" Check if we can achieve k components with diameter <= d by removing edges >= weight_threshold. \"\"\"\r\n        nonlocal total_removed_weight\r\n        \r\n        # Create a modified graph by removing edges >= weight_threshold\r\n        modified_graph = defaultdict(list)\r\n        for u in range(n):\r\n            for v, weight in graph[u]:\r\n                if weight < weight_threshold:\r\n                    modified_graph[u].append((v, weight))\r\n        \r\n        # Check number of components and their diameters\r\n        visited = [False] * n\r\n        components = 0\r\n        \r\n        for i in range(n):\r\n            if not visited[i]:\r\n                diameter = calculate_diameter(i, n, modified_graph)\r\n                if diameter <= d:\r\n                    components += 1\r\n                    if components > k:\r\n                        return False, float('inf')\r\n        \r\n        if components == k:\r\n            # Calculate total weight of removed edges\r\n            removed_weight = sum(graph[u][v] for u in range(n) for v, weight in graph[u] if weight >= weight_threshold)\r\n            total_removed_weight = removed_weight\r\n            return True, removed_weight\r\n        else:\r\n            return False, float('inf')\r\n    \r\n    # Binary search on edge weights\r\n    left, right = 0, float('inf')\r\n    result_edges = []\r\n    total_removed_weight = 0\r\n    \r\n    while left <= right:\r\n        mid = (left + right) // 2\r\n        is_valid, removed_weight = is_valid_diameter(mid)\r\n        \r\n        if is_valid:\r\n            result_edges = [(u, v) for u in range(n) for v, weight in graph[u] if weight >= mid]\r\n            right = mid - 1\r\n        else:\r\n            left = mid + 1\r\n    \r\n    return result_edges, total_removed_weight\r\n\r\n# Example usage:\r\nn1 = 10\r\ngraph1 = [\r\n    [],\r\n    [(1,1),(2,2)],\r\n    [(0,2),(3,4)],\r\n    [(2,4),(4,5),(6,7)],\r\n    [(3,5),(5,6)],\r\n    [(3,6),(4,6),(6,8)],\r\n    [(3,7),(5,8),(7,8)],\r\n    [(6,8),(8,9)],\r\n    [(5,6),(6,7),(7,9)],\r\n    [(7,9)]\r\n]\r\nk1 = 3\r\nd1 = 3\r\n\r\nedges_to_remove, total_weight = minimum_edges_to_remove(n1, graph1, k1, d1)\r\nprint(f\"Edges to remove: {edges_to_remove}, Total weight: {total_weight}\")\r\n\r\nn2 = 20\r\ngraph2 = [\r\n    [],\r\n    [(2,3)],\r\n    [(0,3),(3,2),(4,4)],\r\n    [(0,2),(1,3),(4,5),(5,6)],\r\n    [(2,4),(3,5),(6,7),(7,8)],\r\n    [(3,6),(4,7),(8,9),(9,10)],\r\n    [(3,7),(4,8),(5,9),(10,11)],\r\n    [(4,8),(5,10),(6,11),(11,12)],\r\n    [(4,9),(5,10),(6,11),(12,13)],\r\n    [(5,10),(6,12),(7,13),(13,14)],\r\n    [(5,11),(6,12),(7,13),(14,15)],\r\n    [(6,12),(7,14),(8,15),(15,16)],\r\n    [(7,13),(8,15),(9,16),(16,17)],\r\n    [(8,14),(9,16),(10,17),(17,18)],\r\n    [(9,15),(10,17),(11,18),(18,19)],\r\n    [(10,16),(11,18),(12,19)],\r\n    [],\r\n    [],\r\n    [],\r\n    []\r\n]\r\nk2 = 5\r\nd2 = 4\r\n\r\nedges_to_remove, total_weight = minimum_edges_to_remove(n2, graph2, k2, d2)\r\nprint(f\"Edges to remove: {edges_to_remove}, Total weight: {total_weight}\")\r\n", "unitTests": [{"n": "6", "graph": "graph = [         [(1, 2), (2, 3)],         [(0, 2), (2, 4)],         [(0, 3), (1, 4), (3, 5)],         [(2, 5)],         [],         [(2, 1)]     ]", "k": "3", "d": "3", "expectedOutput": "4"}, {"expectedOutput": "24", "n": "10", "graph": "[         [(1, 3), (2, 4)],         [(0, 3), (2, 5), (3, 6)],         [(0, 4), (1, 5), (4, 7)],         [(1, 6), (4, 8)],         [(2, 7), (3, 8)],         [(6, 1)],         [(2, 1)],         [(4, 1)],         [(3, 1)],         []     ]", "k": "4", "d": "5"}, {"expectedOutput": "5", "n": "5", "graph": "graph = [         [(1, 1), (2, 2)],         [(0, 1), (2, 3), (3, 4)],         [(0, 2), (1, 3)],         [(1, 4)],         [(3, 4)]     ]", "k": "2", "d": "3"}], "solution": "\nfrom collections import deque, defaultdict\n\ndef minimum_edges_to_remove(n, graph, k, d):\n    def calculate_diameter(start_node, n, graph):\n        \"\"\" Calculate the diameter of the connected component starting from start_node. \"\"\"\n        visited = [False] * n\n        max_distance = 0\n        \n        def bfs(node):\n            queue = deque([(node, 0)])\n            visited[node] = True\n            max_dist = 0\n            \n            while queue:\n                current, dist = queue.popleft()\n                for neighbor, weight in graph[current]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        queue.append((neighbor, dist + weight))\n                        max_dist = max(max_dist, dist + weight)\n            return max_dist\n        \n        max_distance = bfs(start_node)\n        return max_distance\n    \n    def is_valid_diameter(weight_threshold):\n        \"\"\" Check if we can achieve k components with diameter <= d by removing edges >= weight_threshold. \"\"\"\n        nonlocal total_removed_weight\n        \n        # Create a modified graph by removing edges >= weight_threshold\n        modified_graph = defaultdict(list)\n        for u in range(n):\n            for v, weight in graph[u]:\n                if weight < weight_threshold:\n                    modified_graph[u].append((v, weight))\n        \n        # Check number of components and their diameters\n        visited = [False] * n\n        components = 0\n        \n        for i in range(n):\n            if not visited[i]:\n                diameter = calculate_diameter(i, n, modified_graph)\n                if diameter <= d:\n                    components += 1\n                    if components > k:\n                        return False, float('inf')\n        \n        if components == k:\n            # Calculate total weight of removed edges\n            removed_weight = sum(graph[u][v] for u in range(n) for v, weight in graph[u] if weight >= weight_threshold)\n            total_removed_weight = removed_weight\n            return True, removed_weight\n        else:\n            return False, float('inf')\n    \n    # Binary search on edge weights\n    left, right = 0, float('inf')\n    result_edges = []\n    total_removed_weight = 0\n    \n    while left <= right:\n        mid = (left + right) // 2\n        is_valid, removed_weight = is_valid_diameter(mid)\n        \n        if is_valid:\n            result_edges = [(u, v) for u in range(n) for v, weight in graph[u] if weight >= mid]\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result_edges, total_removed_weight\n\n# Example usage:\nn1 = 10\ngraph1 = [\n    [],\n    [(1,1),(2,2)],\n    [(0,2),(3,4)],\n    [(2,4),(4,5),(6,7)],\n    [(3,5),(5,6)],\n    [(3,6),(4,6),(6,8)],\n    [(3,7),(5,8),(7,8)],\n    [(6,8),(8,9)],\n    [(5,6),(6,7),(7,9)],\n    [(7,9)]\n]\nk1 = 3\nd1 = 3\n\nedges_to_remove, total_weight = minimum_edges_to_remove(n1, graph1, k1, d1)\nprint(f\"Edges to remove: {edges_to_remove}, Total weight: {total_weight}\")\n\nn2 = 20\ngraph2 = [\n    [],\n    [(2,3)],\n    [(0,3),(3,2),(4,4)],\n    [(0,2),(1,3),(4,5),(5,6)],\n    [(2,4),(3,5),(6,7),(7,8)],\n    [(3,6),(4,7),(8,9),(9,10)],\n    [(3,7),(4,8),(5,9),(10,11)],\n    [(4,8),(5,10),(6,11),(11,12)],\n    [(4,9),(5,10),(6,11),(12,13)],\n    [(5,10),(6,12),(7,13),(13,14)],\n    [(5,11),(6,12),(7,13),(14,15)],\n    [(6,12),(7,14),(8,15),(15,16)],\n    [(7,13),(8,15),(9,16),(16,17)],\n    [(8,14),(9,16),(10,17),(17,18)],\n    [(9,15),(10,17),(11,18),(18,19)],\n    [(10,16),(11,18),(12,19)],\n    [],\n    [],\n    [],\n    []\n]\nk2 = 5\nd2 = 4\n\nedges_to_remove, total_weight = minimum_edges_to_remove(n2, graph2, k2, d2)\nprint(f\"Edges to remove: {edges_to_remove}, Total weight: {total_weight}\")\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-27", "worker": "725396297197498f"}, {"problem": "\\nYou are given a 2D grid of size m x n, where each cell represents a building. The height of each building is represented by a positive integer. Your task is to implement a function that calculates the maximum amount of water that can be trapped between the buildings, given the following constraints:\\n\\n1. The function takes a 2D array of integers `grid` as input, where `grid[i][j]` represents the height of the building at row `i` and column `j`.\\n2. The function must return the maximum amount of water that can be trapped between the buildings, measured in units of area.\\n3. The water can only be trapped between two buildings, and the amount of water trapped is determined by the height of the shorter building.\\n4. The function must handle cases where the grid is not rectangular, and some rows or columns may have fewer buildings than others.\\n5. The function must have a time complexity of O(m*n) or better, where m and n are the dimensions of the grid.\\n6. The function must use constant extra space, meaning it cannot use any additional data structures that grow with the size of the input.\\n\\nExample:\\n- `grid = [[1,0,2,1,0,1,3,2,6,2],[3,2,3,2,7,5,1,6,4,3],[2,3,3,2,0,4,1,5,6,4]]`\\n- The maximum amount of water that can be trapped is 10 units.\\n\\nYour task is to implement the `maxWaterTrapped` function that satisfies the above requirements.", "startingSolution": "\r\ndef maxWaterTrapped(grid,temperature):\r\n    \"\"\"\r\n    Calculates the maximum amount of water that can be trapped between the buildings in a 2D grid.\r\n    If the temperature is below zero degrees Celsius, water turns into ice, and precipitation falls as snow\r\n\r\n    Args:\r\n        grid (List[List[int]]): A 2D grid of integers representing the height of each building,\r\n        temperature (int): The temperature of the day in degrees Celsius.\r\n\r\n    Returns:\r\n        int: The maximum amount of water that can be trapped between the buildings.\r\n    \"\"\"\r\n    pass\r\n", "unitTests": [{"grid": "[[1,0,2,1,0,1,3,2,6,2],[3,2,3,2,7,5,1,6,4,3],[2,3,3,2,0,4,1,5,6,4]]", "temperature": "2", "expectedOutput": "10"}, {"expectedOutput": "10", "grid": "[[1,0,2,1,0,1,3,2,6,2],[3,2,3,2,7,5,1,6,4,3],[2,3,3,2,0,4,1,5,6,4]]", "temperature": "-2"}, {"expectedOutput": "0", "grid": "[]", "temperature": "0"}], "solution": "\ndef maxWaterTrapped(grid, temperature):\n    \"\"\"\n    Calculates the maximum amount of water that can be trapped between the buildings in a 2D grid.\n    If the temperature is below zero degrees Celsius, water turns into ice, and precipitation falls as snow.\n\n    Args:\n        grid (List[List[int]]): A 2D grid of integers representing the height of each building.\n        temperature (int): The temperature of the day in degrees Celsius.\n\n    Returns:\n        int: The maximum amount of water that can be trapped between the buildings.\n    \"\"\"\n    if temperature < 0:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    water_trapped = 0\n\n    for i in range(m):\n        left_max = 0\n        right_max = 0\n        for j in range(n):\n            left_max = max(left_max, grid[i][j])\n            water_trapped += left_max - grid[i][j]\n\n        for j in range(n - 1, -1, -1):\n            right_max = max(right_max, grid[i][j])\n            water_trapped += min(left_max, right_max) - grid[i][j]\n\n    return water_trapped\n\n# Supplemental code for verifying the solution\n>\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-28", "worker": "057f47b83434cfb3"}, {"problem": "Given a 2D grid of size m x n, where each cell represents a building, your task is to find the maximum number of non-overlapping rectangular areas that can be constructed within the grid, such that each area satisfies the following conditions:\n\n1. The area must be a rectangle, with its sides parallel to the grid axes.\n\n2. The area must contain only cells with a value of 1, representing a building.\n\n3. The area must have a height and width of at least 2 units.\n\n4. The area must not overlap with any other area.\n\nThe input to your function will be a 2D array grid, where grid[i][j] is 1 if there is a building at that cell, and 0 otherwise.\n\nYour function should return the maximum number of non-overlapping rectangular areas that can be constructed within the grid, given the constraints above.\n\nExample:\nInput: grid = [[1,1,1,1],[1,1,1,1],[1,1,1,1]]\nOutput: 2\n\nExplanation: The two non-overlapping rectangular areas are:\n1. (0, 0, 1, 1)\n2. (1, 1, 2, 2)\n\nThis problem is challenging because it requires a complex algorithm to efficiently identify and count the maximum number of non-overlapping rectangular areas, while considering multiple constraints and edge cases. It is more difficult than the \\\"easy\\\" examples provided, and is at least as difficult as the \\\"hard\\\" examples.", "startingSolution": "from typing import List, Tuple\r\n\r\n\r\ndef maxNonOverlappingRectangles(grid: List[List[int]]) -> int:\r\n    \"\"\"\r\n    Finds the maximum number of non-overlapping rectangular areas in a grid,\r\n    where each rectangle must be composed entirely of cells with value 1,\r\n    and each rectangle must have a height and width of at least 2 units.\r\n\r\n    Args:\r\n    grid (List[List[int]]): A 2D grid where each cell contains either 0 or 1.\r\n\r\n    Returns:\r\n    int: The maximum number of non-overlapping rectangles that can be formed.\r\n    \"\"\"\r\n    m, n = len(grid), len(grid[0])\r\n    used = [[False] * n for _ in range(m)]\r\n    count = 0\r\n\r\n    def can_form_rectangle(x: int, y: int, h: int, w: int) -> bool:\r\n        \"\"\"\r\n        Checks if a rectangle of height `h` and width `w` can be formed starting from (x, y),\r\n        and ensures that the rectangle does not overlap with already used cells.\r\n\r\n        Args:\r\n        x (int): Starting row index.\r\n        y (int): Starting column index.\r\n        h (int): Height of the rectangle.\r\n        w (int): Width of the rectangle.\r\n\r\n        Returns:\r\n        bool: True if the rectangle can be formed, False otherwise.\r\n        \"\"\"\r\n        if x + h > m or y + w > n:\r\n            return False \r\n        for i in range(x, x + h):\r\n            for j in range(y, y + w):\r\n                if grid[i][j] == 0 or used[i][j]:\r\n                    return False\r\n        return True\r\n\r\n    def mark_rectangle(x: int, y: int, h: int, w: int) -> None:\r\n        \"\"\"\r\n        Marks the cells of the rectangle starting from (x, y) with height `h` and width `w` as used.\r\n\r\n        Args:\r\n        x (int): Starting row index.\r\n        y (int): Starting column index.\r\n        h (int): Height of the rectangle.\r\n        w (int): Width of the rectangle.\r\n        \"\"\"\r\n        for i in range(x, x + h):\r\n            for j in range(y, y + w):\r\n                used[i][j] = True\r\n\r\n    def find_rectangles() -> List[Tuple[int, int, int, int]]:\r\n        \"\"\"\r\n        Finds all possible rectangles in the grid and ensures that no two rectangles overlap.\r\n\r\n        Returns:\r\n        List[Tuple[int, int, int, int]]: List of tuples where each tuple represents a rectangle with\r\n                                         its top-left corner (x, y), height `h`, and width `w`.\r\n        \"\"\"\r\n        rectangles = []\r\n        for i in range(m):\r\n            for j in range(n):\r\n                if grid[i][j] == 1 and not used[i][j]:\r\n                    for h in range(2, m - i + 1):\r\n                        for w in range(2, n - j + 1):\r\n                            if can_form_rectangle(i, j, h, w):\r\n                                rectangles.append((i, j, h, w))\r\n                                mark_rectangle(i, j, h, w)\r\n                                break\r\n        return rectangles\r\n\r\n    rectangles = find_rectangles()\r\n    count = len(rectangles)\r\n\r\n    return count", "unitTests": [{"": "[[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], 2", "expectedOutput": "2"}, {"expectedOutput": "2", "": "[[1, 1, 0, 0], [1, 1, 0, 1], [0, 0, 1, 1], [0, 1, 1, 1]], 2"}, {"expectedOutput": "0", "": "[[1, 0], [0, 1]], 0"}], "solution": "\r\nfrom typing import List, Tuple\r\n\r\ndef maxNonOverlappingRectangles(grid: List[List[int]]) -> int:\r\n    \"\"\"\r\n    Finds the maximum number of non-overlapping rectangular areas in a grid,\r\n    where each rectangle must be composed entirely of cells with value 1,\r\n    and each rectangle must have a height and width of at least 2 units.\r\n\r\n    Args:\r\n    grid (List[List[int]]): A 2D grid where each cell contains either 0 or 1.\r\n\r\n    Returns:\r\n    int: The maximum number of non-overlapping rectangles that can be formed.\r\n    \"\"\"\r\n    m, n = len(grid), len(grid[0])\r\n    used = [[False] * n for _ in range(m)]\r\n    count = 0\r\n\r\n    def can_form_rectangle(x: int, y: int, h: int, w: int) -> bool:\r\n        \"\"\"\r\n        Checks if a rectangle of height `h` and width `w` can be formed starting from (x, y),\r\n        and ensures that the rectangle does not overlap with already used cells.\r\n\r\n        Args:\r\n        x (int): Starting row index.\r\n        y (int): Starting column index.\r\n        h (int): Height of the rectangle.\r\n        w (int): Width of the rectangle.\r\n\r\n        Returns:\r\n        bool: True if the rectangle can be formed, False otherwise.\r\n        \"\"\"\r\n        if x + h > m or y + w > n:\r\n            return False \r\n        for i in range(x, x + h):\r\n            for j in range(y, y + w):\r\n                if grid[i][j] == 0 or used[i][j]:\r\n                    return False\r\n        return True\r\n\r\n    def mark_rectangle(x: int, y: int, h: int, w: int) -> None:\r\n        \"\"\"\r\n        Marks the cells of the rectangle starting from (x, y) with height `h` and width `w` as used.\r\n\r\n        Args:\r\n        x (int): Starting row index.\r\n        y (int): Starting column index.\r\n        h (int): Height of the rectangle.\r\n        w (int): Width of the rectangle.\r\n        \"\"\"\r\n        for i in range(x, x + h):\r\n            for j in range(y, y + w):\r\n                used[i][j] = True\r\n\r\n    def find_rectangles() -> List[Tuple[int, int, int, int]]:\r\n        \"\"\"\r\n        Finds all possible rectangles in the grid and ensures that no two rectangles overlap.\r\n\r\n        Returns:\r\n        List[Tuple[int, int, int, int]]: List of tuples where each tuple represents a rectangle with\r\n                                         its top-left corner (x, y), height `h`, and width `w`.\r\n        \"\"\"\r\n        rectangles = []\r\n        for i in range(m):\r\n            for j in range(n):\r\n                if grid[i][j] == 1 and not used[i][j]:\r\n                    for h in range(2, m - i + 1):\r\n                        for w in range(2, n - j + 1):\r\n                            if can_form_rectangle(i, j, h, w):\r\n                                rectangles.append((i, j, h, w))\r\n                                mark_rectangle(i, j, h, w)\r\n                                break\r\n        return rectangles\r\n\r\n    rectangles = find_rectangles()\r\n    count = len(rectangles)\r\n\r\n    return count\r\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-29", "worker": "c2610e1792c5cf07"}, {"problem": "You are given a directed graph G = (V, E), where V is the set of vertices and E is the set of directed edges. Each vertex v in V represents a task, and each edge (u, v) in E represents a dependency between tasks u and v, where task u must be completed before task v can be started.\n\nAdditionally, each task v has an associated cost c(v) and a deadline d(v). Your goal is to find the minimum total cost of a subset of tasks that can be completed within their deadlines, such that the tasks in the subset form a valid schedule (i.e., all dependencies are satisfied).\n\nYour function should take the following inputs:\\n- A set of vertices V, representing the tasks\n- A set of directed edges E, representing the dependencies between tasks\n- A cost function c: V -> R, mapping each task to its associated cost\n- A deadline function d: V -> R, mapping each task to its deadline\n\nThe function should return the minimum total cost of a subset of tasks that can be completed within their deadlines, such that the tasks in the subset form a valid schedule. If no such subset exists, the function should return -1.\n\nExample:\n- Input: V = {1, 2, 3, 4, 5}, E = {(1, 2), (2, 3), (3, 4), (4, 5)}, c = {1: 2, 2: 3, 3: 5, 4: 1, 5: 4}, d = {1: 2, 2: 3, 3: 5, 4: 7, 5: 10}\n- Output: 11\n- Explanation: The minimum total cost of a subset of tasks that can be completed within their deadlines is 11, by completing tasks 1, 2, 4, and 5.", "startingSolution": "from typing import List, Tuple\r\n\r\n\r\ndef min_total_cost(V: List[int], E: List[Tuple[int, int]], c: dict, d: dict) -> int:\r\n    \"\"\"\r\n    Calculate the minimum total cost of a subset of tasks that can be completed within their deadlines.\r\n\r\n    Args:\r\n        V (List[int]): List of vertices representing the tasks.\r\n        E (List[Tuple[int, int]]): List of directed edges representing the dependencies between tasks.\r\n        c (dict): Dictionary mapping each task to its associated cost.\r\n        d (dict): Dictionary mapping each task to its deadline.\r\n\r\n    Returns:\r\n        int: Minimum total cost of a valid schedule, or -1 if no such subset exists.\r\n    \"\"\"\r\n    def topological_sort(graph: dict) -> List[int]:\r\n        in_degree = {v: 0 for v in V}\r\n        for u, v in E:\r\n            in_degree[v] += 1\r\n\r\n        queue = [v for v in V if in_degree[v] == 0]\r\n        top_order = []\r\n\r\n        while queue:\r\n            u = queue.pop(0)\r\n            top_order.append(u)\r\n\r\n            for _, v in E:\r\n                in_degree[v] -= 1\r\n                if in_degree[v] == 0:\r\n                    queue.append(v)\r\n\r\n        return top_order\r\n\r\n    top_order = topological_sort({v: [] for v in V})\r\n\r\n    cost = {v: c[v] for v in V}\r\n    time = {v: 0 for v in V}\r\n\r\n    for v in top_order:\r\n        time[v] = max(time[v], d[v])\r\n        for u, v in E:\r\n            time[v] = max(time[v], time[u])\r\n\r\n    total_cost = sum(cost[v] for v in V if time[v] <= d[v])\r\n\r\n    return total_cost if total_cost > 0 else -1", "unitTests": [{"": "{1, 2, 3, 4}, {(1, 2), (1, 3), (2, 4), (3, 4)}, {      1: 1, 2: 2, 3: 3, 4: 4}, {1: 2, 2: 3, 3: 5, 4: 6}, 10", "expectedOutput": "10"}, {"expectedOutput": "15", "": "{1, 2, 3, 4, 5}, {(1, 2), (1, 3), (2, 4), (3, 4), (4, 5)}, {1: 1, 2: 2,      3: 3, 4: 4, 5: 5}, {1: 2, 2: 4, 3: 5, 4: 7, 5: 9}, 15"}, {"expectedOutput": "-1", "": "{1, 2, 3, 4}, {(1, 2), (2, 3), (3, 4), (4, 1)}, {      1: 2, 2: 3, 3: 2, 4: 3}, {1: 3, 2: 5, 3: 5, 4: 6}"}], "solution": "from typing import List, Tuple\n\n\ndef min_total_cost(V: List[int], E: List[Tuple[int, int]], c: dict, d: dict) -> int:\n    \"\"\"\n    Calculate the minimum total cost of a subset of tasks that can be completed within their deadlines.\n\n    Args:\n        V (List[int]): List of vertices representing the tasks.\n        E (List[Tuple[int, int]]): List of directed edges representing the dependencies between tasks.\n        c (dict): Dictionary mapping each task to its associated cost.\n        d (dict): Dictionary mapping each task to its deadline.\n\n    Returns:\n        int: Minimum total cost of a valid schedule, or -1 if no such subset exists.\n    \"\"\"\n    def topological_sort(graph: dict) -> List[int]:\n        in_degree = {v: 0 for v in V}\n        for u, v in E:\n            in_degree[v] += 1\n\n        queue = [v for v in V if in_degree[v] == 0]\n        top_order = []\n\n        while queue:\n            u = queue.pop(0)\n            top_order.append(u)\n\n            for _, v in E:\n                in_degree[v] -= 1\n                if in_degree[v] == 0:\n                    queue.append(v)\n\n        return top_order\n\n    top_order = topological_sort({v: [] for v in V})\n\n    cost = {v: c[v] for v in V}\n    time = {v: 0 for v in V}\n\n    for v in top_order:\n        time[v] = max(time[v], d[v])\n        for u, v in E:\n            time[v] = max(time[v], time[u])\n\n    total_cost = sum(cost[v] for v in V if time[v] <= d[v])\n\n    return total_cost if total_cost > 0 else -1", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-30", "worker": "c2610e1792c5cf07"}, {"problem": "nYou are given a 2D array `grid` representing a rectangular grid, where each cell in the grid can be either `0` (empty) or `1` (occupied). Your task is to find the maximum number of non-overlapping rectangles that can be formed within the grid, where each rectangle must satisfy the following conditions:\\n\\n1. All cells within the rectangle must be occupied (i.e., have a value of `1`).\\n2. The rectangle must have a height and width of at least 2 (i.e., it cannot be a single row or column).\\n3. The rectangles must not overlap with each other, meaning that no two rectangles can share a common cell.\\n\\nYour function should take the `grid` as input and return the maximum number of non-overlapping rectangles that can be formed within the grid.\\n\\nExample:\\n- `maxNonOverlappingRectangles([[1, 1, 1, 0], [1, 1, 1, 0], [1, 1, 1, 1], [0, 0, 1, 1]]) = 3`\\n  - The three rectangles are: `[[1, 1, 1, 0], [1, 1, 1, 0]]`, `[[1, 1, 1, 1]]`, and `[[0, 0, 1, 1]]`.\\n- `maxNonOverlappingRectangles([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) = 1`\\n  - The grid is fully occupied, so the maximum number of non-overlapping rectangles is 1.\\n\"", "startingSolution": "\ndef max_non_overlapping_rectangles(grid):\n    \"\"\"\n    Find the maximum number of non-overlapping rectangles in a 2D grid.\n\n    Args:\n        grid (list[list[int]]): A 2D grid of 0s and 1s, where 1 represents an occupied cell.\n\n    Returns:\n        int: The maximum number of non-overlapping rectangles that can be formed within the grid.\n    \"\"\"\n    pass\n", "unitTests": [{"expectedOutput": "1", "grid": "[[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1],  [1, 1, 1, 0]]"}, {"expectedOutput": "3", "grid": " [     [1, 1, 0, 1, 1],     [1, 1, 0, 1, 1],     [1, 0, 1, 1, 0],     [1, 1, 1, 1, 0] ]"}, {"expectedOutput": "2", "grid": "[     [1, 1, 0, 1, 1, 0],     [1, 1, 0, 1, 1, 1],     [1, 1, 0, 1, 0, 1],     [1, 1, 1, 1, 0, 1] ]"}], "solution": "\ndef max_non_overlapping_rectangles(grid):\n    \"\"\"\n    Find the maximum number of non-overlapping rectangles in a 2D grid.\n\n    Args:\n        grid (list[list[int]]): A 2D grid of 0s and 1s, where 1 represents an occupied cell.\n\n    Returns:\n        int: The maximum number of non-overlapping rectangles that can be formed within the grid.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    max_rectangles = 0\n\n    def is_valid_rectangle(i, j, height, width):\n        for x in range(i, i + height):\n            for y in range(j, j + width):\n                if grid[x][y] != 1:\n                    return False\n        return True\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                max_width = 1\n                while j + max_width < n and grid[i][j + max_width] == 1:\n                    max_width += 1\n                max_height = 1\n                while i + max_height < m and grid[i + max_height][j] == 1:\n                    max_height += 1\n                for height in range(2, max_height + 1):\n                    for width in range(2, max_width + 1):\n                        if is_valid_rectangle(i, j, height, width):\n                            dp[i][j] = max(dp[i][j], height * width)\n                            max_rectangles = max(max_rectangles, dp[i][j])\n\n    return max_rectangles\n\n>\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-31", "worker": "df0862d302f4b759"}, {"problem": "\nYou are given an array of integers nums and an integer target. Your task is to find the maximum sum of a non-empty, contiguous, and sorted (in non-decreasing order) subarray of nums such that the sum is strictly less than the target.\n\nThe function should take the following input:\n- nums: an array of integers, which can contain both positive and negative values\n- target: an integer representing the target sum\n\nThe function should return the maximum sum of a contiguous, non-empty, and sorted (in non-decreasing order) subarray of nums that is strictly less than the target. If no such subarray exists, the function should return 0. If the array contains only negative integers, the function should also return 0, as there is no subarray that satisfies the conditions.\n\nThe function must also satisfy the following additional constraints:\n- The subarray must be contiguous, meaning that the elements must be adjacent in the original array.\n- The subarray must contain at least one element.\n- The subarray must not contain any negative integers and must be sorted in non-decreasing order.\n- The function must return the maximum sum that satisfies all the above conditions, or 0 if no such subarray exists.\n\nExample:\n- maxSubarraySumLessTarget([2, 3, 4, 1, 2, 4], 9) == 8 (the subarray [2, 3, 4] has a sum of 9, which is the maximum sum less than 9)\n- maxSubarraySumLessTarget([-1, -2, -3], -5) == 0 (no subarray with a sum less than -5 exists, and the array contains only negative integers)\n- maxSubarraySumLessTarget([1, 2, 3, 4, 5], 12) == 10 (the subarray [1, 2, 3, 4] has a sum of 10, which is the maximum sum less than 12)\n", "startingSolution": "from typing import List\r\n\r\n\r\ndef maxSubarraySumLessTarget(nums: List[int], target: int) -> int:\r\n    \"\"\"\r\n    Finds the maximum sum of a non-empty subarray of nums such that the sum is less than the target,\r\n    and the subarray contains only non-negative integers.\r\n\r\n    Parameters:\r\n    nums (List[int]): The list of integers, which can contain both positive and negative values.\r\n    target (int): The target sum.\r\n\r\n    Returns:\r\n    int: The maximum subarray sum that is less than the target and contains only non-negative integers.\r\n         If no such subarray exists, returns 0.\r\n    \"\"\"\r\n    start = 0\r\n    current_sum = 0\r\n    max_sum = 0\r\n\r\n    for end in range(len(nums)):\r\n        if nums[end] < 0:\r\n            start = end + 1\r\n            current_sum = 0\r\n            continue\r\n\r\n        current_sum += nums[end]\r\n\r\n        while current_sum >= target and start <= end:\r\n            current_sum -= nums[start]\r\n            start += 1\r\n\r\n        if current_sum < target:\r\n            max_sum = max(max_sum, current_sum)\r\n\r\n    return max_sum", "unitTests": [{"": "[2, 3, 4, 1, 2, 4], 9", "expectedOutput": "8"}, {"expectedOutput": "0", "": "[-1, -2, -3], -5"}, {"expectedOutput": "10", "": "[1, 2, 3, 4, 5], 12"}], "solution": "from typing import List\n\n\ndef maxSubarraySumLessTarget(nums: List[int], target: int) -> int:\n    \"\"\"\n    Finds the maximum sum of a non-empty subarray of nums such that the sum is less than the target,\n    and the subarray contains only non-negative integers.\n\n    Parameters:\n    nums (List[int]): The list of integers, which can contain both positive and negative values.\n    target (int): The target sum.\n\n    Returns:\n    int: The maximum subarray sum that is less than the target and contains only non-negative integers.\n         If no such subarray exists, returns 0.\n    \"\"\"\n    start = 0\n    current_sum = 0\n    max_sum = 0\n\n    for end in range(len(nums)):\n        if nums[end] < 0:\n            start = end + 1\n            current_sum = 0\n            continue\n\n        current_sum += nums[end]\n\n        while current_sum >= target and start <= end:\n            current_sum -= nums[start]\n            start += 1\n\n        if current_sum < target:\n            max_sum = max(max_sum, current_sum)\n\n    return max_sum", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-32", "worker": "c2610e1792c5cf07"}, {"problem": "\\nYou are given a set of n non-overlapping intervals, where each interval is represented as a tuple (start, end). Your task is to find the minimum number of \\\"points\\\" that must be placed on the number line such that each interval contains at least one point.\\n\\nThe input to your function will be:\\n- A 2D array `intervals` representing the set of intervals, where `intervals[i] = [start_i, end_i]` means that the i-th interval starts at `start_i` and ends at `end_i`.\\n- An integer `n` representing the number of intervals.\\n\\nYour function should return an integer representing the minimum number of points that must be placed on the number line such that each interval contains at least one point.\\n\\nFor example, if the input is `intervals = [[1,4],[2,3],[3,4],[4,4]]` and `n = 4`, the output should be 2, as two points (e.g., 3 and 4) are sufficient to cover all the intervals.\\n", "startingSolution": "def min_spy_cats(houses, m, day, black_cat, spotted_cat, one_eyed_cat):\n    \"\"\"\n    Finds the minimum number of spy cats required to monitor the houses considering special vigilance requirements.\n    \n    You have a set of non-overlapping intervals representing the addresses of houses that need to be monitored every morning because milk is delivered, and there's a chance that cats might get some milk. You need to optimize the number of spy cats, as homeowners do not appreciate seeing a large group of cats.\n\n    A black cat is demanding and chubby, so it needs twice as much milk. The white cat with black spots thinks it resembles a cow and believes it should be given milk just for that reason, although it still works as required. The white kitty has one eye due to illness, but it does not affect its ability to watch houses.\n\n    Additionally, every third house requires a special type of cat for extra vigilance. The special vigilance requirement changes every day based on a pattern: one day it needs a black cat, the next day a spotted cat, and the day after that a one-eyed cat, repeating in this cycle.\n\n    You need to find the minimum number of spy cats required to ensure that each house is monitored by at least one cat, taking into account the special vigilance requirements.\n\n    Args:\n        houses (list[list[int]]): A 2D array of intervals, where houses[i] = [start_i, end_i] represents the i-th house's address range.\n        m (int): The number of houses.\n        day (int): The current day number, starting from 1.\n        black_cat (bool): Whether you have a black cat.\n        spotted_cat (bool): Whether you have a white cat with black spots.\n        one_eyed_cat (bool): Whether you have a one-eyed white kitty.\n    \n    Returns:\n        int: The minimum number of spy cats required to ensure each house is monitored, taking into account special vigilance requirements.\n    \"\"\"\n    pass\n\n\n    \n\n\n    \n", "unitTests": [{"houses": "[[1, 3], [4, 6], [7, 9]] m = 3", "m": "3", "day": "1", "black_cat": "True", "spotted_cat": "False", "one_eyed_cat": "True", "expectedOutput": "3"}, {"expectedOutput": "1", "houses": "[[1, 5]]", "m": "1", "day": "2", "black_cat": "False", "spotted_cat": "true", "one_eyed_cat": "False"}, {"expectedOutput": "2", "houses": "[[1, 4], [2, 6], [5, 8]]", "m": "3", "day": "3", "black_cat": "True", "spotted_cat": "False", "one_eyed_cat": "True"}, {"expectedOutput": "2", "houses": "[[1, 100], [101, 2000]]", "m": "2", "day": "2", "black_cat": "False", "spotted_cat": "False", "one_eyed_cat": "False"}], "solution": "\ndef min_spy_cats(houses, m, day, black_cat, spotted_cat, one_eyed_cat):\n    # Initialize the count of required spy cats\n    spy_cats = 0\n\n    # Iterate through the houses\n    for house in houses:\n        # Check if the house requires a special cat\n        special_cat = (day - 1) % 3\n        if special_cat == 0 and black_cat:\n            spy_cats += 1\n        elif special_cat == 1 and spotted_cat:\n            spy_cats += 1\n        elif special_cat == 2 and one_eyed_cat:\n            spy_cats += 1\n        else:\n            # If no special cat is required, use a regular cat\n            spy_cats += 1\n\n    return spy_cats\n\n# Supplemental code for verifying the solution\ntest_cases = [\n    ([[[1, 4], [2, 4], [3, 6], [4, 4]], 4, 1, True, False, False], 3),\n    ([[[1, 10], [10, 20], [10, 30], [20, 30]], 4, 2, False, True, False], 1),\n    ([[[1, 5], [10, 20], [30, 40], [50, 60]], 4, 3, False, False, True], 2),\n    ([[[1, 5], [10, 20], [30, 40], [50, 60]], 4, 1, True, True, True], 2)\n]\n\nfor test_case, expected_output in test_cases:\n    houses, m, day, black_cat, spotted_cat, one_eyed_cat = test_case\n    output = min_spy_cats(houses, m, day, black_cat, spotted_cat, one_eyed_cat)\n    assert output == expected_output, f\"Test case failed: {test_case} => {output}, expected {expected_output}\"\n\nprint(\"All test cases passed!\")\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-33", "worker": "057f47b83434cfb3"}, {"problem": "\nYou are given a 2D grid of integers, where each cell represents the height of a building. Your task is to find the maximum area of a rectangle that can be formed within the grid, where the height of the rectangle is bounded by the minimum height of the buildings within the rectangle, and the width of the rectangle is bounded by the number of consecutive buildings with heights greater than or equal to the minimum height.\n\nThe input to your function will be a 2D array of integers, where each inner array represents a row of the grid, and the output should be an integer representing the maximum area of the rectangle that can be formed.\n\nExample:\nInput: [[5,4,6,6,2,3],[4,4,6,6,3,3],[3,3,3,3,8,4],[7,3,3,3,2,3],[6,5,3,3,3,5]]\nOutput: 24\nExplanation: The maximum area rectangle has a height of 3 and a width of 8, resulting in an area of 24.\n", "startingSolution": "def maximumRectangleArea(matrix):\r\n    if not matrix:\r\n        return 0\r\n\r\n    n = len(matrix)\r\n    m = len(matrix[0])\r\n    max_area = 0\r\n\r\n    # Function to find the minimum and maximum hieght in the buildings \r\n    def find_min_max(r1, c1, r2, c2):\r\n        min_val = float('inf')\r\n        max_val = float('-inf')\r\n        for x in range(r1, r2 + 1):\r\n            for y in range(c1, c2 + 1):\r\n                min_val = min(min_val, matrix[x][y])\r\n                max_val = max(max_val, matrix[x][y])\r\n        return min_val, max_val\r\n\r\n    for r1 in range(n):\r\n        for c1 in range(m):\r\n          \r\n            for r2 in range(r1, n):\r\n                for c2 in range(c1, m):\r\n                    # Check if the rectangle covers at least 6 buildings to get the rectangle \r\n                    if (r2 - r1 + 1) * (c2 - c1 + 1) >= 6:\r\n                        # Find minimum and maximum in the current rectangle (min & Max height)\r\n                        min_val, max_val = find_min_max(r1, c1, r2, c2)\r\n                        # Calculate the area \r\n                        area = min_val * max_val\r\n                        # Update maximum area\r\n                        max_area = max(max_area, area)\r\n\r\n    return max_area\r\n", "unitTests": [{"matrix": "[     [5, 4, 6, 6, 2, 3],     [4, 4, 6, 6, 3, 3],     [3, 3, 5, 5, 8, 4],     [7, 3, 3, 3, 2, 3],     [6, 5, 3, 3, 3, 5] ]", "expectedOutput": "30"}, {"expectedOutput": "36", "matrix": " [     [5, 4, 6, 6, 2, 3],     [4, 4, 6, 6, 3, 3],     [3, 3, 5, 5, 8, 9],     [7, 3, 3, 4, 5, 8],     [6, 5, 3, 3, 3, 5] ]"}, {"expectedOutput": "63", "matrix": "[     [5, 4, 6, 6, 2, 3],     [4, 4, 6, 6, 3, 3],     [3, 3, 5, 5, 8, 9],     [7, 7, 7, 4, 5, 8],     [7, 7, 9, 3, 3, 5] ]"}], "solution": "\ndef maximumRectangleArea(matrix):\n    if not matrix:\n        return 0\n\n    n = len(matrix)\n    m = len(matrix[0])\n    max_area = 0\n\n    def find_min_max(r1, c1, r2, c2):\n        min_val = float('inf')\n        max_val = float('-inf')\n        for x in range(r1, r2 + 1):\n            for y in range(c1, c2 + 1):\n                min_val = min(min_val, matrix[x][y])\n                max_val = max(max_val, matrix[x][y])\n        return min_val, max_val\n\n    for r1 in range(n):\n        for c1 in range(m):\n            for r2 in range(r1, n):\n                for c2 in range(c1, m):\n                    if (r2 - r1 + 1) * (c2 - c1 + 1) >= 6:\n                        min_val, max_val = find_min_max(r1, c1, r2, c2)\n                        area = min_val * max_val\n                        max_area = max(max_area, area)\n\n    return max_area\n\n# Unit tests\ndef test_maximum_rectangle_area():\n    assert maximumRectangleArea([[5,4,6,6,2,3],[4,4,6,6,3,3],[3,3,3,3,8,4],[7,3,3,3,2,3],[6,5,3,3,3,5]]) == 24\n    assert maximumRectangleArea([[1,2,3],[4,5,6],[7,8,9]]) == 30\n    assert maximumRectangleArea([[1,2,3,4],[5,6,7,8],[9,10,11,12]]) == 36\n    assert maximumRectangleArea([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]) == 63\n\ntest_maximum_rectangle_area()\nprint(\"All tests passed!\")\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-34", "worker": "df0862d302f4b759"}, {"problem": "You are given a directed graph represented as an adjacency list, where each node in the graph is labeled with a unique integer. Your task is to find the minimum number of nodes that need to be removed from the graph such that the remaining graph is a directed acyclic graph (DAG).\n\nThe input to your function is a list of tuples, where each tuple represents an edge in the graph. The first element of the tuple is the source node, and the second element is the destination node. The function should return the minimum number of nodes that need to be removed to convert the graph into a DAG.\n\nExample:\nInput: [(0, 1), (0, 2), (1, 2), (2, 0), (2, 3), (3, 3)]\nOutput: 1\n\nExplanation:\nThe minimum number of nodes that need to be removed to convert the graph into a DAG is 1. By removing node 2, the remaining graph becomes a DAG.", "startingSolution": "def min_nodes_to_remove_for_dag(graph: list[tuple[int, int]]) -> int:\r\n    \"\"\"\r\n    Given a directed graph represented as a list of tuples, where each tuple represents an edge in the graph, find the minimum number of nodes that need to be removed from the graph to convert it into a directed acyclic graph (DAG).\r\n\r\n    Args:\r\n        graph (List[Tuple[int, int]]): A list of tuples, where each tuple represents an edge in the graph. The first element of the tuple is the source node, and the second element is the destination node.\r\n\r\n    Returns:\r\n        int: The minimum number of nodes that need to be removed from the graph to convert it into a DAG.\r\n    \"\"\"\r\n    pass ", "unitTests": [{"": "[(0, 1), (0, 2), (1, 2), (2, 0), (2, 3), (3, 3)]", "expectedOutput": "2"}, {"expectedOutput": "1", "": "=[(0, 1), (0, 2), (1, 3), (1, 4), (2, 5), (2, 6), (5, 4),(4, 2)]"}, {"expectedOutput": "0", "": "[(0, 1), (0, 2), (1, 3), (1, 4), (2, 5), (2, 6), (5, 4)]"}, {"expectedOutput": "1", "": "[(0, 1), (1, 5), (5, 0), (2, 0), (5, 2), (3, 1), (5, 3), (4, 2), (5, 4)]"}, {"expectedOutput": "1", "": "[(0, 1), (1, 2), (2, 0)]"}], "solution": "from collections import deque\r\n\r\n\r\ndef is_cyclic(adj: dict[int, list[int]]) -> bool:\r\n    in_degree: dict[int, int] = {}\r\n    q: deque[int] = deque()\r\n    visited = 0\r\n\r\n    for u in adj:\r\n        for v in adj[u]:\r\n            if v in in_degree:\r\n                in_degree[v] += 1\r\n            else:\r\n                in_degree[v] = 1\r\n\r\n    for u in adj:\r\n        if u not in in_degree or in_degree[u] == 0:\r\n            q.append(u)\r\n\r\n    while q:\r\n        u = q.popleft()\r\n        visited += 1\r\n\r\n        if u in adj:\r\n            for v in adj[u]:\r\n                in_degree[v] -= 1\r\n\r\n                if in_degree[v] == 0:\r\n                    q.append(v)\r\n\r\n    return visited != len(adj)\r\n\r\n\r\ndef _build_adj_list(graph: list[tuple[int, int]],\r\n                    selected_nodes: set[int]) -> dict[int, list[int]]:\r\n    adj: dict[int, list[int]] = {node: [] for node in selected_nodes}\r\n\r\n    for edge in graph:\r\n        if edge[0] in selected_nodes and edge[1] in selected_nodes:\r\n            adj[edge[0]].append(edge[1])\r\n\r\n    return adj\r\n\r\n\r\ndef validate(graph: list[tuple[int, int]], acc: set[int], to_remove_count: int, nodes_list: list[int], idx: int):\r\n    if idx == len(nodes_list):\r\n        if len(acc) + to_remove_count == len(nodes_list):\r\n            adj = _build_adj_list(graph, acc)\r\n\r\n            return not is_cyclic(adj)\r\n        else:\r\n            return False\r\n\r\n    result1 = validate(graph, acc, to_remove_count, nodes_list, idx + 1)\r\n    acc.add(nodes_list[idx])\r\n    result2 = validate(graph, acc, to_remove_count, nodes_list, idx + 1)\r\n    acc.remove(nodes_list[idx])\r\n\r\n    return result1 or result2\r\n\r\ndef min_nodes_to_remove_for_dag(graph: list[tuple[int, int]]) -> int:\r\n    \"\"\"\r\n    Given a directed graph represented as a list of tuples, where each tuple represents an edge in the graph, find the minimum number of nodes that need to be removed from the graph to convert it into a directed acyclic graph (DAG).\r\n\r\n    Args:\r\n        graph (List[Tuple[int, int]]): A list of tuples, where each tuple represents an edge in the graph. The first element of the tuple is the source node, and the second element is the destination node.\r\n\r\n    Returns:\r\n        int: The minimum number of nodes that need to be removed from the graph to convert it into a DAG.\r\n    \"\"\"\r\n    nodes_set: set[int] = set()\r\n\r\n    for edge in graph:\r\n        nodes_set.add(edge[0])\r\n        nodes_set.add(edge[1])\r\n\r\n    nodes_list = list(nodes_set)\r\n\r\n    left = 0\r\n    right = len(nodes_list)\r\n\r\n    while left < right:\r\n        mid = left + (right - left) // 2\r\n        acc: set[int] = set()\r\n        is_ok = validate(graph, acc, mid, nodes_list, 0)\r\n\r\n        if is_ok:\r\n            right = mid\r\n        else:\r\n            left = mid + 1\r\n    \r\n\r\n    return right", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-35", "worker": "94607a49db8dc666"}, {"problem": "You are given a directed, weighted hypergraph G = (V, E) with n vertices and m hyperedges, where each vertex represents a city and each hyperedge represents a set of cities that can be visited together.\n\nEach hyperedge has three weights associated with it: a travel time, a toll cost, and a carbon emission value. Additionally, each city has a maximum number of times it can be visited, represented by a limit value.\n\nYour task is to find the minimum total carbon emission required to visit all cities in the graph, starting and ending at the same city (i.e., a Hamiltonian cycle), while satisfying the following constraints:\n\n1. The total travel time of the Hamiltonian cycle must not exceed a given time limit T.\n2. The total toll cost of the Hamiltonian cycle must not exceed a given budget B.\n3. The number of times each city is visited in the Hamiltonian cycle must not exceed its limit value.\n4. The Hamiltonian cycle must visit each city at least once.\n5. The Hamiltonian cycle must visit each hyperedge at least once, meaning that all sets of cities in the hyperedges must be visited together at least once.\n6. The total number of hyperedges in the Hamiltonian cycle must be exactly m (every hyperedge must be used exactly once).\n7. Each city must be revisited exactly its limit value number of times during the cycle, adding additional complexity to the route planning.\n\nFormally, your function should take the following input:\n- n: the number of vertices (cities) in the graph\n- m: the number of hyperedges in the graph\n- edges: a 4D array of size m, where each element [cities, [t, c, e]] represents a hyperedge connecting the set of cities \"cities\", with a total travel time t, toll cost c, and carbon emission e\n- limits: a 1D array of size n, where limits[i] represents the maximum number of times city i can be visited\n- T: the maximum allowed total travel time for the Hamiltonian cycle\n- B: the maximum allowed total toll cost for the Hamiltonian cycle\n\nYour function should return the minimum total carbon emission required to visit all cities in the graph, starting and ending at the same city, while satisfying the given constraints. If no such Hamiltonian cycle exists, return -1.\n\nExample:\n- Input: n = 4, m = 5, edges = [[[0, 1], [10, 5, 2]], [[1, 2], [15, 10, 3]], [[2, 3], [10, 5, 1]], [[0, 3], [5, 2, 1]], [[0, 1, 2], [20, 15, 4]]], limits = [2, 2, 2, 2], T = 55, B = 30\n- Output: 8\n- Explanation: The minimum total carbon emission Hamiltonian cycle is 0 -> 1 -> 2 -> 3 -> 0, with a total travel time of 55, a total toll cost of 22, and a total carbon emission of 8.\n", "startingSolution": "\ndef min_carbon_emission_hamiltonian_cycle(n, m, edges, limits, T, B):\n    \"\"\"\n    Given a directed, weighted hypergraph G = (V, E) with n vertices and m hyperedges, where each vertex represents a city and each hyperedge represents a set of cities that can be visited together, find the minimum total carbon emission required to visit all cities in the graph, starting and ending at the same city (i.e., a Hamiltonian cycle), while satisfying the following constraints:\n\n    1. The total travel time of the Hamiltonian cycle must not exceed a given time limit T.\n    2. The total toll cost of the Hamiltonian cycle must not exceed a given budget B.\n    3. The number of times each city is visited in the Hamiltonian cycle must not exceed its limit value.\n    4. The Hamiltonian cycle must visit each city at least once.\n    5. The Hamiltonian cycle must visit each hyperedge at least once, meaning that all sets of cities in the hyperedges must be visited together at least once.\n    6. The total number of hyperedges in the Hamiltonian cycle must be exactly m (every hyperedge must be used exactly once).\n    7. Each city must be revisited exactly its limit value number of times during the cycle, adding additional complexity to the route planning.\n\n    Args:\n        n (int): The number of vertices (cities) in the graph.\n        m (int): The number of hyperedges in the graph.\n        edges (list): A 4D array of size m, where each element [cities, [t, c, e]] represents a hyperedge connecting the set of cities \"cities\", with a total travel time t, toll cost c, and carbon emission e.\n        limits (list): A 1D array of size n, where limits[i] represents the maximum number of times city i can be visited.\n        T (int): The maximum allowed total travel time for the Hamiltonian cycle.\n        B (int): The maximum allowed total toll cost for the Hamiltonian cycle.\n\n    Returns:\n        int: The minimum total carbon emission required to visit all cities in the graph, starting and ending at the same city, while satisfying the given constraints. If no such Hamiltonian cycle exists, return -1.\n    \"\"\"\n    pass\n", "unitTests": [{"n": "n = 4", "m": "m = 5", "edges": "edges = [[[0, 1], [10, 5, 2]], [[1, 2], [15, 10, 3]], [[2, 3], [10, 5, 1]], [[0, 3], [5, 2, 1]], [[0, 1, 2], [20, 15, 4]]]", "limits": "limits = [2, 2, 2, 2]", "T": "T = 55", "B": "B = 30", "expectedOutput": "8"}, {"expectedOutput": "-1", "n": "n = 3", "m": "m = 3", "edges": "edges = [[[0, 1], [10, 5, 2]], [[1, 2], [15, 10, 3]], [[0, 2], [10, 5, 1]]]", "limits": "limits = [1, 1, 1]", "T": "T = 40", "B": "B = 20"}, {"expectedOutput": "10", "n": "n = 4", "m": "m = 4", "edges": "edges = [[[0, 1], [5, 2, 1]], [[1, 2], [10, 5, 2]], [[2, 3], [10, 5, 3]], [[3, 0], [10, 5, 4]]]", "limits": "limits = [2, 2, 2, 2]", "T": "T = 45", "B": "B = 25"}], "solution": "\nfrom collections import defaultdict\nfrom typing import List\n\ndef min_carbon_emission_hamiltonian_cycle(n: int, m: int, edges: List[List[List[int]]], limits: List[int], T: int, B: int) -> int:\n    \"\"\"\n    Given a directed, weighted hypergraph G = (V, E) with n vertices and m hyperedges, where each vertex represents a city and each hyperedge represents a set of cities that can be visited together, find the minimum total carbon emission required to visit all cities in the graph, starting and ending at the same city (i.e., a Hamiltonian cycle), while satisfying the following constraints:\n\n    1. The total travel time of the Hamiltonian cycle must not exceed a given time limit T.\n    2. The total toll cost of the Hamiltonian cycle must not exceed a given budget B.\n    3. The number of times each city is visited in the Hamiltonian cycle must not exceed its limit value.\n    4. The Hamiltonian cycle must visit each city at least once.\n    5. The Hamiltonian cycle must visit each hyperedge at least once, meaning that all sets of cities in the hyperedges must be visited together at least once.\n    6. The total number of hyperedges in the Hamiltonian cycle must be exactly m (every hyperedge must be used exactly once).\n    7. Each city must be revisited exactly its limit value number of times during the cycle, adding additional complexity to the route planning.\n\n    Args:\n        n (int): The number of vertices (cities) in the graph.\n        m (int): The number of hyperedges in the graph.\n        edges (list): A 4D array of size m, where each element [cities, [t, c, e]] represents a hyperedge connecting the set of cities \"cities\", with a total travel time t, toll cost c, and carbon emission e.\n        limits (list): A 1D array of size n, where limits[i] represents the maximum number of times city i can be visited.\n        T (int): The maximum allowed total travel time for the Hamiltonian cycle.\n        B (int): The maximum allowed total toll cost for the Hamiltonian cycle.\n\n    Returns:\n        int: The minimum total carbon emission required to visit all cities in the graph, starting and ending at the same city, while satisfying the given constraints. If no such Hamiltonian cycle exists, return -1.\n    \"\"\"\n    # Initialize a dictionary to store the adjacency list of the hypergraph\n    graph = defaultdict(list)\n    for cities, [t, c, e] in edges:\n        for city in cities:\n            graph[city].append((tuple(cities), [t, c, e]))\n\n    # Initialize a dictionary to store the number of times each city has been visited\n    visited_count = [0] * n\n\n    # Initialize a queue to store the current path and its corresponding travel time, toll cost, and carbon emission\n    queue = [([], 0, 0, 0)]\n\n    # Initialize the minimum carbon emission to a large value\n    min_carbon_emission = float('inf')\n\n    while queue:\n        path, total_time, total_cost, total_emission = queue.pop(0)\n\n        # Check if the current path is a valid Hamiltonian cycle\n        if len(path) == m and path[0] == path[-1]:\n            # Check if the current path satisfies the constraints\n            if total_time <= T and total_cost <= B and all(visited_count[city] <= limits[city] for city in set(path)):\n                min_carbon_emission = min(min_carbon_emission, total_emission)\n            continue\n\n        # Explore the next hyperedge\n        for city in graph:\n            for cities, [t, c, e] in graph[city]:\n                # Check if the current hyperedge has not been visited yet\n                if all(visited_count[c] < limits[c] for c in cities) and tuple(cities) not in path:\n                    new_path = path + [tuple(cities)]\n                    new_total_time = total_time + t\n                    new_total_cost = total_cost + c\n                    new_total_emission = total_emission + e\n\n                    # Update the visited count for each city in the current hyperedge\n                    for c in cities:\n                        visited_count[c] += 1\n\n                    queue.append((new_path, new_total_time, new_total_cost, new_total_emission))\n\n                    # Undo the visited count update\n                    for c in cities:\n                        visited_count[c] -= 1\n\n    return min_carbon_emission if min_carbon_emission != float('inf') else -1\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-36", "worker": "0a5cceb1127927f6"}, {"problem": "\nGiven a 2D grid of size m x n, where each cell represents a building and its height, your task is to find the maximum number of buildings that can be connected by a single path, where a path is defined as a sequence of adjacent cells (horizontally or vertically) with strictly increasing heights.\n\nThe input to your function will be a 2D array of integers, where each integer represents the height of the corresponding building. Your function should return the maximum number of buildings that can be connected by a single path, as well as the length of the longest path.\n\nThe problem has the following additional constraints:\n\n1. The grid can contain negative heights, representing buildings that have been demolished or are under construction.\n2. The grid can contain duplicate heights, where multiple buildings have the same height.\n3. The grid can be of arbitrary size, with m and n ranging from 1 to 1000.\n4. Your solution must have a time complexity of O(m * n) or better, as the grid size can be very large.\n5. Your solution must use efficient data structures and algorithms to handle the large input size and the additional constraints.\n\nExample:\nInput: [[1,2,3],[3,2,1],[1,1,1]]\nOutput: (3, 3)\nExplanation: The path [1,2,3] can connect 3 buildings, and the length of the longest path is 3.\n\nExample:\nInput: [[1,1,1,1],[2,2,2,2],[3,3,3,3],[4,4,4,4]]\nOutput: (4, 4)\nExplanation: All 4 buildings can be connected by a single path, and the length of the longest path is 4.\n\nExample:\nInput: [[1,2,3,4],[3,2,1,0],[1,1,1,1],[0,0,0,0]]\nOutput: (2, 4)\nExplanation: The path [1,2,3,4] can connect 4 buildings, but the path [0,1,1,1] can only connect 2 buildings. The length of the longest path is 4.\n", "startingSolution": "\ndef max_connected_buildings(grid):\n    \"\"\"\n    Given a 2D grid of size m x n, where each cell represents a building, find the maximum number of buildings that can be connected by a single path.\n\n    A path is defined as a sequence of adjacent cells (horizontally or vertically) with strictly increasing heights.\n\n    Args:\n        grid (List[List[int]]): A 2D grid of integers, where each integer represents the height of a building.\n\n    Returns:\n        int: The maximum number of buildings that can be connected by a single path.\n    \"\"\"\n    pass\n", "unitTests": [{"grid": "[1, 2, 3],         [3, 2, 1],         [1, 1, 1]", "expectedOutput": "3"}, {"expectedOutput": "4", "grid": "[1, 1, 1, 1],         [2, 2, 2, 2],         [3, 3, 3, 3],         [4, 4, 4, 4]"}, {"expectedOutput": "1", "grid": "[1, 1, 1],         [1, 1, 1],         [1, 1, 1]"}], "solution": "\ndef max_connected_buildings(grid):\n    \"\"\"\n    Given a 2D grid of size m x n, where each cell represents a building, find the maximum number of buildings that can be connected by a single path.\n\n    A path is defined as a sequence of adjacent cells (horizontally or vertically) with strictly increasing heights.\n\n    Args:\n        grid (List[List[int]]): A 2D grid of integers, where each integer represents the height of a building.\n\n    Returns:\n        int: The maximum number of buildings that can be connected by a single path.\n    \"\"\"\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    max_count = 0\n\n    def dfs(i, j, path_len, prev_height):\n        nonlocal max_count\n\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] <= prev_height:\n            return\n\n        path_len += 1\n        max_count = max(max_count, path_len)\n\n        dfs(i-1, j, path_len, grid[i][j])\n        dfs(i+1, j, path_len, grid[i][j])\n        dfs(i, j-1, path_len, grid[i][j])\n        dfs(i, j+1, path_len, grid[i][j])\n\n    for i in range(m):\n        for j in range(n):\n            dfs(i, j, 1, grid[i][j])\n\n    return max_count\n\n>\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-37", "worker": "86afe36b19d0f78b"}, {"problem": "\nGiven an undirected graph G = (V, E) with n vertices and m edges, where each vertex represents a person and each edge represents a friendship between two people. Each person i has a unique positive integer ID, denoted as ID[i], and a positive integer skill level, denoted as skill[i].\n\nYour task is to find the maximum number of disjoint groups that can be formed, where each group satisfies the following conditions:\n\n1. The group must contain at least 2 people and at most k people.\n2. The group must be connected, meaning that there is a path between any two people in the group.\n3. The difference between the maximum and minimum skill levels within the group must be at most d.\n4. The sum of the skill levels of all people in the group must be divisible by a given integer p.\n5. The group must not contain any person whose ID is a prime number.\n\nAdditionally, you are given a list of forbidden pairs of IDs, where no two people with those IDs can be in the same group.\n\nReturn the maximum number of disjoint groups that can be formed while satisfying all the above conditions.\n\nExample:\n- Input: n = 8, m = 10, k = 4, d = 15, p = 3, ID = [1, 2, 3, 4, 5, 6, 7, 8], skill = [10, 20, 30, 40, 50, 60, 70, 80], forbidden_pairs = [[1, 2], [3, 4], [5, 6]]\n- Output: 2\n- Explanation: Two groups can be formed: [2, 3, 5, 7] and [1, 4, 6, 8]\n", "startingSolution": "\ndef max_disjoint_groups(n, m, ID, skill, k):\n    \"\"\"\n    Given an undirected graph G = (V, E) with n vertices and m edges, where each vertex represents a person and each edge represents a friendship between two people. Each person i has a unique positive integer ID, denoted as ID[i], and a positive integer skill level, denoted as skill[i].\n\n    Your task is to find the maximum number of disjoint groups that can be formed, where each group satisfies the following conditions:\n\n    1. The group must contain at least 2 people.\n    2. The group must be connected, meaning that there is a path between any two people in the group.\n    3. The difference between the maximum and minimum skill levels within the group must be at most k.\n\n    Return the maximum number of disjoint groups that can be formed while satisfying the above conditions.\n\n    Args:\n        n (int): The number of vertices (people) in the graph.\n        m (int): The number of edges (friendships) in the graph.\n        ID (list[int]): A list of unique positive integer IDs, where ID[i] represents the ID of person i.\n        skill (list[int]): A list of positive integer skill levels, where skill[i] represents the skill level of person i.\n        k (int): The maximum allowed difference between the maximum and minimum skill levels within a group.\n\n    Returns:\n        int: The maximum number of disjoint groups that can be formed while satisfying the given conditions.\n    \"\"\"\n    pass\n", "unitTests": [{"n": "6", "m": "7", "ID": "[1, 2, 3, 4, 5, 6, 1, 3, 5, 2, 4, 6]", "skill": "[10, 20, 30, 40, 50, 60]", "k": "10", "expectedOutput": "2"}, {"expectedOutput": "0", "n": "6", "m": "5", "ID": "[1, 2, 3, 4, 5]", "skill": "[10, 20, 30, 40, 50]", "k": "5"}, {"expectedOutput": "1", "n": "7", "m": "6", "ID": "[1, 2, 3, 4, 5, 6, 7, 2, 4, 6, 3, 5, 7]", "skill": "[10, 20, 30, 5, 15, 25, 35]", "k": "10"}], "solution": "from collections import defaultdict\n\ndef max_disjoint_groups(n: int, m: int, ID: list[int], skill: list[int], k: int) -> int:\n    \"\"\"\n    Given an undirected graph G = (V, E) with n vertices and m edges, where each vertex represents a person and each edge represents a friendship between two people. Each person i has a unique positive integer ID, denoted as ID[i], and a positive integer skill level, denoted as skill[i].\n\n    Your task is to find the maximum number of disjoint groups that can be formed, where each group satisfies the following conditions:\n\n    1. The group must contain at least 2 people.\n    2. The group must be connected, meaning that there is a path between any two people in the group.\n    3. The difference between the maximum and minimum skill levels within the group must be at most k.\n\n    Return the maximum number of disjoint groups that can be formed while satisfying the above conditions.\n\n    Args:\n        n (int): The number of vertices (people) in the graph.\n        m (int): The number of edges (friendships) in the graph.\n        ID (list[int]): A list of unique positive integer IDs, where ID[i] represents the ID of person i.\n        skill (list[int]): A list of positive integer skill levels, where skill[i] represents the skill level of person i.\n        k (int): The maximum allowed difference between the maximum and minimum skill levels within a group.\n\n    Returns:\n        int: The maximum number of disjoint groups that can be formed while satisfying the given conditions.\n    \"\"\"\n    graph = defaultdict(list)\n    if len(ID) != 2 * m:\n        raise ValueError(\"Mismatch between the number of edges and IDs provided.\")\n    \n    for i in range(m):\n        u, v = ID[2*i], ID[2*i + 1]\n        graph[u].append(v)\n        graph[v].append(u)\n    def dfs(node, visited):\n        stack = [node]\n        group = []\n        while stack:\n            curr = stack.pop()\n            if not visited[curr]:\n                visited[curr] = True\n                group.append(curr)\n                for neighbor in graph[curr]:\n                    if not visited[neighbor]:\n                        stack.append(neighbor)\n        return group\n    result = 2\n    visited = defaultdict(bool)\n    for person in ID:\n        if not visited[person]:\n            group = dfs(person, visited)\n            if len(group) >= 2:\n                min_skill = min(skill[node] for node in group)\n                max_skill = max(skill[node] for node in group)\n                if max_skill - min_skill <= k:\n                    result += 1\n\n    return result\n\n# Example usage\nn = 6\nm = 3  \nID = [1, 2, 2, 3, 3, 4]  \nskill = [10, 20, 30, 40, 50, 60]\nk = 10\nprint(max_disjoint_groups(n, m, ID, skill, k))  # Output: 2\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-38", "worker": "86afe36b19d0f78b"}, {"problem": "You are given a 2D grid of size m x n, where each cell represents a plot of land. Some cells contain buildings, represented by positive integer values indicating the height of the building, and some cells are empty, represented by 0. Your task is to find the maximum number of buildings that can be illuminated by a set of floodlights placed on the grid, with additional constraints.\n\nEach building is represented by a positive integer value, which indicates the height of the building. The floodlights can illuminate all the buildings within a certain radius, which is determined by the height of the floodlight.\n\nThe rules for illuminating the buildings are as follows:\n- A floodlight can be placed on any empty cell (value 0) in the grid.\n- The height of the floodlight determines its illumination radius. The radius is equal to the height of the floodlight.\n- A building is considered illuminated if it is within the illumination radius of at least one floodlight.\n- The height of a floodlight must be greater than or equal to the height of the tallest building it is illuminating.\n- Each building can be illuminated by at most one floodlight.\n- No two floodlights can be placed within each other’s illumination radius.\n- The number of floodlights that can be placed is limited by a given integer L.\n- The total sum of the heights of the placed floodlights must not exceed a given budget B.\n\nYour function should take the 2D grid of building heights, the integer L, and the integer B as input and return the maximum number of buildings that can be illuminated by a set of floodlights placed on the grid.\n\nExample:\nInput: grid = [[5, 0, 9, 0, 6], [0, 0, 7, 0, 0], [5, 8, 0, 2, 3]], L = 3, B = 18\nOutput: 6\nExplanation: The maximum number of buildings that can be illuminated is 6. We can place a floodlight of height 9 at (0, 2) to illuminate the buildings at (0, 2), (0, 1), (1, 2), and (1, 1). Another floodlight of height 5 can be placed at (2, 0) to illuminate the buildings at (2, 0) and (1, 0). The total height of the floodlights used is 14, which is within the budget of 18.", "startingSolution": "\ndef max_illuminated_buildings(grid, L, B):\n    \"\"\"\n    Given a 2D grid of building heights, a maximum number of floodlights L, and a budget B, find the maximum number of buildings that can be illuminated by a set of floodlights placed on the grid.\n\n    The floodlights can illuminate all the buildings within a certain radius, which is determined by the height of the floodlight. The rules for illuminating the buildings are as follows:\n    - A floodlight can be placed on any empty cell (value 0) in the grid.\n    - The height of the floodlight determines its illumination radius. The radius is equal to the height of the floodlight.\n    - A building is considered illuminated if it is within the illumination radius of at least one floodlight.\n    - The height of a floodlight must be greater than or equal to the height of the tallest building it is illuminating.\n    - Each building can be illuminated by at most one floodlight.\n    - No two floodlights can be placed within each other's illumination radius.\n    - The number of floodlights that can be placed is limited by the given integer L.\n    - The total sum of the heights of the placed floodlights must not exceed the given budget B.\n\n    Args:\n        grid (List[List[int]]): A 2D grid of building heights.\n        L (int): The maximum number of floodlights that can be placed.\n        B (int): The budget for the total height of the floodlights.\n\n    Returns:\n        int: The maximum number of buildings that can be illuminated.\n    \"\"\"\n    pass\n", "unitTests": [{"grid": "grid = [[5, 0, 9, 0, 6], [0, 0, 7, 0, 0], [5, 8, 0, 2, 3]]", "L": "L = 3", "B": "B = 18", "expectedOutput": "6"}, {"expectedOutput": "0", "grid": "grid = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]", "L": "L = 2", "B": "B = 10"}, {"expectedOutput": "7", "grid": "grid = [[1, 2, 0, 4], [0, 0, 3, 0], [0, 6, 0, 5], [0, 0, 0, 0]]", "L": "L = 4", "B": "B = 20"}], "solution": "\ndef max_illuminated_buildings(grid, L, B):\n    \"\"\"\n    Given a 2D grid of building heights, a maximum number of floodlights L, and a budget B, find the maximum number of buildings that can be illuminated by a set of floodlights placed on the grid.\n\n    The floodlights can illuminate all the buildings within a certain radius, which is determined by the height of the floodlight. The rules for illuminating the buildings are as follows:\n    - A floodlight can be placed on any empty cell (value 0) in the grid.\n    - The height of the floodlight determines its illumination radius. The radius is equal to the height of the floodlight.\n    - A building is considered illuminated if it is within the illumination radius of at least one floodlight.\n    - The height of a floodlight must be greater than or equal to the height of the tallest building it is illuminating.\n    - Each building can be illuminated by at most one floodlight.\n    - No two floodlights can be placed within each other's illumination radius.\n    - The number of floodlights that can be placed is limited by the given integer L.\n    - The total sum of the heights of the placed floodlights must not exceed the given budget B.\n\n    Args:\n        grid (List[List[int]]): A 2D grid of building heights.\n        L (int): The maximum number of floodlights that can be placed.\n        B (int): The budget for the total height of the floodlights.\n\n    Returns:\n        int: The maximum number of buildings that can be illuminated.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    empty_cells = sorted([(i, j, grid[i][j]) for i in range(m) for j in range(n) if grid[i][j] == 0], key=lambda x: -x[2])\n    placed_floodlights = []\n    illuminated_buildings = set()\n\n    for i, j, height in empty_cells:\n        if len(placed_floodlights) >= L:\n            break\n\n        if sum(h for _, _, h in placed_floodlights) + height > B:\n            continue\n\n        can_place = True\n        for x, y, h in placed_floodlights:\n            if abs(i - x) + abs(j - y) < max(height, h):\n                can_place = False\n                break\n\n        if can_place:\n            placed_floodlights.append((i, j, height))\n            for x in range(max(0, i - height), min(m, i + height + 1)):\n                for y in range(max(0, j - height), min(n, j + height + 1)):\n                    if grid[x][y] > 0:\n                        illuminated_buildings.add((x, y))\n\n    return len(illuminated_buildings)\n\n\n# Example usage\ngrid = [[5, 0, 9, 0, 6], [0, 0, 7, 0, 0], [5, 8, 0, 2, 3]]\nL = 3\nB = 18\nprint(max_illuminated_buildings(grid, L, B))  # Output: 6\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-39", "worker": "0a5cceb1127927f6"}, {"problem": "You are given a set of n tasks, where each task has a start time, an end time, and a value associated with it. Your task is to design and implement a function that finds the maximum total value of tasks that can be completed without any overlaps.\nThe function should take the following inputs:\n    - An array of n tuples, where each tuple represents a task with the start time, end time, and value.\n\nThe function should return the maximum total value of tasks that can be completed without any overlaps.\nThe rules for completing the tasks are as follows:\n    - Each task must be completed within its start and end time.\n    - No two tasks can overlap in time.\n    - You can not end a task and start another one in the same time, in other words you can not end a task at 1 and start another task at 1.\n    - The goal is to find the maximum total value of tasks that can be completed without any overlaps.\nExample:\n    Input:\n    [(1, 3, 5), (2, 4, 3), (3, 5, 4), (4, 6, 2)]\n    Output: 9\n    Explanation:\n        The optimal schedule is to complete the tasks at (1, 3, 5) and (3, 5, 4), which have a total value of 9.", "startingSolution": "def max_task_value(tasks: list[tuple[int, int, int]]) -> int:\r\n    \"\"\"\r\n    Given a set of n tasks, where each task has a start time, an end time, and a value associated with it,\r\n    find the maximum total value of tasks that can be completed without any overlaps.\r\n\r\n    Args:\r\n        tasks (list of tuples): A list of tuples, where each tuple represents a task with the start time, end time, and value.\r\n\r\n    Returns:\r\n        int: The maximum total value of tasks that can be completed without any overlaps.\r\n    \"\"\"", "unitTests": [{"": "[(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (5, 6, 1)]", "expectedOutput": "3"}, {"expectedOutput": "16", "": "[(1, 10, 3), (3, 5, 4), (6, 10, 5), (12, 15, 7)]"}, {"expectedOutput": "18", "": "[(1, 10, 11), (3, 5, 4), (6, 10, 5), (12, 15, 7)]"}, {"": "[(6, 10, 5), (3, 5, 4), (12, 15, 7), (1, 10, 3)]", "expectedOutput": "16"}, {"expectedOutput": "10", "": "[(1, 10, 3), (1, 10, 7), (1, 10, 10), (1, 10, 1)]"}, {"expectedOutput": "0", "": "[]"}], "solution": "def find_next(tasks: list[tuple[int, int, int]], idx: int,\r\n              end_time: int) -> int:\r\n    left: int = idx + 1\r\n    right: int = len(tasks)\r\n\r\n    while (left < right):\r\n        mid: int = left + (right - left) // 2\r\n\r\n        if tasks[mid][0] <= end_time:\r\n            left = mid + 1\r\n        else:\r\n            right = mid\r\n\r\n    return right\r\n\r\n\r\ndef calculate_max_task_value(dp: list[list[int]], tasks: list[tuple[int, int,\r\n                                                                    int]],\r\n                             idx: int, end_time: int) -> int:\r\n    if idx >= len(tasks):\r\n        return 0\r\n\r\n    key = 1 if end_time >= tasks[idx][0] else 0\r\n\r\n    if dp[idx][key] != -1:\r\n        return dp[idx][key]\r\n\r\n    if end_time >= tasks[idx][0]:\r\n        next = find_next(tasks, idx, end_time)\r\n        dp[idx][key] = calculate_max_task_value(dp, tasks, next, end_time)\r\n\r\n        return dp[idx][key]\r\n\r\n    result1 = calculate_max_task_value(dp, tasks, idx + 1, end_time)\r\n    result2 = calculate_max_task_value(dp, tasks, idx + 1,\r\n                                       tasks[idx][1]) + tasks[idx][2]\r\n\r\n    dp[idx][key] = max(result1, result2)\r\n\r\n    return dp[idx][key]\r\n\r\n\r\ndef max_task_value(tasks: list[tuple[int, int, int]]) -> int:\r\n    \"\"\"\r\n    Given a set of n tasks, where each task has a start time, an end time, and a value associated with it,\r\n    find the maximum total value of tasks that can be completed without any overlaps.\r\n\r\n    Args:\r\n        tasks (list of tuples): A list of tuples, where each tuple represents a task with the start time, end time, and value.\r\n\r\n    Returns:\r\n        int: The maximum total value of tasks that can be completed without any overlaps.\r\n    \"\"\"\r\n    dp = []\r\n\r\n    for _ in range(len(tasks)):\r\n        dp.append([-1, -1])\r\n\r\n    tasks.sort(key=lambda item: item[1])\r\n\r\n    return calculate_max_task_value(dp, tasks, 0, -1)", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-40", "worker": "94607a49db8dc666"}, {"problem": "\\nYou are given a 2D grid of size m x n, where each cell represents a node in a graph. The grid is divided into two types of regions: land and water. Land cells are represented by the value 1, and water cells are represented by the value 0.\\n\\nYour task is to implement a function that finds the minimum number of bridges required to connect all the land regions in the grid, such that each land region is accessible from every other land region. A bridge is defined as a path that connects two land regions, and it can only be built between adjacent (horizontally, vertically, or diagonally) land cells.\\n\\nThe function should take the 2D grid as input and return the minimum number of bridges required to connect all the land regions.\\n\\nExample:\\nInput: grid = [[1,1,0,0,0],[0,1,0,0,0],[0,1,0,0,1],[0,1,0,0,0],[0,1,0,0,0]]\\nOutput: 1\\nExplanation: The grid can be divided into two land regions: one with cells (0,0), (0,1), (1,1), (2,1), (3,1), (4,1), and the other with cell (2,4). We need to build one bridge to connect these two regions.\\n\\nThe function should handle grids of any size, and the land and water regions can be arranged in any arbitrary pattern.\\n", "startingSolution": "\r\ndef min_bridges(grid):\r\n    \"\"\"\r\n    Given a 2D grid of size m x n, where each cell represents a node in a graph, and the grid is divided into land (1) and water (0) regions, find the minimum number of bridges required to connect all the land regions such that each land region is accessible from every other land region.\r\n    \r\n    A bridge is defined as a path that connects two land regions, and it can only be built between adjacent (horizontally, vertically, or diagonally) land cells.\r\n\r\n    if brige is long enough so that each 3rd part of the bridge cost twice as second part  of the bridge.\r\n    \r\n    Use MST to construct a skeleton connecting all land regions\r\n    Args:\r\n        grid (List[List[int]]): A 2D grid of size m x n, where each cell is either 0 (water) or 1 (land).\r\n\r\n    Returns:\r\n        int: The minimum number of bridges required to connect all the land regions in the grid.\r\n    \"\"\"\r\n    pass\r\n", "unitTests": [{"grid": "[[1, 1, 0, 0, 0], [0, 1, 0, 0, 0], [0, 1, 0, 0, 1], [0, 1, 0, 0, 0], [0, 1, 0, 0, 1]]", "expectedOutput": "1"}, {"expectedOutput": "0", "grid": "[]"}, {"expectedOutput": "1", "grid": "grid = [             [1, 1, 0, 0, 0],             [0, 1, 0, 0, 0],             [0, 1, 0, 0, 1],             [0, 1, 0, 0, 0],             [0, 1, 0, 0, 0]         ]"}], "solution": "\nimport heapq\n\ndef min_bridges(grid):\n    \"\"\"\n    Given a 2D grid of size m x n, where each cell represents a node in a graph, and the grid is divided into land (1) and water (0) regions, find the minimum number of bridges required to connect all the land regions such that each land region is accessible from every other land region.\n    \n    A bridge is defined as a path that connects two land regions, and it can only be built between adjacent (horizontally, vertically, or diagonally) land cells.\n\n    If the bridge is long enough so that each 3rd part of the bridge costs twice as much as the second part of the bridge.\n    \n    Use MST to construct a skeleton connecting all land regions.\n    Args:\n        grid (List[List[int]]): A 2D grid of size m x n, where each cell is either 0 (water) or 1 (land).\n\n    Returns:\n        int: The minimum number of bridges required to connect all the land regions in the grid.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    parent = list(range(m * n))\n    rank = [0] * (m * n)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        x_root = find(x)\n        y_root = find(y)\n        if x_root == y_root:\n            return\n        if rank[x_root] < rank[y_root]:\n            parent[x_root] = y_root\n        elif rank[x_root] > rank[y_root]:\n            parent[y_root] = x_root\n        else:\n            parent[y_root] = x_root\n            rank[x_root] += 1\n\n    edges = []\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == 1:\n                        cost = max(abs(i - ni), abs(j - nj)) * 2 ** (max(abs(i - ni), abs(j - nj)) // 3)\n                        edges.append((cost, i * n + j, ni * n + nj))\n\n    edges.sort()\n    total_cost = 0\n    for cost, u, v in edges:\n        if find(u) != find(v):\n            union(u, v)\n            total_cost += cost\n\n    return total_cost\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-41", "worker": "057f47b83434cfb3"}, {"problem": "\nYou are given a 3D grid of integers, where grid[i][j][k] represents the value of the cell at row i, column j, and depth k. Your task is to find the maximum number of distinct L-shaped paths that can be formed by connecting adjacent cells (horizontally, vertically, or diagonally) such that the sum of the values in the cells along each path is divisible by a given integer k, and the path length is at least a given minimum length L.\n\nAn L-shaped path is a path that consists of two segments: a horizontal segment and a vertical segment (or vice versa). The two segments must be connected at a single cell, and the path must not overlap with any other path.\n\nThe input to your function is:\n- A 3D array grid, where grid[i][j][k] represents the value of the cell at row i, column j, and depth k.\n- An integer k, which represents the divisor for the path sum.\n- An integer L, which represents the minimum length of the paths to be considered.\n\nYour function should return the maximum number of distinct L-shaped paths that satisfy the divisibility and minimum length conditions.\n\nExample:\n- grid = [[[-1, 2, 3], [4, 5, 6], [7, 8, 9]], [[10, 11, 12], [13, 14, 15], [16, 17, 18]], [[19, 20, 21], [22, 23, 24], [25, 26, 27]]]\n- k = 3\n- L = 6\n- Output: 1\n  The only distinct L-shaped path is:\n  4 -> 5 -> 14 -> 15 -> 24 -> 25 (sum = 87, divisible by 3, length = 6)\n", "startingSolution": "def max_l_shaped_paths(grid, k, L):\r\n    if not grid or not grid[0] or not grid[0][0]:\r\n        return 0\r\n    \r\n    n = len(grid)\r\n    m = len(grid[0])\r\n    p = len(grid[0][0])\r\n    \r\n    dp = [[[0] * k for _ in range(m)] for _ in range(n)]\r\n    \r\n    # Initialize starting point\r\n    dp[0][0][grid[0][0][0] % k] = 1\r\n    \r\n    # Process each cell in the grid\r\n    for i in range(n):\r\n        for j in range(m):\r\n            for mod in range(k):\r\n                if dp[i][j][mod] > 0:\r\n                    current_length = i + j  # Number of steps taken to reach (i, j)\r\n                    \r\n                    # Check horizontal and vertical extensions\r\n                    if i > 0:\r\n                        if current_length >= L - 1:  # Ensure minimum length is met\r\n                            new_mod = (mod + grid[i][j][0]) % k\r\n                            dp[i][j][new_mod] = max(dp[i][j][new_mod], dp[i-1][j][mod] + 1)\r\n                    \r\n                    if j > 0:\r\n                        if current_length >= L - 1:  # Ensure minimum length is met\r\n                            new_mod = (mod + grid[i][j][0]) % k\r\n                            dp[i][j][new_mod] = max(dp[i][j][new_mod], dp[i][j-1][mod] + 1)\r\n                    \r\n                    # Check diagonal extensions\r\n                    if i > 0 and j > 0:\r\n                        if current_length >= L - 1:  # Ensure minimum length is met\r\n                            new_mod = (mod + grid[i][j][0]) % k\r\n                            dp[i][j][new_mod] = max(dp[i][j][new_mod], dp[i-1][j-1][mod] + 1)\r\n                    \r\n                    if i > 0 and j < m - 1:\r\n                        if current_length >= L - 1:  # Ensure minimum length is met\r\n                            new_mod = (mod + grid[i][j][0]) % k\r\n                            dp[i][j][new_mod] = max(dp[i][j][new_mod], dp[i-1][j+1][mod] + 1)\r\n    \r\n    # Find the maximum number of paths ending at any cell with mod 0 and length >= L\r\n    max_paths = 0\r\n    for i in range(n):\r\n        for j in range(m):\r\n            max_paths = max(max_paths, dp[i][j][0])\r\n    \r\n    return max_paths\r\n\r\n# Example usage:\r\ngrid = [\r\n    [[-1, 2, 3], [4, 5, 6], [7, 8, 9]],\r\n    [[10, 11, 12], [13, 14, 15], [16, 17, 18]],\r\n    [[19, 20, 21], [22, 23, 24], [25, 26, 27]]\r\n]\r\nk = 3\r\nL = 6\r\n\r\nprint(max_l_shaped_paths(grid, k, L))  # Output: 1\r\n", "unitTests": [{"grid": "grid = [         [[-1, 2, 3], [4, 5, 6], [7, 8, 9]],         [[10, 11, 12], [13, 14, 15], [16, 17, 18]],         [[19, 20, 21], [22, 23, 24], [25, 26, 27]]     ]", "k": "3", "L": "6", "expectedOutput": "1"}, {"expectedOutput": "2", "grid": "grid = [         [[1, 2, 3], [4, 5, 6], [7, 8, 9]],         [[10, 11, 12], [13, 14, 15], [16, 17, 18]],         [[19, 20, 21], [22, 23, 24], [25, 26, 27]]     ]", "k": "5", "L": "4"}, {"expectedOutput": "0", "grid": "grid = [         [[1, 2, 3], [4, 5, 6], [7, 8, 9]],         [[10, 11, 12], [13, 14, 15], [16, 17, 18]],         [[19, 20, 21], [22, 23, 24], [25, 26, 27]]     ]", "k": "2", "L": "5"}], "solution": "\ndef max_l_shaped_paths(grid, k, L):\n    if not grid or not grid[0] or not grid[0][0]:\n        return 0\n    \n    n = len(grid)\n    m = len(grid[0])\n    p = len(grid[0][0])\n    \n    dp = [[[0] * k for _ in range(m)] for _ in range(n)]\n    \n    # Initialize starting point\n    dp[0][0][grid[0][0][0] % k] = 1\n    \n    # Process each cell in the grid\n    for i in range(n):\n        for j in range(m):\n            for mod in range(k):\n                if dp[i][j][mod] > 0:\n                    current_length = i + j  # Number of steps taken to reach (i, j)\n                    \n                    # Check horizontal and vertical extensions\n                    if i > 0:\n                        if current_length >= L - 1:  # Ensure minimum length is met\n                            new_mod = (mod + grid[i][j][0]) % k\n                            dp[i][j][new_mod] = max(dp[i][j][new_mod], dp[i-1][j][mod] + 1)\n                    \n                    if j > 0:\n                        if current_length >= L - 1:  # Ensure minimum length is met\n                            new_mod = (mod + grid[i][j][0]) % k\n                            dp[i][j][new_mod] = max(dp[i][j][new_mod], dp[i][j-1][mod] + 1)\n                    \n                    # Check diagonal extensions\n                    if i > 0 and j > 0:\n                        if current_length >= L - 1:  # Ensure minimum length is met\n                            new_mod = (mod + grid[i][j][0]) % k\n                            dp[i][j][new_mod] = max(dp[i][j][new_mod], dp[i-1][j-1][mod] + 1)\n                    \n                    if i > 0 and j < m - 1:\n                        if current_length >= L - 1:  # Ensure minimum length is met\n                            new_mod = (mod + grid[i][j][0]) % k\n                            dp[i][j][new_mod] = max(dp[i][j][new_mod], dp[i-1][j+1][mod] + 1)\n    \n    # Find the maximum number of paths ending at any cell with mod 0 and length >= L\n    max_paths = 0\n    for i in range(n):\n        for j in range(m):\n            max_paths = max(max_paths, dp[i][j][0])\n    \n    return max_paths\n\n# Example usage:\ngrid = [\n    [[-1, 2, 3], [4, 5, 6], [7, 8, 9]],\n    [[10, 11, 12], [13, 14, 15], [16, 17, 18]],\n    [[19, 20, 21], [22, 23, 24], [25, 26, 27]]\n]\nk = 3\nL = 6\n\nprint(max_l_shaped_paths(grid, k, L))  # Output: 1\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-42", "worker": "725396297197498f"}, {"problem": "\nYou are given a set of n tasks, where each task has a start time, an end time, a weight, and a priority. Your goal is to find a subset of tasks that can be completed without any overlaps, and the sum of the weights of the selected tasks, weighted by their priorities, is maximized.\n\nThe input to your function will be a 2D array of integers, where each inner array represents a task with [start_time, end_time, weight, priority]. The function should return an integer representing the maximum weighted sum of the selected tasks.\n\nExample:\nInput: [[1, 3, 5, 2], [2, 4, 3, 1], [3, 5, 4, 3], [4, 6, 1, 1]]\nOutput: 19\n\nExplanation: The optimal subset of tasks is [1, 3, 5] with weight 5 and priority 2, and [3, 5, 4] with weight 4 and priority 3, resulting in a total weighted sum of 5 * 2 + 4 * 3 = 19.\n", "startingSolution": "from typing import List\r\n\r\n\r\ndef find_max_weight(tasks: List[List[int]], index: int) -> int:\r\n    \"\"\"\r\n    Finds the maximum weighted sum of selected non-overlapping tasks based on their weights and priorities.\r\n\r\n    Args:\r\n        tasks: A list of tasks where each task is represented by [start_time, end_time, weight, priority].\r\n        index: The current index of the task being considered.\r\n\r\n    Returns:\r\n        The maximum weighted sum of the selected tasks up to the given index.\r\n    \"\"\"\r\n\r\n    tasks.sort(key=lambda x: x[1])\r\n\r\n    def binary_search(tasks, index):\r\n        low, high = 0, index - 1\r\n        while low <= high:\r\n            mid = (low + high) // 2\r\n            if tasks[mid][1] <= tasks[index][0]:\r\n                if tasks[mid + 1][1] <= tasks[index][0]:\r\n                    low = mid + 1\r\n                else:\r\n                    return mid\r\n            else:\r\n                high = mid - 1\r\n        return -1\r\n\r\n    if index == 0:\r\n        return tasks[0][2]\r\n\r\n    include_weight = tasks[index][2]\r\n    latest_non_conflicting = binary_search(tasks, index)\r\n    if latest_non_conflicting != -1:\r\n        include_weight += find_max_weight(tasks, latest_non_conflicting)\r\n\r\n    exclude_weight = find_max_weight(tasks, index - 1)\r\n\r\n    return max(include_weight, exclude_weight)", "unitTests": [{"tasks": "[[1, 2, 50, 1], [3, 5, 20, 2], [6, 19, 100, 3], [2, 100, 200, 1]]", "index": "1", "expectedOutput": "250"}, {"expectedOutput": "40", "tasks": "[[1, 2, 10, 1], [2, 3, 10, 1], [3, 4, 10, 1], [4, 5, 10, 1]]", "index": "-1"}, {"expectedOutput": "15", "tasks": "[[1, 3, 5, 1], [3, 5, 5, 2], [5, 7, 5, 3]]", "index": "-1"}], "solution": "from typing import List\n\n\ndef find_max_weight(tasks: List[List[int]], index: int) -> int:\n    \"\"\"\n    Finds the maximum weighted sum of selected non-overlapping tasks based on their weights and priorities.\n\n    Args:\n        tasks: A list of tasks where each task is represented by [start_time, end_time, weight, priority].\n        index: The current index of the task being considered.\n\n    Returns:\n        The maximum weighted sum of the selected tasks up to the given index.\n    \"\"\"\n\n    tasks.sort(key=lambda x: x[1])\n\n    def binary_search(tasks, index):\n        low, high = 0, index - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if tasks[mid][1] <= tasks[index][0]:\n                if tasks[mid + 1][1] <= tasks[index][0]:\n                    low = mid + 1\n                else:\n                    return mid\n            else:\n                high = mid - 1\n        return -1\n\n    if index == 0:\n        return tasks[0][2]\n\n    include_weight = tasks[index][2]\n    latest_non_conflicting = binary_search(tasks, index)\n    if latest_non_conflicting != -1:\n        include_weight += find_max_weight(tasks, latest_non_conflicting)\n\n    exclude_weight = find_max_weight(tasks, index - 1)\n\n    return max(include_weight, exclude_weight)", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-43", "worker": "c2610e1792c5cf07"}, {"problem": "You are given a set of n tasks, where each task has a start time, an end time, and a value associated with it. Your task is to design and implement a function that finds the maximum total value of tasks that can be completed without any overlaps.\n\nThe function should take the following inputs:\n- An array of n tuples, where each tuple represents a task with the start time, end time, and value.\n\nThe function should return the maximum total value of tasks that can be completed without any overlaps.\nThe rules for completing the tasks are as follows:\n- Each task must be completed within its start and end time.\n- No two tasks can overlap in time.\n- You can not end a task and start another one simultaneously, In other words, you can not end a task at time 1 and start another task in time 1.\n- The goal is to find the maximum total value of tasks that can be completed without any overlaps.\nExample:\n    Input:\n    [(1, 3, 5), (2, 4, 3), (3, 5, 4), (4, 6, 2)]\n    Output: 9\n    Explanation:\n        The optimal schedule is to complete the tasks at (1, 3, 5) and (3, 5, 4), which have a total value of 9.", "startingSolution": "def max_task_value(tasks: list[tuple[int, int, int]]) -> int:\r\n    \"\"\"\r\n    Given a set of n tasks, where each task has a start time, an end time, and a value associated with it,\r\n    find the maximum total value of tasks that can be completed without any overlaps.\r\n\r\n    Args:\r\n        tasks (list of tuples): A list of tuples, where each tuple represents a task with the start time, end time, and value.\r\n\r\n    Returns:\r\n        int: The maximum total value of tasks that can be completed without any overlaps.\r\n    \"\"\"", "unitTests": [{"": "[(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (5, 6, 1)]", "expectedOutput": "3"}, {"expectedOutput": "16", "": "[(1, 10, 3), (3, 5, 4), (6, 10, 5), (12, 15, 7)]"}, {"expectedOutput": "18", "": "[(1, 10, 11), (3, 5, 4), (6, 10, 5), (12, 15, 7)]"}, {"expectedOutput": "16", "": "[(6, 10, 5), (3, 5, 4), (12, 15, 7), (1, 10, 3)]"}, {"expectedOutput": "10", "": "[(1, 10, 3), (1, 10, 7), (1, 10, 10), (1, 10, 1)]"}, {"expectedOutput": "0", "": "[]"}], "solution": "\ndef max_task_value(tasks: list[tuple[int, int, int]]) -> int:\n    \"\"\"\n    Given a set of n tasks, where each task has a start time, an end time, and a value associated with it,\n    find the maximum total value of tasks that can be completed without any overlaps.\n\n    Args:\n        tasks (list of tuples): A list of tuples, where each tuple represents a task with the start time, end time, and value.\n\n    Returns:\n        int: The maximum total value of tasks that can be completed without any overlaps.\n    \"\"\"\n    if not tasks:\n        return 0\n\n    tasks.sort(key=lambda x: x[1])  # Sort tasks by end time\n\n    dp = [0] * (len(tasks) + 1)\n\n    for i in range(1, len(tasks) + 1):\n        # Find the latest non-overlapping task before the current task\n        j = i - 1\n        while j >= 0 and tasks[j][1] > tasks[i - 1][0]:\n            j -= 1\n\n        # Choose the maximum value between including the current task or not\n        dp[i] = max(dp[i - 1], (dp[j + 1] if j >= 0 else 0) + tasks[i - 1][2])\n\n    return dp[-1]\n\n# Supplemental code for verifying the solution passes all unit tests\ndef test_max_task_value():\n    assert max_task_value([(1, 2, 3)]) == 3\n    assert max_task_value([(1, 3, 2), (2, 4, 3), (3, 5, 5)]) == 16\n    assert max_task_value([(1, 4, 2), (3, 5, 3), (0, 6, 3), (4, 7, 1), (3, 8, 5), (5, 9, 3)]) == 18\n    assert max_task_value([(1, 2, 3), (2, 3, 4), (3, 4, 5)]) == 16\n    assert max_task_value([(1, 2, 3), (2, 3, 4), (2, 4, 5)]) == 10\n    assert max_task_value([]) == 0\n\ntest_max_task_value()\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-44", "worker": "94607a49db8dc666"}, {"problem": "You are given an array of integers nums and an integer k. Your task is to find the maximum possible product of any contiguous subarray of nums of length at most k.\n\nThe product of an empty subarray is considered to be 1.\n\nImplement a function maxProductSubarray(nums, k) that takes the input array nums and the integer k, and returns the maximum possible product of any contiguous subarray of nums of length at most k.", "startingSolution": "\r\ndef maxProductSubarray(nums, k):\r\n    \"\"\"\r\n    Given an array of integers nums and an integer k, find the maximum possible product of any contiguous subarray of nums of length at most k.\r\n\r\n    The product of an empty subarray is considered to be 1.\r\n\r\n    Args:\r\n        nums (list[int]): The input array of integers.\r\n        k (int): The maximum length of the contiguous subarray.\r\n\r\n    Returns:\r\n        int: The maximum possible product of any contiguous subarray of nums of length at most k.\r\n    \"\"\"\r\n   def maxProductSubarray(nums, k):\r\n    n = len(nums)\r\n    max_product = float('-inf')\r\n\r\n    for i in range(n):\r\n        current_product = 1\r\n        for j in range(i, min(i + k, n)):\r\n            current_product *= nums[j]\r\n            max_product = max(max_product, current_product)\r\n\r\n    if max_product == float('-inf'):\r\n        return 0\r\n    return max_product\r\n\r\n", "unitTests": [{"nums": "nums1 = [2, 3, -2, 4]", "k": "2", "expectedOutput": "6"}, {"expectedOutput": "0", "nums": "   nums2 = [-2, 0, -1]", "k": "2"}, {"expectedOutput": "40", "nums": "[1, 2, -1, -2, 2, 1, -2, 1, 4, -5, 4]", "k": "4"}], "solution": "\r\ndef maxProductSubarray(nums, k):\r\n    \"\"\"\r\n    Given an array of integers nums and an integer k, find the maximum possible product of any contiguous subarray of nums of length at most k.\r\n\r\n    The product of an empty subarray is considered to be 1.\r\n\r\n    Args:\r\n        nums (list[int]): The input array of integers.\r\n        k (int): The maximum length of the contiguous subarray.\r\n\r\n    Returns:\r\n        int: The maximum possible product of any contiguous subarray of nums of length at most k.\r\n    \"\"\"\r\n    n = len(nums)\r\n    max_product = float('-inf')\r\n\r\n    for i in range(n):\r\n        current_product = 1\r\n        for j in range(i, min(i + k, n)):\r\n            current_product *= nums[j]\r\n            max_product = max(max_product, current_product)\r\n\r\n    if max_product == float('-inf'):\r\n      \r\n       return max_product\r\n\r\n\r\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-45", "worker": "6e7b82a374b87eb3"}, {"problem": "nYou are given a 2D grid of size m x n, where each cell represents a unique location on a map. The grid is filled with various types of terrain, represented by integers from 1 to 10, where 1 represents the most difficult terrain and 10 represents the easiest terrain.\\n\\nYour task is to implement a function that finds the shortest path between two given locations on the map, subject to the following constraints:\\n\\n1. The path must start at a cell with terrain type 10 and end at a cell with terrain type 10.\\n2. The path must only traverse cells with terrain types greater than or equal to a specified minimum terrain type, which can be any integer from 1 to 9.\\n3. The path must minimize the total distance traveled, where the distance between two adjacent cells is 1.\\n4. If multiple shortest paths exist, the function should return the one that minimizes the sum of the terrain types along the path.\\n\\nThe function should take the following input:\\n- A 2D grid of integers representing the terrain types\\n- The starting location (x1, y1)\\n- The ending location (x2, y2)\\n- The minimum required terrain type\\n\\nThe function should return the shortest path as a list of (x, y) coordinates, or an empty list if no valid path exists.\\n\\nExample:\\n- grid = [[10, 8, 9, 9, 10],\\n         [9, 7, 8, 9, 9],\\n         [8, 6, 7, 8, 9],\\n         [7, 5, 6, 7, 8],\\n         [10, 9, 8, 7, 10]]\\n- startLocation = (0, 0)\\n- endLocation = (4, 4)\\n- minTerrainType = 7\\n- shortestPath = [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]\\n\", ", "startingSolution": "\ndef find_shortest_path(grid, start_location, end_location, min_terrain_type):\n    \"\"\"\n    Find the shortest path between two locations on a 2D grid, subject to the following constraints:\n    1. The path must start at a cell with terrain type 10 and end at a cell with terrain type 10.\n    2. The path must only traverse cells with terrain types greater than or equal to the specified minimum terrain type.\n    3. The path must minimize the total distance traveled, where the distance between two adjacent cells is 1.\n    4. If multiple shortest paths exist, the function should return the one that minimizes the sum of the terrain types along the path.\n\n    Args:\n        grid (List[List[int]]): A 2D grid of integers representing the terrain types.\n        start_location (Tuple[int, int]): The starting location (x, y).\n        end_location (Tuple[int, int]): The ending location (x, y).\n        min_terrain_type (int): The minimum required terrain type (between 1 and 9).\n\n    Returns:\n        List[Tuple[int, int]]: The shortest path as a list of (x, y) coordinates, or an empty list if no valid path exists.\n    \"\"\"\n    pass\n", "unitTests": [{"grid": "[     [10, 4, 9, 9, 10],     [9, 7, 8, 9, 9],     [8, 6, 7, 8, 9],     [7, 5, 6, 3, 8],     [10, 9, 8, 7, 10] ]", "start_location": "(0, 0)", "end_location": "(4, 4)", "min_terrain_type": "7", "expectedOutput": "[(0, 0), (1, 1), (2, 2), (2, 3), (3, 4), (4, 4)]"}, {"expectedOutput": "[(0, 0), (1, 1), (2, 0), (3, 0), (4, 0)]", "grid": "[     [10, 4, 9, 9, 10],     [9, 7, 8, 9, 9],     [8, 6, 7, 8, 9],     [7, 5, 6, 3, 8],     [10, 9, 8, 7, 10] ]", "start_location": "(0, 0)", "end_location": "(4, 0)", "min_terrain_type": "7"}, {"expectedOutput": "[(0, 0), (1, 1), (2, 1), (3, 2), (4, 3), (4, 4)]", "grid": " [     [10, 4, 9, 9, 10],     [9, 7, 8, 9, 9],     [8, 6, 7, 8, 9],     [7, 5, 6, 3, 8],     [10, 9, 8, 7, 10] ]", "start_location": "(0, 0)", "end_location": "(4, 4)", "min_terrain_type": "4"}], "solution": "\nfrom collections import deque\n\ndef find_shortest_path(grid, start_location, end_location, min_terrain_type):\n    \"\"\"\n    Find the shortest path between two locations on a 2D grid, subject to the following constraints:\n    1. The path must start at a cell with terrain type 10 and end at a cell with terrain type 10.\n    2. The path must only traverse cells with terrain types greater than or equal to the specified minimum terrain type.\n    3. The path must minimize the total distance traveled, where the distance between two adjacent cells is 1.\n    4. If multiple shortest paths exist, the function should return the one that minimizes the sum of the terrain types along the path.\n\n    Args:\n        grid (List[List[int]]): A 2D grid of integers representing the terrain types.\n        start_location (Tuple[int, int]): The starting location (x, y).\n        end_location (Tuple[int, int]): The ending location (x, y).\n        min_terrain_type (int): The minimum required terrain type (between 1 and 9).\n\n    Returns:\n        List[Tuple[int, int]]: The shortest path as a list of (x, y) coordinates, or an empty list if no valid path exists.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    queue = deque([(start_location, [start_location], 0, 0)])  # (location, path, distance, terrain_sum)\n    visited = set()\n\n    while queue:\n        location, path, distance, terrain_sum = queue.popleft()\n        x, y = location\n\n        if location == end_location and grid[x][y] == 10:\n            return path\n\n        if location in visited or grid[x][y] < min_terrain_type:\n            continue\n\n        visited.add(location)\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < m and 0 <= new_y < n:\n                new_location = (new_x, new_y)\n                new_path = path + [new_location]\n                new_distance = distance + 1\n                new_terrain_sum = terrain_sum + grid[new_x][new_y]\n                queue.append((new_location, new_path, new_distance, new_terrain_sum))\n\n    return []\n", "meetsStartingSolutionFormatCriteria": true, "meetsFinalSolutionFormatCriteria": true, "meetsCorrectnessCriteria": true, "meetsDifficultyCriteria": false, "id": "example-46", "worker": "df0862d302f4b759"}, {"problem": "\nYou are given an undirected graph represented as an adjacency list, where each node in the graph is labeled with a unique integer from 0 to n-1, where n is the total number of nodes. Your task is to find the maximum number of disjoint subgraphs in the graph, where each subgraph satisfies the following conditions:\n\n1. The subgraph is connected (i.e., there is a path between any two nodes in the subgraph).\n2. The subgraph contains at least 3 nodes.\n3. The sum of the squares of the node labels in the subgraph is a perfect square.\n4. The subgraph must have an even number of nodes.\n5. The subgraph must contain at least one node with a label that is divisible by 3.\n6. The subgraph must not contain any node with a label that is a prime number.\n\nFor example, consider the following graph:\n\n```\n0 - 1 - 2\n|   |   |\n3 - 4 - 5\n```\n\nIn this graph, there is only one disjoint subgraph that satisfies all the conditions:\n- Subgraph 1: [0, 3, 4] (sum of squares: 0^2 + 3^2 + 4^2 = 25, which is a perfect square, and the subgraph has an even number of nodes, contains a node with a label divisible by 3, and does not contain any prime numbers)\n\nTherefore, the maximum number of disjoint subgraphs that satisfy the conditions is 1.\n\nYour function should take an adjacency list representation of the graph as input and return the maximum number of disjoint subgraphs that satisfy the conditions.\n", "startingSolution": "\ndef max_disjoint_subgraphs(graph):\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, find the maximum number of disjoint subgraphs that satisfy the following conditions:\n    \n    1. The subgraph is connected (i.e., there is a path between any two nodes in the subgraph).\n    2. The subgraph contains at least 3 nodes.\n    3. The sum of the squares of the node labels in the subgraph is a perfect square.\n    \n    Args:\n        graph (list): An adjacency list representation of the undirected graph.\n    \n    Returns:\n        int: The maximum number of disjoint subgraphs that satisfy the conditions.\n    \"\"\"\n    pass\n", "unitTests": [{"expectedOutput": "0", "graph": "0: [1, 3],         1: [0, 2, 4],         2: [1, 5],         3: [0, 4],         4: [1, 3, 5],         5: [2, 4]"}, {"expectedOutput": "0", "graph": "0: [1],         1: [0, 2],         2: [1, 3],         3: [2],         4: [5],         5: [4]"}, {"expectedOutput": "0", "graph": "0: [1],         1: [0, 2],         2: [1, 3],         3: [2]"}], "solution": "\nfrom math import sqrt\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef max_disjoint_subgraphs(graph):\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, find the maximum number of disjoint subgraphs that satisfy the following conditions:\n    \n    1. The subgraph is connected (i.e., there is a path between any two nodes in the subgraph).\n    2. The subgraph contains at least 3 nodes.\n    3. The sum of the squares of the node labels in the subgraph is a perfect square.\n    4. The subgraph must have an even number of nodes.\n    5. The subgraph must contain at least one node with a label that is divisible by 3.\n    6. The subgraph must not contain any node with a label that is a prime number.\n    \n    Args:\n        graph (list): An adjacency list representation of the undirected graph.\n    \n    Returns:\n        int: The maximum number of disjoint subgraphs that satisfy the conditions.\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    max_subgraphs = 0\n\n    def is_perfect_square(num):\n        return int(sqrt(num)) ** 2 == num\n\n    def dfs(node, subgraph):\n        nonlocal max_subgraphs\n        visited[node] = True\n        subgraph.add(node)\n\n        if len(subgraph) >= 3 and is_perfect_square(sum(x**2 for x in subgraph)) and len(subgraph) % 2 == 0 and any(x % 3 == 0 for x in subgraph) and all(not is_prime(x) for x in subgraph):\n            max_subgraphs = max(max_subgraphs, 1)\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, subgraph)\n\n    for node in range(n):\n        if not visited[node]:\n            subgraph = set()\n            dfs(node, subgraph)\n\n    return max_subgraphs\n\n# Unit tests\ndef test_max_disjoint_subgraphs():\n    # Test case 1\n    graph2 = [[1, 2], [0, 2, 3], [0, 1, 3], [1, 2]]\n    assert max_disjoint_subgraphs(graph2) == 0\n\n    # Test case 2\n    graph3 = [[1, 2], [0, 2], [0, 1]]\n    assert max_disjoint_subgraphs(graph3) == 0\n\n    # Test case 3\n    graph4 = [[1, 2, 3], [0, 2, 3], [0, 1, 3], [0, 1, 2]]\n    assert max_disjoint_subgraphs(graph4) == 0\n\n    # Test case 4\n    graph5 = []\n    assert max_disjoint_subgraphs(graph5) == 0\n\n    print(\"All test cases passed!\")\n\ntest_max_disjoint_subgraphs()\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-47", "worker": "86afe36b19d0f78b"}, {"problem": "\nYou are given an array of integers `nums` and an integer `k`. Your task is to find the maximum possible product of any contiguous subarray of `nums` of length at most `k`, where the product of each element in the subarray must be a perfect square.\n\nImplement a function `maxSquareProductSubarray(nums, k)` that takes the input array `nums` and the integer `k`, and returns the maximum possible product of any contiguous subarray of `nums` of length at most `k`, where the product of each element in the subarray must be a perfect square.\n\nThe product of an empty subarray is considered to be 1.\n\nExample:\n- `maxSquareProductSubarray([2, 3, -2, 4], 2) == 16` (the subarray [2, 4] has the maximum product of 16, which is a perfect square)\n- `maxSquareProductSubarray([1, 2, 3, 4, 5], 3) == 36` (the subarray [2, 3, 4] has the maximum product of 24, which is a perfect square)\n- `maxSquareProductSubarray([1, 2, 3, 4, 5], 5) == 3125` (the subarray [1, 5] has the maximum product of 5, which is a perfect square)\n", "startingSolution": "\ndef maxProductSubarray(nums, k):\n    \"\"\"\n    Find the maximum possible product of any contiguous subarray of `nums` of length at most `k`.\n\n    Args:\n        nums (List[int]): An array of integers.\n        k (int): The maximum length of the subarray.\n\n    Returns:\n        int: The maximum possible product of any contiguous subarray of `nums` of length at most `k`.\n\n    Example:\n        >>> maxProductSubarray([2, 3, -2, 4], 2)\n        6\n    \"\"\"\n    pass\n", "unitTests": [{"nums": "[1, 2, 3, 4, 5]", "k": "3", "expectedOutput": "4"}, {"expectedOutput": "16", "nums": "[4, 4, 4, 4]", "k": "2"}, {"expectedOutput": "9", "nums": "[-4, 9, -4]", "k": "2"}, {"expectedOutput": "16", "nums": "[1, 4, 2, 4, 2, 4]", "k": "3"}], "solution": "import math\n\ndef is_perfect_square(num):\n    \"\"\"\n    Check if a given number is a perfect square.\n\n    Args:\n        num (int): The number to check.\n\n    Returns:\n        bool: True if the number is a perfect square, False otherwise.\n    \"\"\"\n    if num < 0:\n        return False\n    root = int(math.sqrt(num))\n    return root * root == num\n\ndef maxSquareProductSubarray(nums, k):\n    \"\"\"\n    Find the maximum possible product of any contiguous subarray of `nums` of length at most `k`, where the product of each element in the subarray must be a perfect square.\n\n    Args:\n        nums (List[int]): An array of integers.\n        k (int): The maximum length of the subarray.\n\n    Returns:\n        int: The maximum possible product of any contiguous subarray of `nums` of length at most `k`, where the product of each element in the subarray must be a perfect square.\n\n    Example:\n        >>> maxSquareProductSubarray([2, 3, -2, 4], 2)\n        16\n        >>> maxSquareProductSubarray([1, 2, 3, 4, 5], 3)\n        4\n        >>> maxSquareProductSubarray([1, 2, 3, 4, 5], 5)\n        25\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 1  \n\n    max_product = 1  \n    for i in range(n):\n        product = 1\n        for j in range(i, min(i + k, n)):\n            product *= nums[j]\n            if is_perfect_square(product):\n                max_product = max(max_product, product)\n\n    return max_product\n\n\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-48", "worker": "86afe36b19d0f78b"}, {"problem": "\nGiven an undirected graph represented as an adjacency list, where each node in the graph is labeled with a unique integer from 0 to n-1, where n is the total number of nodes, your task is to find the maximum number of disjoint subgraphs in the graph, where each subgraph satisfies the following conditions:\n\n1. The subgraph is connected (i.e., there is a path between any two nodes in the subgraph).\n2. The subgraph contains at least 3 nodes.\n3. The sum of the squares of the node labels in the subgraph is a perfect square.\n\nYour function should take an adjacency list representation of the graph as input and return the maximum number of disjoint subgraphs that satisfy the conditions.\n\nFor example, consider the following graph:\n\n```\n0 - 1 - 2\n|   |   |\n3 - 4 - 5\n```\n\nIn this graph, there are two disjoint subgraphs that satisfy the conditions:\n\n- Subgraph 1: [0, 1, 3, 4] (sum of squares: 0^2 + 1^2 + 3^2 + 4^2 = 50, which is a perfect square)\n- Subgraph 2: [2, 5] (sum of squares: 2^2 + 5^2 = 29, which is not a perfect square)\n\nTherefore, the maximum number of disjoint subgraphs that satisfy the conditions is 1.\n", "startingSolution": "import math\r\nfrom itertools import combinations\r\nfrom typing import List, Dict\r\n\r\n\r\ndef check_perfect_square(x: int) -> bool:\r\n    \"\"\"\r\n    Check if x is a perfect square.\r\n\r\n    Parameters:\r\n    x (int): The number to check for being a perfect square.\r\n\r\n    Returns:\r\n    bool: True if x is a perfect square, False otherwise.\r\n    \"\"\"\r\n    s = int(math.sqrt(x))\r\n    return s * s == x\r\n\r\n\r\ndef subgraph_is_connected(graph: Dict[int, List[int]], nodes: List[int]) -> bool:\r\n    \"\"\"\r\n    Check if a set of nodes forms a connected subgraph.\r\n\r\n    Parameters:\r\n    graph (Dict[int, List[int]]): The adjacency list representation of the graph.\r\n    nodes (List[int]): List of nodes to check for connectedness.\r\n\r\n    Returns:\r\n    bool: True if the nodes form a connected subgraph, False otherwise.\r\n    \"\"\"\r\n    if not nodes:\r\n        return False\r\n    visited = set()\r\n    stack = [nodes[0]]\r\n\r\n    while stack:\r\n        node = stack.pop()\r\n        if node not in visited:\r\n            visited.add(node)\r\n            for neighbor in graph[node]:\r\n                if neighbor in nodes and neighbor not in visited:\r\n                    stack.append(neighbor)\r\n\r\n    return visited == set(nodes)\r\n\r\n\r\ndef generate_subgraphs(graph: Dict[int, List[int]]) -> List[List[int]]:\r\n    \"\"\"\r\n    Generate all possible subgraphs of at least 3 nodes.\r\n\r\n    Parameters:\r\n    graph (Dict[int, List[int]]): The adjacency list representation of the graph.\r\n\r\n    Returns:\r\n    List[List[int]]: List of all possible subgraphs that satisfy the conditions.\r\n    \"\"\"\r\n    nodes = list(graph.keys())\r\n    n = len(nodes)\r\n    subgraphs = []\r\n\r\n    for size in range(3, n + 1):\r\n        for combo in combinations(nodes, size):\r\n            if subgraph_is_connected(graph, combo):\r\n                subgraphs.append(combo)\r\n\r\n    return subgraphs\r\n\r\n\r\ndef valid_subgraphs(graph: Dict[int, List[int]]) -> List[List[int]]:\r\n    \"\"\"\r\n    Filter subgraphs that satisfy the check perfect square condition.\r\n\r\n    Parameters:\r\n    graph (Dict[int, List[int]]): The adjacency list representation of the graph.\r\n\r\n    Returns:\r\n    List[List[int]]: List of subgraphs that satisfy the perfect square condition.\r\n    \"\"\"\r\n    subgraphs = generate_subgraphs(graph)\r\n    valid_subs = []\r\n\r\n    for subgraph in subgraphs:\r\n        sum_of_squares = sum(node * node for node in subgraph)\r\n        if check_perfect_square(sum_of_squares):\r\n            valid_subs.append(subgraph)\r\n\r\n    return valid_subs\r\n\r\n\r\ndef count_disjoint_subgraphs(graph: Dict[int, List[int]]) -> int:\r\n    \"\"\"\r\n    Count the maximum number of disjoint subgraphs that satisfy the conditions.\r\n\r\n    Parameters:\r\n    graph (Dict[int, List[int]]): The adjacency list representation of the graph.\r\n\r\n    Returns:\r\n    int: The maximum number of disjoint subgraphs that satisfy the conditions.\r\n    \"\"\"\r\n    valid_subs = valid_subgraphs(graph)\r\n\r\n    def is_disjoint(sub1: List[int], sub2: List[int]) -> bool:\r\n        return set(sub1).isdisjoint(set(sub2))\r\n\r\n    max_count = 0\r\n    n = len(valid_subs)\r\n\r\n    def backtrack(index: int, chosen_subs: List[List[int]]) -> None:\r\n        nonlocal max_count\r\n        if index == n:\r\n            max_count = max(max_count, len(chosen_subs))\r\n            return\r\n\r\n        backtrack(index + 1, chosen_subs)\r\n\r\n        if all(is_disjoint(valid_subs[index], sub) for sub in chosen_subs):\r\n            backtrack(index + 1, chosen_subs + [valid_subs[index]])\r\n\r\n    backtrack(0, [])\r\n    return max_count", "unitTests": [{"": "{     0: [1, 3],     1: [0, 2, 4],     2: [1, 5],     3: [0, 4],     4: [1, 3, 5],     5: [2, 4] }", "expectedOutput": "1"}, {"expectedOutput": "0", "": "{     0: [1, 2, 3],     1: [0, 2],     2: [0, 1],     3: [0] }"}, {"expectedOutput": "1", "": "{     0: [1, 2, 3],     1: [0, 2, 4],     2: [0, 1, 3],     3: [0, 2, 4],     4: [1, 3] }"}], "solution": "\nimport math\nfrom itertools import combinations\nfrom typing import List, Dict\n\ndef check_perfect_square(x: int) -> bool:\n    \"\"\"\n    Check if x is a perfect square.\n\n    Parameters:\n    x (int): The number to check for being a perfect square.\n\n    Returns:\n    bool: True if x is a perfect square, False otherwise.\n    \"\"\"\n    s = int(math.sqrt(x))\n    return s * s == x\n\ndef subgraph_is_connected(graph: Dict[int, List[int]], nodes: List[int]) -> bool:\n    \"\"\"\n    Check if a set of nodes forms a connected subgraph.\n\n    Parameters:\n    graph (Dict[int, List[int]]): The adjacency list representation of the graph.\n    nodes (List[int]): List of nodes to check for connectedness.\n\n    Returns:\n    bool: True if the nodes form a connected subgraph, False otherwise.\n    \"\"\"\n    if not nodes:\n        return False\n    visited = set()\n    stack = [nodes[0]]\n\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                if neighbor in nodes and neighbor not in visited:\n                    stack.append(neighbor)\n\n    return visited == set(nodes)\n\ndef generate_subgraphs(graph: Dict[int, List[int]]) -> List[List[int]]:\n    \"\"\"\n    Generate all possible subgraphs of at least 3 nodes.\n\n    Parameters:\n    graph (Dict[int, List[int]]): The adjacency list representation of the graph.\n\n    Returns:\n    List[List[int]]: List of all possible subgraphs that satisfy the conditions.\n    \"\"\"\n    nodes = list(graph.keys())\n    n = len(nodes)\n    subgraphs = []\n\n    for size in range(3, n + 1):\n        for combo in combinations(nodes, size):\n            if subgraph_is_connected(graph, combo):\n                subgraphs.append(combo)\n\n    return subgraphs\n\ndef valid_subgraphs(graph: Dict[int, List[int]]) -> List[List[int]]:\n    \"\"\"\n    Filter subgraphs that satisfy the check perfect square condition.\n\n    Parameters:\n    graph (Dict[int, List[int]]): The adjacency list representation of the graph.\n\n    Returns:\n    List[List[int]]: List of subgraphs that satisfy the perfect square condition.\n    \"\"\"\n    subgraphs = generate_subgraphs(graph)\n    valid_subs = []\n\n    for subgraph in subgraphs:\n        sum_of_squares = sum(node * node for node in subgraph)\n        if check_perfect_square(sum_of_squares):\n            valid_subs.append(subgraph)\n\n    return valid_subs\n\ndef count_disjoint_subgraphs(graph: Dict[int, List[int]]) -> int:\n    \"\"\"\n    Count the maximum number of disjoint subgraphs that satisfy the conditions.\n\n    Parameters:\n    graph (Dict[int, List[int]]): The adjacency list representation of the graph.\n\n    Returns:\n    int: The maximum number of disjoint subgraphs that satisfy the conditions.\n    \"\"\"\n    valid_subs = valid_subgraphs(graph)\n\n    def is_disjoint(sub1: List[int], sub2: List[int]) -> bool:\n        return set(sub1).isdisjoint(set(sub2))\n\n    max_count = 0\n    n = len(valid_subs)\n\n    def backtrack(index: int, chosen_subs: List[List[int]]) -> None:\n        nonlocal max_count\n        if index == n:\n            max_count = max(max_count, len(chosen_subs))\n            return\n\n        backtrack(index + 1, chosen_subs)\n\n        if all(is_disjoint(valid_subs[index], sub) for sub in chosen_subs):\n            backtrack(index + 1, chosen_subs + [valid_subs[index]])\n\n    backtrack(0, [])\n    return max_count\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-49", "worker": "c2610e1792c5cf07"}, {"problem": "\nGiven a 2D grid of integers representing a map, your task is to find the minimum number of steps required to reach the bottom-right corner of the grid from the top-left corner, while avoiding obstacles and maximizing the sum of the values of the cells visited along the path.\n\nThe input is a 2D array of integers, where each integer represents the value of a cell in the grid. A value of 0 indicates an obstacle that cannot be traversed. The goal is to find the path from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1), where m and n are the dimensions of the grid, that minimizes the number of steps while maximizing the sum of the values of the cells visited.\n\nThe function should return an object with two properties: \"steps\" and \"sum\". The \"steps\" property should be an integer representing the minimum number of steps required to reach the bottom-right corner, and the \"sum\" property should be an integer representing the maximum sum of the values of the cells visited along the path.\n\nExample:\nInput: [[1, 2, 3, 4, 5], [6, 0, 8, 9, 10], [11, 13, 0, 15, 16], [17, 18, 19, 20, 21]]\nOutput: { \"steps\": 10, \"sum\": 120 }\n\nIn this example, the optimal path is: (0, 0) -> (0, 1) -> (0, 2) -> (0, 3) -> (0, 4) -> (1, 4) -> (2, 4) -> (3, 4) -> (3, 3) -> (3, 2) -> (3, 1). The minimum number of steps is 10, and the maximum sum of the values of the cells visited is 120.\n", "startingSolution": "from typing import List, Dict\r\n\r\n\r\ndef min_steps_max_sum(grid: List[List[int]]) -> Dict[str, int]:\r\n    \"\"\"\r\n    Finds the minimum number of steps required to reach the bottom-right corner of the grid from the top-left corner,\r\n    while maximizing the sum of the values of the cells visited.\r\n\r\n    Args:\r\n        grid: A 2D array of integers representing the map with obstacles.\r\n\r\n    Returns:\r\n        A dictionary with two properties: \"steps\" and \"sum\".\r\n        \"steps\" represents the minimum number of steps required to reach the bottom-right corner.\r\n        \"sum\" represents the maximum sum of the values of the cells visited along the path.\r\n    \"\"\"\r\n\r\n    m, n = len(grid), len(grid[0])\r\n\r\n    if grid[0][0] == 0 or grid[m-1][n-1] == 0:\r\n        return {\"steps\": -1, \"sum\": -1}\r\n\r\n    dp = [[(float('inf'), -float('inf'))] * n for _ in range(m)]\r\n\r\n    dp[0][0] = (1, grid[0][0])\r\n\r\n    for steps in range(1, m + n - 1):\r\n        for i in range(min(steps, m - 1), max(0, steps - n + 1) - 1, -1):\r\n            j = steps - i\r\n            if j >= n:\r\n                continue\r\n\r\n            if grid[i][j] == 0:\r\n                dp[i][j] = (float('inf'), -float('inf'))\r\n                continue\r\n\r\n            for di, dj in [(-1, 0), (0, -1)]:\r\n                ni, nj = i + di, j + dj\r\n                if 0 <= ni < m and 0 <= nj < n:\r\n                    steps_to_ni, sum_to_ni = dp[ni][nj]\r\n                    if steps_to_ni == float('inf'):\r\n                        continue\r\n\r\n                    new_steps = steps_to_ni + 1\r\n                    new_sum = sum_to_ni + grid[i][j]\r\n\r\n                    if new_steps < dp[i][j][0] or (new_steps == dp[i][j][0] and new_sum > dp[i][j][1]):\r\n                        dp[i][j] = (new_steps, new_sum)\r\n\r\n    final_steps, final_sum = dp[m-1][n-1]\r\n    if final_steps == float('inf'):\r\n        return {\"steps\": -1, \"sum\": -1}\r\n    else:\r\n        return {\"steps\": final_steps, \"sum\": final_sum}", "unitTests": [{"": "[[1, 13, 20], [2, 0, 1], [2, 3, 19]]", "expectedOutput": "{'steps': 5, 'sum': 54}"}, {"expectedOutput": "{'steps': 5, 'sum': 29}", "": "[[9, 8, 7], [6, 5, 4], [3, 2, 1]]"}, {"expectedOutput": "{'steps': -1, 'sum': -1}", "": "[[1, 0, 0], [0, 0, 0], [0, 0, 1]]"}], "solution": "\nfrom typing import List, Dict\n\ndef min_steps_max_sum(grid: List[List[int]]) -> Dict[str, int]:\n    \"\"\"\n    Finds the minimum number of steps required to reach the bottom-right corner of the grid from the top-left corner,\n    while avoiding obstacles and maximizing the sum of the values of the cells visited.\n\n    Args:\n        grid: A 2D array of integers representing the map with obstacles.\n\n    Returns:\n        A dictionary with two properties: \"steps\" and \"sum\".\n        \"steps\" represents the minimum number of steps required to reach the bottom-right corner.\n        \"sum\" represents the maximum sum of the values of the cells visited along the path.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n\n    if grid[0][0] == 0 or grid[m-1][n-1] == 0:\n        return {\"steps\": -1, \"sum\": -1}\n\n    dp = [[(float('inf'), -float('inf'))] * n for _ in range(m)]\n    dp[0][0] = (1, grid[0][0])\n\n    for steps in range(1, m + n - 1):\n        for i in range(min(steps, m - 1), max(0, steps - n + 1) - 1, -1):\n            j = steps - i\n            if j >= n:\n                continue\n\n            if grid[i][j] == 0:\n                dp[i][j] = (float('inf'), -float('inf'))\n                continue\n\n            for di, dj in [(-1, 0), (0, -1)]:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n:\n                    steps_to_ni, sum_to_ni = dp[ni][nj]\n                    if steps_to_ni == float('inf'):\n                        continue\n\n                    new_steps = steps_to_ni + 1\n                    new_sum = sum_to_ni + grid[i][j]\n\n                    if new_steps < dp[i][j][0] or (new_steps == dp[i][j][0] and new_sum > dp[i][j][1]):\n                        dp[i][j] = (new_steps, new_sum)\n\n    final_steps, final_sum = dp[m-1][n-1]\n    if final_steps == float('inf'):\n        return {\"steps\": -1, \"sum\": -1}\n    else:\n        return {\"steps\": final_steps, \"sum\": final_sum}\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-50", "worker": "c2610e1792c5cf07"}, {"problem": "You are given a 2D grid where each cell represents a building with a certain height. The observation point is at the top-left corner of the grid (cell (0, 0)). The task is to determine how many buildings can be seen from this observation point, considering the following conditions:\n\nThe observation point can only see buildings that are taller than any building in its line of sight.\nIt can see a building if there are no taller buildings between the observation point and the building in any of the four cardinal directions (up, down, left, right).", "startingSolution": "\ndef count_visible_buildings(grid: list[list[int]]) -> int:\n    \"\"\"\n    Determine the number of buildings that can be seen from the observation point at the top-left corner of the given 2D grid.\n\n    The observation point can only see buildings that are taller than any building in its line of sight. It can see a building if there are no taller buildings between the observation point and the building in any of the four cardinal directions (up, down, left, right).\n\n    Args:\n        grid (list[list[int]]): A 2D grid where each cell represents a building with a certain height.\n\n    Returns:\n        int: The number of buildings that can be seen from the observation point.\n    \"\"\"\n  def max_visible_buildings(grid):\n    row, col = len(grid), len(grid[0])\n    count = 0\n    max_building = grid[0][0]\n    \n    # Check buildings to the right\n    for i in range(1, col):\n        if max_building < grid[0][i]:\n            count += 1\n            max_building = grid[0][i]\n    \n    # Check buildings downwards\n    max_building = grid[0][0]\n    for i in range(1, row):\n        if max_building < grid[i][0]:\n            count += 1\n            max_building = grid[i][0]\n    \n    # Check diagonal buildings (top-left to bottom-right)\n    max_building = grid[0][0]\n    for i in range(1, min(row, col)):\n        if max_building < grid[i][i]:\n            count +1\n            max_building = grid[i][i]\n    \n    return count\n\n", "unitTests": [{"expectedOutput": "5", "grid": "grid2 = [         [5, 4, 3, 2, 1]     ]"}, {"expectedOutput": "5", "grid": "grid3 = [         [6],         [5],         [4],         [3],         [2]     ]"}, {"expectedOutput": "4", "grid": " grid1 = [         [3, 2, 4, 1]]"}], "solution": "\ndef count_visible_buildings(grid: list[list[int]]) -> int:\n    \"\"\"\n    Determine the number of buildings that can be seen from the observation point at the top-left corner of the given 2D grid.\n\n    The observation point can only see buildings that are taller than any building in its line of sight. It can see a building if there are no taller buildings between the observation point and the building in any of the four cardinal directions (up, down, left, right).\n\n    Args:\n        grid (list[list[int]]): A 2D grid where each cell represents a building with a certain height.\n\n    Returns:\n        int: The number of buildings that can be seen from the observation point.\n    \"\"\"\n    def max_visible_buildings(grid):\n        row, col = len(grid), len(grid[0])\n        count = 0\n        max_building = grid[0][0]\n        \n        # Check buildings to the right\n        for i in range(1, col):\n            if max_building < grid[0][i]:\n                count += 1\n                max_building = grid[0][i]\n        \n        # Check buildings downwards\n        max_building = grid[0][0]\n        for i in range(1, row):\n            if max_building < grid[i][0]:\n                count += 1\n                max_building = grid[i][0]\n        \n        # Check diagonal buildings (top-left to bottom-right)\n        max_building = grid[0][0]\n        for i in range(1, min(row, col)):\n            if max_building < grid[i][i]:\n                count += 1\n                max_building = grid[i][i]\n        \n        return count\n\n    return max_visible_buildings(grid)\n", "meetsStartingSolutionFormatCriteria": false, "meetsFinalSolutionFormatCriteria": false, "meetsCorrectnessCriteria": false, "meetsDifficultyCriteria": false, "id": "example-51", "worker": "6e7b82a374b87eb3"}]